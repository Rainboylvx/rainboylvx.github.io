<!doctype html><html lang=zh-cn><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta http-equiv=cache-control content="max-age=0"><meta http-equiv=cache-control content="no-cache"><meta http-equiv=expires content="0"><meta http-equiv=expires content="Tue, 01 Jan 1980 1:00:00 GMT"><meta http-equiv=pragma content="no-cache"><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png }><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=manifest href=/site.webmanifest><meta name=theme-color media="(prefers-color-scheme: light)" content="#ffffff"><meta name=theme-color media="(prefers-color-scheme: dark)" content="#1b1b1b"><meta name=description content><script>(function(){const e=localStorage.getItem("theme")||(window.matchMedia("(prefers-color-scheme: dark)").matches?"dark":"light");document.documentElement.setAttribute("data-theme",e)})()</script><title>| Rainboy's Blog</title><style>:root{--background:#ffffff}@media(prefers-color-scheme:dark){:root{--background:#1b1b1b}}html{background-color:var(--background)}body{background-color:var(--background)}</style><link rel=stylesheet type=text/css href=/style.min.4de9e3236bcb55312d0b2ff0fc62c694f607b9c0d95d0621f6c6dbacb7d6dbb5.css media=all><link rel=stylesheet href=/grid.css><link href="https://fonts.font.im/css?family=Roboto+Mono" rel=stylesheet><style>body,.heti,.heti--sans{font-family:roboto mono,monospace,times new roman,times,heti song,serif,apple color emoji,segoe ui emoji,segoe ui symbol}</style></head><body><nav><ul class=menu><li><a tabindex=-1 class=menu-link href=/><u>H</u>ome</a></li><li><a tabindex=-1 class=menu-link href=/tags><u>T</u>ags</a></li><li><span style=cursor:pointer id=theme-switcher class=menu-link type=button><svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-moon h-4 w-4"><path d="M12 3a6 6 0 009 9 9 9 0 11-9-9z"/></svg></span></li></ul></nav><div id=single-header><h1></h1><div id=single-meta></div></div><main class="heti heti--classic"><h1 id=基于tcp的服务器端客户端>基于tcp的服务器端/客户端</h1><p>详细的内容看这里,我就不复制了:</p><p><a href=https://github.com/riba2534/TCP-IP-NetworkNote/blob/master/ch04/README.md target=_blank rel=noopener>https://github.com/riba2534/TCP-IP-NetworkNote/blob/master/ch04/README.md</a></p><p><p class=imgp><img loading=lazy src=https://camo.githubusercontent.com/270414295465a1c9e1cbd2f105bbd31b2d146d9282b431a8ab53aa369bfd137c/68747470733a2f2f692e6c6f6c692e6e65742f323031392f30312f31342f356333633231383839646230362e706e67 alt></p></p><p>TCP/IP 协议栈共分为 4 层，可以理解为数据收发分成了 4 个层次化过程，通过层次化的方式来解决问题</p><ul><li>链路层: 物理层,负责网络设备之间的通信，如网卡、网线等</li><li>IP层: 数据包进行中线选择</li><li>TCP/UDP层: 负责数据包的传输，保证数据包的可靠性和顺序性</li></ul><h2 id=实现基于-tcp-的服务器客户端>实现基于 TCP 的服务器/客户端</h2><p><p class=imgp><img loading=lazy src=https://camo.githubusercontent.com/69fcf57d2971b632de8b50baeab7039cd018c607363fc5c4f8c80f532362a5db/68747470733a2f2f692e6c6f6c692e6e65742f323031392f30312f31342f356333633237383261373831302e706e67 alt></p></p><p><p class=imgp><img loading=lazy src=https://camo.githubusercontent.com/2ded080eac322e985c4cd748055c169e7e832905497d93d0949fa45c08b69bfb/68747470733a2f2f692e6c6f6c692e6e65742f323031392f30312f31342f356333633331643737653836632e706e67 alt></p></p><h2 id=代码>代码:</h2><p>hello_server</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=ln>1</span><span class=cl><span class=p>{{</span><span class=err>#</span><span class=n>include</span> <span class=n>ch04</span><span class=o>/</span><span class=n>hello_server</span><span class=p>.</span><span class=n>c</span><span class=p>}}</span>
</span></span></code></pre></div><p>代码: hello_client</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=ln>1</span><span class=cl><span class=p>{{</span><span class=err>#</span><span class=n>include</span> <span class=n>ch04</span><span class=o>/</span><span class=n>hello_client</span><span class=p>.</span><span class=n>c</span><span class=p>}}</span>
</span></span></code></pre></div><h2 id=echo服务器客户端>echo服务器/客户端</h2><p>程序运行的基本方式：</p><ul><li>服务器端在同一时刻只与一个客户端相连，并提供回声服务。</li><li>服务器端依次向 5 个客户端提供服务并退出。<code>for</code>循环5次</li><li>客户端接受用户输入的字符串并发送到服务器端。</li><li>服务器端将接受的字符串数据传回客户端，即「回声」</li><li>服务器端与客户端之间的字符串回声一直执行到客户端输入 Q 为止。</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=ln>1</span><span class=cl><span class=p>{{</span><span class=err>#</span><span class=n>include</span> <span class=n>ch04</span><span class=o>/</span><span class=n>echo_server</span><span class=p>.</span><span class=n>c</span><span class=p>}}</span>
</span></span></code></pre></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=ln>1</span><span class=cl><span class=p>{{</span><span class=err>#</span><span class=n>include</span> <span class=n>ch04</span><span class=o>/</span><span class=n>echo_client</span><span class=p>.</span><span class=n>c</span><span class=p>}}</span>
</span></span></code></pre></div><h2 id=faq>FAQ</h2><p>问: 我在在linux下使用socket进行tcp网络编程,如果client端调用了close(sock)函数,那么server端口的read函数会读取到什么?</p><p>答:</p><p>在Linux下使用socket进行TCP网络编程时,如果客户端调用了<code>close(sock)</code>函数,服务器端的<code>read</code>函数的行为取决于客户端关闭连接的方式和时机。</p><p>通常情况下,当客户端调用<code>close(sock)</code>函数时,会向服务器发送一个FIN包,表示客户端想要关闭连接。服务器收到FIN包后,会做出以下响应:</p><ol><li><p>如果服务器已经读取了所有客户端发送的数据,那么<code>read</code>函数会返回0,表示已经到达文件末尾(EOF)。这意味着客户端已经关闭了连接,并且没有更多的数据可读。</p></li><li><p>如果服务器还没有读取完客户端发送的所有数据,那么<code>read</code>函数会继续读取剩余的数据,直到读取完所有数据或者遇到错误为止。在这种情况下,<code>read</code>函数会返回实际读取到的字节数。当所有数据读取完毕后,再次调用<code>read</code>函数会返回0,表示已经到达文件末尾(EOF)。</p></li><li><p>如果客户端在发送数据的过程中突然关闭了连接,那么服务器的<code>read</code>函数可能会返回一个错误,通常是<code>ECONNRESET</code>错误,表示连接被重置。</p></li></ol><p>需要注意的是,如果客户端在关闭连接之前没有发送所有的数据,那么服务器可能会丢失一部分数据。为了确保数据的完整性,通常建议在关闭连接之前,先调用<code>shutdown(sock, SHUT_WR)</code>函数,告诉操作系统不再发送数据,然后再调用<code>close(sock)</code>函数关闭连接。</p><p>总之,服务器端的<code>read</code>函数在客户端关闭连接时的行为取决于具体的情况:</p><ul><li>如果客户端发送了所有数据并关闭连接,<code>read</code>函数会返回0,表示EOF。</li><li>如果客户端关闭连接时还有未读取的数据,<code>read</code>函数会继续读取剩余数据,直到读取完毕,然后返回0,表示EOF。</li><li>如果客户端异常关闭连接,<code>read</code>函数可能会返回错误,如<code>ECONNRESET</code>。</li></ul><p>作为服务器端,需要正确处理这些不同的情况,以确保程序的正确性和鲁棒性。</p><p>问: 如何检测到 read函数返回一个错误, 例如是ECONNRESET?</p><p>在Linux系统中,当<code>read</code>函数返回错误时,会设置全局变量<code>errno</code>来指示具体的错误类型。你可以通过检查<code>errno</code>的值来判断是否发生了<code>ECONNRESET</code>错误。</p><p>下面是一个示例代码,演示了如何检测<code>read</code>函数返回的错误:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=ln> 1</span><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;stdio.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=ln> 2</span><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;stdlib.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=ln> 3</span><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;unistd.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=ln> 4</span><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;errno.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=ln> 5</span><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;string.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=ln> 6</span><span class=cl><span class=cp></span>
</span></span><span class=line><span class=ln> 7</span><span class=cl><span class=kt>ssize_t</span> <span class=nf>read_data</span><span class=p>(</span><span class=kt>int</span> <span class=n>sockfd</span><span class=p>,</span> <span class=kt>void</span> <span class=o>*</span><span class=n>buf</span><span class=p>,</span> <span class=kt>size_t</span> <span class=n>len</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=ln> 8</span><span class=cl>    <span class=kt>ssize_t</span> <span class=n>num_read</span> <span class=o>=</span> <span class=nf>read</span><span class=p>(</span><span class=n>sockfd</span><span class=p>,</span> <span class=n>buf</span><span class=p>,</span> <span class=n>len</span><span class=p>);</span>
</span></span><span class=line><span class=ln> 9</span><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>num_read</span> <span class=o>==</span> <span class=o>-</span><span class=mi>1</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=ln>10</span><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=n>errno</span> <span class=o>==</span> <span class=n>ECONNRESET</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=ln>11</span><span class=cl>            <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;Connection reset by peer</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=ln>12</span><span class=cl>        <span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
</span></span><span class=line><span class=ln>13</span><span class=cl>            <span class=nf>perror</span><span class=p>(</span><span class=s>&#34;read&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=ln>14</span><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=ln>15</span><span class=cl>        <span class=k>return</span> <span class=o>-</span><span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=ln>16</span><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=ln>17</span><span class=cl>    <span class=k>return</span> <span class=n>num_read</span><span class=p>;</span>
</span></span><span class=line><span class=ln>18</span><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>在上面的代码中,<code>read_data</code>函数封装了<code>read</code>函数的调用。它检查<code>read</code>函数的返回值:</p><ul><li>如果返回值为-1,表示发生了错误。此时,通过检查<code>errno</code>的值来判断具体的错误类型:<ul><li>如果<code>errno</code>的值等于<code>ECONNRESET</code>,表示连接被对端重置,可以输出相应的错误信息。</li><li>否则,可以使用<code>perror</code>函数输出错误信息,<code>perror</code>函数会根据<code>errno</code>的值自动生成对应的错误描述。</li></ul></li><li>如果返回值不为-1,表示读取成功,函数返回实际读取到的字节数。</li></ul><p>在实际使用时,你可以根据需要对<code>read_data</code>函数进行调用,并根据返回值进行相应的处理:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=ln>1</span><span class=cl><span class=kt>char</span> <span class=n>buffer</span><span class=p>[</span><span class=mi>1024</span><span class=p>];</span>
</span></span><span class=line><span class=ln>2</span><span class=cl><span class=kt>ssize_t</span> <span class=n>num_read</span> <span class=o>=</span> <span class=nf>read_data</span><span class=p>(</span><span class=n>sockfd</span><span class=p>,</span> <span class=n>buffer</span><span class=p>,</span> <span class=k>sizeof</span><span class=p>(</span><span class=n>buffer</span><span class=p>));</span>
</span></span><span class=line><span class=ln>3</span><span class=cl><span class=k>if</span> <span class=p>(</span><span class=n>num_read</span> <span class=o>==</span> <span class=o>-</span><span class=mi>1</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=ln>4</span><span class=cl>    <span class=c1>// 处理错误情况
</span></span></span><span class=line><span class=ln>5</span><span class=cl><span class=c1></span><span class=p>}</span> <span class=k>else</span> <span class=k>if</span> <span class=p>(</span><span class=n>num_read</span> <span class=o>==</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=ln>6</span><span class=cl>    <span class=c1>// 处理连接关闭的情况
</span></span></span><span class=line><span class=ln>7</span><span class=cl><span class=c1></span><span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
</span></span><span class=line><span class=ln>8</span><span class=cl>    <span class=c1>// 处理成功读取数据的情况
</span></span></span><span class=line><span class=ln>9</span><span class=cl><span class=c1></span><span class=p>}</span>
</span></span></code></pre></div><p>通过检查<code>read_data</code>函数的返回值,你可以判断是否发生了错误,并根据具体的错误类型采取相应的处理措施。</p><p>总之,通过检查<code>read</code>函数的返回值和<code>errno</code>的值,你可以检测并处理<code>read</code>函数返回的错误,包括<code>ECONNRESET</code>错误。这样可以增强程序的健壮性和可靠性。</p></main><br><footer><div class=footer-info><p>Copyright &copy; 2025 Rainboy. All rights reserved.
<span>| Last build: 2025-10-18 12:42:21</span></p></div><script defer>document.addEventListener("keydown",function(e){if(document.activeElement.isContentEditable)return!1;if(document.activeElement.tagName=="INPUT")return!1;if(e.altKey||e.ctrlKey||e.shiftKey)return!1;var t=e.key;if(t==="h")e.preventDefault(),e.stopPropagation(),window.location.href="/";else if(t==="t")e.preventDefault(),e.stopPropagation(),window.location.href=`https://${location.hostname}/tags`;else if(t==="i"){e.preventDefault(),e.stopPropagation();const t=document.querySelectorAll("input");for(let e=0;e<t.length;e++)if(t[e].offsetParent!==null){t[e].selectionStart=t[e].selectionEnd=t[e].value.length,t[e].focus();break}}return!1})</script><script defer>function throttle(e,t){var n=Date.now();return function(){var s=Date.now();n+t-s<0&&(e(),n=s)}}function scrollHandler(){const e=Array.from(document.querySelectorAll("body h2, body h3"));function t(){for(var n,s,o,i=window.pageYOffset||document.documentElement.scrollTop,t=0;t<e.length;t++)s=e[t].getAttribute("id"),n=document.querySelector('nav ul li a[href="#'+s+'"]'),n&&n.classList.remove("active-toc");for(t=e.length-1;t>=0;t--)if(o=e[t].offsetTop,i>o-75&&(s=e[t].getAttribute("id"),n=document.querySelector('nav ul li a[href="#'+s+'"]'),n)){n.classList.add("active-toc");break}}window.addEventListener("scroll",throttle(t,200))}setTimeout(scrollHandler,100)</script><script defer>function addCopyButtonToCodeBlocks(){const e=document.querySelectorAll('code[class^="language-"]:not(.output):not([class*="language-console"])');e.forEach(e=>{const t=document.createElement("button");t.classList.add("copy-code-button"),t.innerHTML="copy",t.addEventListener("click",()=>{const s=e.querySelectorAll(".cl");let n="";s.forEach(e=>{n+=e.innerText}),navigator.clipboard.writeText(n),t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},1500)}),e.parentNode.before(t)})}setTimeout(function(){addCopyButtonToCodeBlocks()},100)</script><script defer src=/js/theme-switcher.js></script></footer></body></html>