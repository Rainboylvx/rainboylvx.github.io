<!doctype html><html lang=zh-cn><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta http-equiv=cache-control content="max-age=0"><meta http-equiv=cache-control content="no-cache"><meta http-equiv=expires content="0"><meta http-equiv=expires content="Tue, 01 Jan 1980 1:00:00 GMT"><meta http-equiv=pragma content="no-cache"><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png }><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=manifest href=/site.webmanifest><meta name=theme-color media="(prefers-color-scheme: light)" content="#ffffff"><meta name=theme-color media="(prefers-color-scheme: dark)" content="#1b1b1b"><meta name=description content><script>(function(){const e=localStorage.getItem("theme")||(window.matchMedia("(prefers-color-scheme: dark)").matches?"dark":"light");document.documentElement.setAttribute("data-theme",e)})()</script><title>| Rainboy's Blog</title><style>:root{--background:#ffffff}@media(prefers-color-scheme:dark){:root{--background:#1b1b1b}}html{background-color:var(--background)}body{background-color:var(--background)}</style><link rel=stylesheet type=text/css href=/style.min.9e52618e081d7542403ff6356f894d993b93e26eb37d3f072c70cd92f0c439ab.css media=all><link rel=stylesheet href=/grid.css><link href="https://fonts.font.im/css?family=Roboto+Mono" rel=stylesheet><style>body,.heti,.heti--sans{font-family:roboto mono,monospace,times new roman,times,heti song,serif,apple color emoji,segoe ui emoji,segoe ui symbol}</style></head><body><nav><ul class=menu><li><a tabindex=-1 class=menu-link href=/><u>H</u>ome</a></li><li><a tabindex=-1 class=menu-link href=/tags><u>T</u>ags</a></li><li><span style=cursor:pointer id=theme-switcher class=menu-link type=button><svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-moon h-4 w-4"><path d="M12 3a6 6 0 009 9 9 9 0 11-9-9z"/></svg></span></li></ul></nav><div id=single-header><h1></h1><div id=single-meta></div></div><main class="heti heti--classic"><h2 id=第-9-章-套接字的多种可选项>第 9 章 套接字的多种可选项</h2><p>本章代码，在<a href=https://github.com/riba2534/TCP-IP-NetworkNote target=_blank rel=noopener>TCP-IP-NetworkNote</a>中可以找到。</p><h3 id=91-套接字可选项和-io-缓冲大小>9.1 套接字可选项和 I/O 缓冲大小</h3><p>我们进行套接字编程时往往只关注数据通信，而忽略了套接字具有的不同特性。但是，理解这些特性并根据实际需要进行更改也很重要</p><h4 id=911-套接字多种可选项>9.1.1 套接字多种可选项</h4><p>我们之前写得程序都是创建好套接字之后直接使用的，此时通过默认的套接字特性进行数据通信，这里列出了一些套接字可选项。</p><table><thead><tr><th style=text-align:center>协议层</th><th style=text-align:center>选项名</th><th style=text-align:center>读取</th><th style=text-align:center>设置</th></tr></thead><tbody><tr><td style=text-align:center>SOL_SOCKET</td><td style=text-align:center>SO_SNDBUF</td><td style=text-align:center>O</td><td style=text-align:center>O</td></tr><tr><td style=text-align:center>SOL_SOCKET</td><td style=text-align:center>SO_RCVBUF</td><td style=text-align:center>O</td><td style=text-align:center>O</td></tr><tr><td style=text-align:center>SOL_SOCKET</td><td style=text-align:center>SO_REUSEADDR</td><td style=text-align:center>O</td><td style=text-align:center>O</td></tr><tr><td style=text-align:center>SOL_SOCKET</td><td style=text-align:center>SO_KEEPALIVE</td><td style=text-align:center>O</td><td style=text-align:center>O</td></tr><tr><td style=text-align:center>SOL_SOCKET</td><td style=text-align:center>SO_BROADCAST</td><td style=text-align:center>O</td><td style=text-align:center>O</td></tr><tr><td style=text-align:center>SOL_SOCKET</td><td style=text-align:center>SO_DONTROUTE</td><td style=text-align:center>O</td><td style=text-align:center>O</td></tr><tr><td style=text-align:center>SOL_SOCKET</td><td style=text-align:center>SO_OOBINLINE</td><td style=text-align:center>O</td><td style=text-align:center>O</td></tr><tr><td style=text-align:center>SOL_SOCKET</td><td style=text-align:center>SO_ERROR</td><td style=text-align:center>O</td><td style=text-align:center>X</td></tr><tr><td style=text-align:center>SOL_SOCKET</td><td style=text-align:center>SO_TYPE</td><td style=text-align:center>O</td><td style=text-align:center>X</td></tr><tr><td style=text-align:center>IPPROTO_IP</td><td style=text-align:center>IP_TOS</td><td style=text-align:center>O</td><td style=text-align:center>O</td></tr><tr><td style=text-align:center>IPPROTO_IP</td><td style=text-align:center>IP_TTL</td><td style=text-align:center>O</td><td style=text-align:center>O</td></tr><tr><td style=text-align:center>IPPROTO_IP</td><td style=text-align:center>IP_MULTICAST_TTL</td><td style=text-align:center>O</td><td style=text-align:center>O</td></tr><tr><td style=text-align:center>IPPROTO_IP</td><td style=text-align:center>IP_MULTICAST_LOOP</td><td style=text-align:center>O</td><td style=text-align:center>O</td></tr><tr><td style=text-align:center>IPPROTO_IP</td><td style=text-align:center>IP_MULTICAST_IF</td><td style=text-align:center>O</td><td style=text-align:center>O</td></tr><tr><td style=text-align:center>IPPROTO_TCP</td><td style=text-align:center>TCP_KEEPALIVE</td><td style=text-align:center>O</td><td style=text-align:center>O</td></tr><tr><td style=text-align:center>IPPROTO_TCP</td><td style=text-align:center>TCP_NODELAY</td><td style=text-align:center>O</td><td style=text-align:center>O</td></tr><tr><td style=text-align:center>IPPROTO_TCP</td><td style=text-align:center>TCP_MAXSEG</td><td style=text-align:center>O</td><td style=text-align:center>O</td></tr></tbody></table><p>从表中可以看出，套接字可选项是分层的。</p><ul><li><p>IPPROTO_IP 可选项是IP协议相关事项</p></li><li><p>IPPROTO_TCP 层可选项是 TCP 协议的相关事项</p></li><li><p>SOL_SOCKET 层是套接字的通用可选项。</p></li></ul><h4 id=912-getsockopt--setsockopt>9.1.2 <code>getsockopt</code> & <code>setsockopt</code></h4><p>可选项的读取和设置通过以下两个函数来完成</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=ln> 1</span><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;sys/socket.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=ln> 2</span><span class=cl><span class=cp></span>
</span></span><span class=line><span class=ln> 3</span><span class=cl><span class=kt>int</span> <span class=nf>getsockopt</span><span class=p>(</span><span class=kt>int</span> <span class=n>sock</span><span class=p>,</span> <span class=kt>int</span> <span class=n>level</span><span class=p>,</span> <span class=kt>int</span> <span class=n>optname</span><span class=p>,</span> <span class=kt>void</span> <span class=o>*</span><span class=n>optval</span><span class=p>,</span> <span class=kt>socklen_t</span> <span class=o>*</span><span class=n>optlen</span><span class=p>);</span>
</span></span><span class=line><span class=ln> 4</span><span class=cl><span class=cm>/*
</span></span></span><span class=line><span class=ln> 5</span><span class=cl><span class=cm>成功时返回 0 ，失败时返回 -1
</span></span></span><span class=line><span class=ln> 6</span><span class=cl><span class=cm>sock: 用于查看选项套接字文件描述符
</span></span></span><span class=line><span class=ln> 7</span><span class=cl><span class=cm>level: 要查看的可选项协议层
</span></span></span><span class=line><span class=ln> 8</span><span class=cl><span class=cm>optname: 要查看的可选项名
</span></span></span><span class=line><span class=ln> 9</span><span class=cl><span class=cm>optval: 保存查看结果的缓冲地址值
</span></span></span><span class=line><span class=ln>10</span><span class=cl><span class=cm>optlen: 向第四个参数传递的缓冲大小。调用函数候，该变量中保存通过第四个参数返回的可选项信息的字节数。
</span></span></span><span class=line><span class=ln>11</span><span class=cl><span class=cm>*/</span>
</span></span></code></pre></div><p>上述函数可以用来读取套接字可选项，下面的函数可以更改可选项：d</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=ln> 1</span><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;sys/socket.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=ln> 2</span><span class=cl><span class=cp></span>
</span></span><span class=line><span class=ln> 3</span><span class=cl><span class=kt>int</span> <span class=nf>setsockopt</span><span class=p>(</span><span class=kt>int</span> <span class=n>sock</span><span class=p>,</span> <span class=kt>int</span> <span class=n>level</span><span class=p>,</span> <span class=kt>int</span> <span class=n>optname</span><span class=p>,</span> <span class=k>const</span> <span class=kt>void</span> <span class=o>*</span><span class=n>optval</span><span class=p>,</span> <span class=kt>socklen_t</span> <span class=n>optlen</span><span class=p>);</span>
</span></span><span class=line><span class=ln> 4</span><span class=cl><span class=cm>/*
</span></span></span><span class=line><span class=ln> 5</span><span class=cl><span class=cm>成功时返回 0 ，失败时返回 -1
</span></span></span><span class=line><span class=ln> 6</span><span class=cl><span class=cm>sock: 用于更改选项套接字文件描述符
</span></span></span><span class=line><span class=ln> 7</span><span class=cl><span class=cm>level: 要更改的可选项协议层
</span></span></span><span class=line><span class=ln> 8</span><span class=cl><span class=cm>optname: 要更改的可选项名
</span></span></span><span class=line><span class=ln> 9</span><span class=cl><span class=cm>optval: 保存更改结果的缓冲地址值
</span></span></span><span class=line><span class=ln>10</span><span class=cl><span class=cm>optlen: 向第四个参数传递的缓冲大小。调用函数后，该变量中保存通过第四个参数返回的可选项信息的字节数。
</span></span></span><span class=line><span class=ln>11</span><span class=cl><span class=cm>*/</span>
</span></span></code></pre></div><p>下面的代码可以看出 getsockopt 的使用方法。下面示例用协议层为 SOL_SOCKET 、名为 SO_TYPE 的可选项查看套接字类型（TCP 和 UDP ）。</p><ul><li><a href=https://github.com/riba2534/TCP-IP-NetworkNote/blob/master/ch09/sock_type.c target=_blank rel=noopener>sock_type.c</a></li></ul><p>编译运行：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=ln>1</span><span class=cl>gcc sock_type.c -o sock_type
</span></span><span class=line><span class=ln>2</span><span class=cl>./sock_type
</span></span></code></pre></div><p>结果：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=ln>1</span><span class=cl>SOCK_STREAM: 1
</span></span><span class=line><span class=ln>2</span><span class=cl>SOCK_DGRAM: 2
</span></span><span class=line><span class=ln>3</span><span class=cl>Socket type one: 1
</span></span><span class=line><span class=ln>4</span><span class=cl>Socket type two: 2
</span></span></code></pre></div><p>首先创建了一个 TCP 套接字和一个 UDP 套接字。然后通过调用 getsockopt 函数来获得当前套接字的状态。</p><p>用于验证套接类型的 SO_TYPE 是只读可选项，因为<strong>套接字类型只能在创建时决定，以后不能再更改</strong>。</p><h4 id=913-so_sndbuf--so_rcvbuf>9.1.3 <code>SO_SNDBUF</code> & <code>SO_RCVBUF</code></h4><p>创建套接字的同时会生成 I/O 缓冲。关于 I/O 缓冲，可以去看第五章。</p><p>SO_RCVBUF 是输入缓冲大小相关可选项，SO_SNDBUF 是输出缓冲大小相关可选项。用这 2 个可选项既可以读取当前 I/O 大小，也可以进行更改。通过下列示例读取创建套接字时默认的 I/O 缓冲大小。</p><ul><li><a href=https://github.com/riba2534/TCP-IP-NetworkNote/blob/master/ch09/get_buf.c target=_blank rel=noopener>get_buf.c</a></li></ul><p>编译运行：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=ln>1</span><span class=cl>gcc get_buf.c -o getbuf
</span></span><span class=line><span class=ln>2</span><span class=cl>./getbuf
</span></span></code></pre></div><p>运行结果：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=ln>1</span><span class=cl>Input buffer size: 87380
</span></span><span class=line><span class=ln>2</span><span class=cl>Output buffer size: 16384
</span></span></code></pre></div><p>可以看出本机的输入缓冲和输出缓冲大小。</p><p>下面的代码演示了，通过程序设置 I/O 缓冲区的大小</p><ul><li><a href=https://github.com/riba2534/TCP-IP-NetworkNote/blob/master/ch09/set_buf.c target=_blank rel=noopener>set_buf.c</a></li></ul><p>编译运行：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=ln>1</span><span class=cl>gcc get_buf.c -o setbuf
</span></span><span class=line><span class=ln>2</span><span class=cl>./setbuf
</span></span></code></pre></div><p>结果:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=ln>1</span><span class=cl>Input buffer size: 6144
</span></span><span class=line><span class=ln>2</span><span class=cl>Output buffer size: 6144
</span></span></code></pre></div><p>输出结果和我们预想的不是很相同，缓冲大小的设置需谨慎处理，因此不会完全按照我们的要求进行。</p><h3 id=92-so_reuseaddr>9.2 <code>SO_REUSEADDR</code></h3><h4 id=921-发生地址分配错误binding-error>9.2.1 发生地址分配错误（Binding Error）</h4><p>在学习 SO_REUSEADDR 可选项之前，应该好好理解 Time-wait 状态。看以下代码的示例：</p><ul><li><a href=https://github.com/riba2534/TCP-IP-NetworkNote/blob/master/ch09/reuseadr_eserver.c target=_blank rel=noopener>reuseadr_eserver.c</a></li></ul><p>这是一个回声服务器的服务端代码，可以配合第四章的 <a href=https://github.com/riba2534/TCP-IP-NetworkNote/blob/master/ch04/echo_client.c target=_blank rel=noopener>echo_client.c</a> 使用，在这个代码中，客户端通知服务器终止程序。在客户端控制台输入 Q 可以结束程序，向服务器发送 FIN 消息并经过四次握手过程。当然，输入 CTRL+C 也会向服务器传递 FIN 信息。强制终止程序时，由操作系统关闭文件套接字，此过程相当于调用 close 函数，也会向服务器发送 FIN 消息。</p><p>这样看不到是什么特殊现象，考虑以下情况：</p><blockquote><p>服务器端和客户端都已经建立连接的状态下，向服务器控制台输入 CTRL+C ，强制关闭服务端</p></blockquote><p>如果用这种方式终止程序，如果用同一端口号再次运行服务端，就会输出「bind() error」消息，并且无法再次运行。但是在这种情况下，再过大约 3 分钟就可以重新运行服务端。</p><h4 id=922-time-wait-状态>9.2.2 <code>Time-wait</code> 状态</h4><p>观察以下过程：</p><p><p class=imgp><img loading=lazy src=https://i.loli.net/2019/01/19/5c42db182cade.png alt></p></p><p>假设图中主机 A 是服务器，因为是主机 A 向 B 发送 FIN 消息，故可想象成服务器端在控制台中输入 CTRL+C 。但是问题是，套接字经过四次握手后并没有立即消除，而是要经过一段时间的 Time-wait 状态。当然，只有先断开连接的（先发送 FIN 消息的）主机才经过 Time-wait 状态。因此，若服务器端先断开连接，则无法立即重新运行。套接字处在 Time-wait 过程时，相应端口是正在使用的状态。因此，就像之前验证过的，bind 函数调用过程中会发生错误。</p><p><strong>实际上，不论是服务端还是客户端，都要经过一段时间的 Time-wait 过程。先断开连接的套接字必然会经过 Time-wait 过程，但是由于客户端套接字的端口是任意指定的，所以无需过多关注 Time-wait 状态。</strong></p><p>那到底为什么会有 Time-wait 状态呢，在图中假设，主机 A 向主机 B 传输 ACK 消息（SEQ 5001 , ACK 7502 ）后立刻消除套接字。但是最后这条 ACK 消息在传递过程中丢失，没有传递主机 B ，这时主机 B 就会试图重传。但是此时主机 A 已经是完全终止状态，因此主机 B 永远无法收到从主机 A 最后传来的 ACK 消息。基于这些问题的考虑，所以要设计 Time-wait 状态。</p><h4 id=923-地址再分配>9.2.3 地址再分配</h4><p>Time-wait 状态看似重要，但是不一定讨人喜欢。如果系统发生故障紧急停止，这时需要尽快重启服务起以提供服务，但因处于 Time-wait 状态而必须等待几分钟。因此，Time-wait 并非只有优点，这些情况下容易引发大问题。下图中展示了四次握手时不得不延长 Time-wait 过程的情况。</p><p><p class=imgp><img loading=lazy src=https://i.loli.net/2019/01/19/5c42dec2ba42b.png alt></p></p><p>从图上可以看出，在主机 A 四次握手的过程中，如果最后的数据丢失，则主机 B 会认为主机 A 未能收到自己发送的 FIN 信息，因此重传。这时，收到的 FIN 消息的主机 A 将重启 Time-wait 计时器。因此，如果网络状况不理想， Time-wait 将持续。</p><p>解决方案就是在套接字的可选项中更改 SO_REUSEADDR 的状态。适当调整该参数，可将 Time-wait 状态下的套接字端口号重新分配给新的套接字。SO_REUSEADDR 的默认值为 0.这就意味着无法分配 Time-wait 状态下的套接字端口号。因此需要将这个值改成 1 。具体作法已在示例 <a href=https://github.com/riba2534/TCP-IP-NetworkNote/blob/master/ch09/reuseadr_eserver.c target=_blank rel=noopener>reuseadr_eserver.c</a> 给出，只需要把注释掉的东西解除注释即可。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=ln>1</span><span class=cl><span class=n>optlen</span> <span class=o>=</span> <span class=k>sizeof</span><span class=p>(</span><span class=n>option</span><span class=p>);</span>
</span></span><span class=line><span class=ln>2</span><span class=cl><span class=n>option</span> <span class=o>=</span> <span class=n>TRUE</span><span class=p>;</span>
</span></span><span class=line><span class=ln>3</span><span class=cl><span class=nf>setsockopt</span><span class=p>(</span><span class=n>serv_sock</span><span class=p>,</span> <span class=n>SOL_SOCKET</span><span class=p>,</span> <span class=n>SO_REUSEADDR</span><span class=p>,</span> <span class=p>(</span><span class=kt>void</span> <span class=o>*</span><span class=p>)</span><span class=o>&amp;</span><span class=n>option</span><span class=p>,</span> <span class=n>optlen</span><span class=p>);</span>
</span></span></code></pre></div><p>此时，已经解决了上述问题。</p><h3 id=93-tcp_nodelay>9.3 <code>TCP_NODELAY</code></h3><h4 id=931-nagle-算法>9.3.1 <code>Nagle</code> 算法</h4><p>为了防止因数据包过多而发生网络过载，<code>Nagle</code> 算法诞生了。它应用于 TCP 层。它是否使用会导致如图所示的差异：</p><p><p class=imgp><img loading=lazy src=https://i.loli.net/2019/01/19/5c42e12abc5b8.png alt></p></p><p>图中展示了通过 <code>Nagle</code> 算法发送字符串 <code>Nagle</code> 和未使用 <code>Nagle</code> 算法的差别。可以得到一个结论。</p><p><strong>只有接收到前一数据的 ACK 消息， <code>Nagle</code> 算法才发送下一数据。</strong></p><p>TCP 套接字默认使用 <code>Nagle</code> 算法交换数据，因此最大限度的进行缓冲，直到收到 ACK 。左图也就是说一共传递 4 个数据包以传输一个字符串。从右图可以看出，发送数据包一共使用了 10 个数据包。由此可知，不使用 <code>Nagle</code> 算法将对网络流量产生负面影响。即使只传输一个字节的数据，其头信息都可能是几十个字节。因此，为了提高网络传输效率，必须使用 <code>Nagle</code> 算法。</p><p><code>Nagle</code> 算法并不是什么情况下都适用，网络流量未受太大影响时，不使用 <code>Nagle</code> 算法要比使用它时传输速度快。最典型的就是「传输大文数据」。将文件数据传入输出缓冲不会花太多时间，因此，不使用 <code>Nagle</code> 算法，也会在装满输出缓冲时传输数据包。这不仅不会增加数据包的数量，反而在无需等待 ACK 的前提下连续传输，因此可以大大提高传输速度。</p><p>所以，未准确判断数据性质时不应禁用 <code>Nagle</code> 算法。</p><h4 id=932-禁用-nagle-算法>9.3.2 禁用 <code>Nagle</code> 算法</h4><p>禁用 <code>Nagle</code> 算法应该使用：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=ln>1</span><span class=cl><span class=kt>int</span> <span class=n>opt_val</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=ln>2</span><span class=cl><span class=nf>setsockopt</span><span class=p>(</span><span class=n>sock</span><span class=p>,</span> <span class=n>IPPROTO_TCP</span><span class=p>,</span> <span class=n>TCP_NODELAY</span><span class=p>,</span> <span class=p>(</span><span class=kt>void</span> <span class=o>*</span><span class=p>)</span><span class=o>&amp;</span><span class=n>opt_val</span><span class=p>,</span> <span class=k>sizeof</span><span class=p>(</span><span class=n>opt_val</span><span class=p>));</span>
</span></span></code></pre></div><p>通过 TCP_NODELAY 的值来查看<code>Nagle</code> 算法的设置状态。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=ln>1</span><span class=cl><span class=n>opt_len</span> <span class=o>=</span> <span class=k>sizeof</span><span class=p>(</span><span class=n>opt_val</span><span class=p>);</span>
</span></span><span class=line><span class=ln>2</span><span class=cl><span class=nf>getsockopt</span><span class=p>(</span><span class=n>sock</span><span class=p>,</span> <span class=n>IPPROTO_TCP</span><span class=p>,</span> <span class=n>TCP_NODELAY</span><span class=p>,</span> <span class=p>(</span><span class=kt>void</span> <span class=o>*</span><span class=p>)</span><span class=o>&amp;</span><span class=n>opt_val</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>opt_len</span><span class=p>);</span>
</span></span></code></pre></div><p>如果正在使用<code>Nagle</code> 算法，那么 opt_val 值为 0，如果禁用则为 1.</p><p>关于这个算法，可以参考这个回答：<a href=https://www.zhihu.com/question/42308970/answer/246334766 target=_blank rel=noopener>TCP连接中启用和禁用TCP_NODELAY有什么影响？</a></p><h3 id=94-基于-windows-的实现>9.4 基于 Windows 的实现</h3><p>暂略</p><h3 id=95-习题>9.5 习题</h3><blockquote><p>以下答案仅代表本人个人观点，可能不是正确答案。</p></blockquote><ol><li><p><strong>下列关于 Time-wait 状态的说法错误的是？</strong></p><p>答：以下字体加粗的代表正确。</p><ol><li>Time-wait 状态只在服务器的套接字中发生</li><li><strong>断开连接的四次握手过程中，先传输 FIN 消息的套接字将进入 Time-wait 状态。</strong></li><li>Time-wait 状态与断开连接的过程无关，而与请求连接过程中 SYN 消息的传输顺序有关</li><li>Time-wait 状态通常并非必要，应尽可能通过更改套接字可选项来防止其发生</li></ol></li><li><p><strong>TCP_NODELAY 可选项与 Nagle 算法有关，可通过它禁用 Nagle 算法。请问何时应考虑禁用 Nagle 算法？结合收发数据的特性给出说明。</strong></p><p>答：当网络流量未受太大影响时，不使用 Nagle 算法要比使用它时传输速度快，比如说在传输大文件时。</p></li></ol><h2 id=代码>代码</h2><p>get_buf.c</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=ln>1</span><span class=cl><span class=p>{{</span><span class=err>#</span><span class=n>include</span> <span class=n>chapter_9</span><span class=o>/</span><span class=n>get_buf</span><span class=p>.</span><span class=n>c</span><span class=p>}}</span>
</span></span></code></pre></div><p>set_buf</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=ln>1</span><span class=cl><span class=p>{{</span><span class=err>#</span><span class=n>include</span> <span class=n>chapter_9</span><span class=o>/</span><span class=n>set_buf</span><span class=p>.</span><span class=n>c</span><span class=p>}}</span>
</span></span></code></pre></div><p>reuseadr_eserver</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=ln>1</span><span class=cl><span class=p>{{</span><span class=err>#</span><span class=n>include</span> <span class=n>chapter_9</span><span class=o>/</span><span class=n>reuseadr_eserver</span><span class=p>.</span><span class=n>c</span><span class=p>}}</span>
</span></span></code></pre></div><p>sock_type</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=ln>1</span><span class=cl><span class=p>{{</span><span class=err>#</span><span class=n>include</span> <span class=n>chapter_9</span><span class=o>/</span><span class=n>sock_type</span><span class=p>.</span><span class=n>c</span><span class=p>}}</span>
</span></span></code></pre></div></main><br><footer><div class=footer-info><p>Copyright &copy; 2025 Rainboy. All rights reserved.
<span>| Last build: 2025-09-17 17:03:39</span></p></div><script defer>document.addEventListener("keydown",function(e){if(document.activeElement.isContentEditable)return!1;if(document.activeElement.tagName=="INPUT")return!1;if(e.altKey||e.ctrlKey||e.shiftKey)return!1;var t=e.key;if(t==="h")e.preventDefault(),e.stopPropagation(),window.location.href="/";else if(t==="t")e.preventDefault(),e.stopPropagation(),window.location.href=`https://${location.hostname}/tags`;else if(t==="i"){e.preventDefault(),e.stopPropagation();const t=document.querySelectorAll("input");for(let e=0;e<t.length;e++)if(t[e].offsetParent!==null){t[e].selectionStart=t[e].selectionEnd=t[e].value.length,t[e].focus();break}}return!1})</script><script defer>function throttle(e,t){var n=Date.now();return function(){var s=Date.now();n+t-s<0&&(e(),n=s)}}function scrollHandler(){const e=Array.from(document.querySelectorAll("body h2, body h3"));function t(){for(var n,s,o,i=window.pageYOffset||document.documentElement.scrollTop,t=0;t<e.length;t++)s=e[t].getAttribute("id"),n=document.querySelector('nav ul li a[href="#'+s+'"]'),n&&n.classList.remove("active-toc");for(t=e.length-1;t>=0;t--)if(o=e[t].offsetTop,i>o-75&&(s=e[t].getAttribute("id"),n=document.querySelector('nav ul li a[href="#'+s+'"]'),n)){n.classList.add("active-toc");break}}window.addEventListener("scroll",throttle(t,200))}setTimeout(scrollHandler,100)</script><script defer>function addCopyButtonToCodeBlocks(){const e=document.querySelectorAll('code[class^="language-"]:not(.output):not([class*="language-console"])');e.forEach(e=>{const t=document.createElement("button");t.classList.add("copy-code-button"),t.innerHTML="copy",t.addEventListener("click",()=>{const s=e.querySelectorAll(".cl");let n="";s.forEach(e=>{n+=e.innerText}),navigator.clipboard.writeText(n),t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},1500)}),e.parentNode.before(t)})}setTimeout(function(){addCopyButtonToCodeBlocks()},100)</script><script defer src=/js/theme-switcher.js></script></footer></body></html>