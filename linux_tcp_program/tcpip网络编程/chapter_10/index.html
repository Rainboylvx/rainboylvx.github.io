<!doctype html><html lang=zh-cn><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta http-equiv=cache-control content="max-age=0"><meta http-equiv=cache-control content="no-cache"><meta http-equiv=expires content="0"><meta http-equiv=expires content="Tue, 01 Jan 1980 1:00:00 GMT"><meta http-equiv=pragma content="no-cache"><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png }><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=manifest href=/site.webmanifest><meta name=theme-color media="(prefers-color-scheme: light)" content="#ffffff"><meta name=theme-color media="(prefers-color-scheme: dark)" content="#1b1b1b"><meta name=description content><script>(function(){const e=localStorage.getItem("theme")||(window.matchMedia("(prefers-color-scheme: dark)").matches?"dark":"light");document.documentElement.setAttribute("data-theme",e)})()</script><title>| Rainboy's Blog</title><style>:root{--background:#ffffff}@media(prefers-color-scheme:dark){:root{--background:#1b1b1b}}html{background-color:var(--background)}body{background-color:var(--background)}</style><link rel=stylesheet type=text/css href=/style.min.3e04aededf473d89499a30c20d8e5e836f06b0e43d61d382f9658ca7cdd1ab20.css media=all><link rel=stylesheet href=/grid.css><link href="https://fonts.font.im/css?family=Roboto+Mono" rel=stylesheet><style>body,.heti,.heti--sans{font-family:roboto mono,monospace,times new roman,times,heti song,serif,apple color emoji,segoe ui emoji,segoe ui symbol}</style></head><body><nav><ul class=menu><li><a tabindex=-1 class=menu-link href=/><u>H</u>ome</a></li><li><a tabindex=-1 class=menu-link href=/tags><u>T</u>ags</a></li><li><span style=cursor:pointer id=theme-switcher class=menu-link type=button><svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-moon h-4 w-4"><path d="M12 3a6 6 0 009 9 9 9 0 11-9-9z"/></svg></span></li></ul></nav><div id=single-header><h1></h1><div id=single-meta></div></div><main class="heti heti--classic"><p>为了加大服务器同时处理用户的连接,有效的利用CPU</p><ol><li>多进程服务器: 创建多个进程提供服务</li><li>多路复用: 捆绑并统一管理IO对象提供服务</li><li>多线程: 生成与客户短等量化的线程提供服务</li></ol><h2 id=101-进程概念及引用>10.1 进程概念及引用</h2><h3 id=理解进程>理解进程</h3><p>进程的定义如下：<strong>占用内存空间的正在运行的程序</strong></p><h3 id=进程id>进程ID</h3><p>在说进程创建方法之前，先要简要说明进程 ID。无论进程是如何创建的，所有的进程都会被操作系统分配一个 ID。此 ID 被称为「进程ID」，其值为大于 2 的整数。1 要分配给操作系统启动后的（用于协助操作系统）首个进程，因此用户无法得到 ID 值为 1 。接下来观察在 Linux 中运行的进程。</p><h3 id=fork创建进程>fork创建进程</h3><p>创建进程的方式很多，此处只介绍用于创建多进程服务端的 fork 函数。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=ln>1</span><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;unistd.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=ln>2</span><span class=cl><span class=cp></span><span class=kt>pid_t</span> <span class=nf>fork</span><span class=p>(</span><span class=kt>void</span><span class=p>);</span>
</span></span><span class=line><span class=ln>3</span><span class=cl><span class=c1>// 成功时返回进程ID,失败时返回 -1
</span></span></span></code></pre></div><p>fork 函数将创建调用的进程副本。也就是说，并非根据完全不同的程序创建进程，而是复制正在运行的、调用 fork 函数的进程。另外，两个进程都执行 fork 函数调用后的语句（准确的说是在 fork 函数返回后）。但因为是通过同一个进程、复制相同的内存空间，之后的程序流要根据 fork 函数的返回值加以区分。即利用 fork 函数的如下特点区分程序执行流程。</p><ul><li>父进程：fork 函数返回子进程 ID</li><li>子进程：fork 函数返回 0</li></ul><p>此处，「父进程」（Parent Process）指原进程，即调用 fork 函数的主体，而「子进程」（Child Process）是通过父进程调用 fork 函数复制出的进程。接下来是调用 fork 函数后的程序运行流程。如图所示：</p><p><a href=https://camo.githubusercontent.com/7c517aeff982752b7b862d181d7d4061edcb420dd3e668e3ab0a9c0704daa2a2/68747470733a2f2f692e6c6f6c692e6e65742f323031392f30312f32302f356334336461353431326239302e706e67 target=_blank rel="noreferrer nofollow"><p class=imgp><img loading=lazy src=https://camo.githubusercontent.com/7c517aeff982752b7b862d181d7d4061edcb420dd3e668e3ab0a9c0704daa2a2/68747470733a2f2f692e6c6f6c692e6e65742f323031392f30312f32302f356334336461353431326239302e706e67 alt></p></a></p><p>从图中可以看出，父进程调用 fork 函数的同时复制出子进程，并分别得到 fork 函数的返回值。但复制前，父进程将全局变量 gval 增加到 11,将局部变量 lval 的值增加到 25，因此在这种状态下完成进程复制。复制完成后根据 fork 函数的返回类型区分父子进程。父进程的 lval 的值增加 1 ，但这不会影响子进程的 lval 值。同样子进程将 gval 的值增加 1 也不会影响到父进程的 gval 。因为 fork 函数调用后分成了完全不同的进程，只是二者共享同一段代码而已。接下来给出一个例子：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=ln> 1</span><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;stdio.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=ln> 2</span><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;unistd.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=ln> 3</span><span class=cl><span class=cp></span><span class=kt>int</span> <span class=n>gval</span> <span class=o>=</span> <span class=mi>10</span><span class=p>;</span>
</span></span><span class=line><span class=ln> 4</span><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>(</span><span class=kt>int</span> <span class=n>argc</span><span class=p>,</span> <span class=kt>char</span> <span class=o>*</span><span class=n>argv</span><span class=p>[])</span>
</span></span><span class=line><span class=ln> 5</span><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=ln> 6</span><span class=cl>    <span class=kt>pid_t</span> <span class=n>pid</span><span class=p>;</span>
</span></span><span class=line><span class=ln> 7</span><span class=cl>    <span class=kt>int</span> <span class=n>lval</span> <span class=o>=</span> <span class=mi>20</span><span class=p>;</span>
</span></span><span class=line><span class=ln> 8</span><span class=cl>    <span class=n>gval</span><span class=o>++</span><span class=p>,</span> <span class=n>lval</span> <span class=o>+=</span> <span class=mi>5</span><span class=p>;</span>
</span></span><span class=line><span class=ln> 9</span><span class=cl>    <span class=n>pid</span> <span class=o>=</span> <span class=nf>fork</span><span class=p>();</span>
</span></span><span class=line><span class=ln>10</span><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>pid</span> <span class=o>==</span> <span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=ln>11</span><span class=cl>        <span class=n>gval</span> <span class=o>+=</span> <span class=mi>2</span><span class=p>,</span> <span class=n>lval</span> <span class=o>+=</span> <span class=mi>2</span><span class=p>;</span>
</span></span><span class=line><span class=ln>12</span><span class=cl>    <span class=k>else</span>
</span></span><span class=line><span class=ln>13</span><span class=cl>        <span class=n>gval</span> <span class=o>-=</span> <span class=mi>2</span><span class=p>,</span> <span class=n>lval</span> <span class=o>-=</span> <span class=mi>2</span><span class=p>;</span>
</span></span><span class=line><span class=ln>14</span><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>pid</span> <span class=o>==</span> <span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=ln>15</span><span class=cl>        <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;Child Proc: [%d,%d] </span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>gval</span><span class=p>,</span> <span class=n>lval</span><span class=p>);</span>
</span></span><span class=line><span class=ln>16</span><span class=cl>    <span class=k>else</span>
</span></span><span class=line><span class=ln>17</span><span class=cl>        <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;Parent Proc: [%d,%d] </span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>gval</span><span class=p>,</span> <span class=n>lval</span><span class=p>);</span>
</span></span><span class=line><span class=ln>18</span><span class=cl>    <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=ln>19</span><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h2 id=102-进程与僵尸进程>10.2 进程与僵尸进程</h2><p>文件操作中，关闭文件和打开文件同等重要。同样，进程销毁和进程创建也同等重要。如果未认真对待进程销毁，他们将变成僵尸进程。</p><p>进程的工作完成后（执行完 main 函数中的程序后）应被销毁，但有时这些进程将变成僵尸进程，占用系统中的重要资源。这种状态下的进程称作「僵尸进程」，这也是给系统带来负担的原因之一。</p><blockquote><p>僵尸进程是当子进程比父进程先结束，而父进程又没有回收子进程，释放子进程占用的资源，此时子进程将成为一个僵尸进程。如果父进程先退出 ，子进程被init接管，子进程退出后init会回收其占用的相关资源</p></blockquote><blockquote><p>UNIX命令ps列出的进程的状态（&ldquo;STAT&rdquo;）栏标示为 &ldquo;Z"则为僵尸进程。[1]</p></blockquote><blockquote><p>收割僵尸进程的方法是通过kill命令手工向其父进程发送SIGCHLD信号。如果其父进程仍然拒绝收割僵尸进程，则终止父进程，使得init进程收养僵尸进程。init进程周期执行wait系统调用收割其收养的所有僵尸进程。</p></blockquote><h3 id=产生僵尸进程的原因>产生僵尸进程的原因</h3><p>产生僵尸进程的原因是: <strong>当子进程结束时,操作系统不会主动将子进程的退出状态传递给父进程</strong> 。只有父进程<strong>主动</strong>请求获取子进程的退出状态, 操作系统才会将其传递。如果父进程没有主动要求获取子进程的退出状态,操作系统将一直保存子进程的退出状态,导致子进程长时间处于僵尸进程状态。因此,<strong>为了及时回收子进程,父进程应该主动获取子进程的退出状态。</strong></p><p>zombie.c</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=ln>1</span><span class=cl><span class=p>{{</span><span class=err>#</span><span class=n>include</span> <span class=n>chapter_10</span><span class=o>/</span><span class=n>zombie</span><span class=p>.</span><span class=n>c</span> <span class=p>}}</span>
</span></span></code></pre></div><p><p class=imgp><img loading=lazy src=./chapter_10/image.png alt></p></p><h3 id=销毁僵尸-wait函数>销毁僵尸 wait函数</h3><p>父进程应该主动请求获取子进程的返回值以销毁子进程。使用 wait 函数来获取子进程的终止状态，通过宏 WIFEXITED 和 WEXITSTATUS 来分离和处理子进程的返回值。</p><p>{{#include chapter_10/wait.c }}</p><h3 id=销毁僵尸-waitpid函数>销毁僵尸 waitpid函数</h3><p>wait 函数会引起程序阻塞，还可以考虑调用 waitpid 函数。这是防止僵尸进程的第二种方法，也是防止阻塞的方法。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=ln>1</span><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;sys/wait.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=ln>2</span><span class=cl><span class=cp></span><span class=kt>pid_t</span> <span class=nf>waitpid</span><span class=p>(</span><span class=kt>pid_t</span> <span class=n>pid</span><span class=p>,</span> <span class=kt>int</span> <span class=o>*</span><span class=n>statloc</span><span class=p>,</span> <span class=kt>int</span> <span class=n>options</span><span class=p>);</span>
</span></span><span class=line><span class=ln>3</span><span class=cl><span class=cm>/*
</span></span></span><span class=line><span class=ln>4</span><span class=cl><span class=cm>成功时返回终止的子进程ID 或 0 ，失败时返回 -1
</span></span></span><span class=line><span class=ln>5</span><span class=cl><span class=cm>pid: 等待终止的目标子进程的ID,若传 -1，则与 wait 函数相同，可以等待任意子进程终止
</span></span></span><span class=line><span class=ln>6</span><span class=cl><span class=cm>statloc: 与 wait 函数的 statloc 参数具有相同含义
</span></span></span><span class=line><span class=ln>7</span><span class=cl><span class=cm>options: 传递头文件 sys/wait.h 声明的常量 WNOHANG ,即使没有终止的子进程也不会进入阻塞状态，而是返回 0 退出函数。
</span></span></span><span class=line><span class=ln>8</span><span class=cl><span class=cm>*/</span>
</span></span></code></pre></div><p>waitpid.c</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=ln> 1</span><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;stdio.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=ln> 2</span><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;unistd.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=ln> 3</span><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;sys/wait.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=ln> 4</span><span class=cl><span class=cp></span><span class=kt>int</span> <span class=nf>main</span><span class=p>(</span><span class=kt>int</span> <span class=n>argc</span><span class=p>,</span> <span class=kt>char</span> <span class=o>*</span><span class=n>argv</span><span class=p>[])</span>
</span></span><span class=line><span class=ln> 5</span><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=ln> 6</span><span class=cl>    <span class=kt>int</span> <span class=n>status</span><span class=p>;</span>
</span></span><span class=line><span class=ln> 7</span><span class=cl>    <span class=kt>pid_t</span> <span class=n>pid</span> <span class=o>=</span> <span class=nf>fork</span><span class=p>();</span>
</span></span><span class=line><span class=ln> 8</span><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>pid</span> <span class=o>==</span> <span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=ln> 9</span><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=ln>10</span><span class=cl>        <span class=nf>sleep</span><span class=p>(</span><span class=mi>15</span><span class=p>);</span> <span class=c1>//用 sleep 推迟子进程的执行
</span></span></span><span class=line><span class=ln>11</span><span class=cl><span class=c1></span>        <span class=k>return</span> <span class=mi>24</span><span class=p>;</span>
</span></span><span class=line><span class=ln>12</span><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=ln>13</span><span class=cl>    <span class=k>else</span>
</span></span><span class=line><span class=ln>14</span><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=ln>15</span><span class=cl>        <span class=c1>//调用waitpid 传递参数 WNOHANG ，这样之前有没有终止的子进程则返回0
</span></span></span><span class=line><span class=ln>16</span><span class=cl><span class=c1></span>        <span class=k>while</span> <span class=p>(</span><span class=o>!</span><span class=nf>waitpid</span><span class=p>(</span><span class=o>-</span><span class=mi>1</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>status</span><span class=p>,</span> <span class=n>WNOHANG</span><span class=p>))</span>
</span></span><span class=line><span class=ln>17</span><span class=cl>        <span class=p>{</span>
</span></span><span class=line><span class=ln>18</span><span class=cl>            <span class=nf>sleep</span><span class=p>(</span><span class=mi>3</span><span class=p>);</span>
</span></span><span class=line><span class=ln>19</span><span class=cl>            <span class=nf>puts</span><span class=p>(</span><span class=s>&#34;sleep 3 sec.&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=ln>20</span><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=ln>21</span><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=nf>WIFEXITED</span><span class=p>(</span><span class=n>status</span><span class=p>))</span>
</span></span><span class=line><span class=ln>22</span><span class=cl>            <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;Child send %d </span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=nf>WEXITSTATUS</span><span class=p>(</span><span class=n>status</span><span class=p>));</span>
</span></span><span class=line><span class=ln>23</span><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=ln>24</span><span class=cl>    <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span></code></pre></div><h2 id=103-信号处理>10.3 信号处理</h2><blockquote><p>子进程究竟何时终止？调用 waitpid 函数后要无休止的等待吗？</p></blockquote><p>信号是一种软中断，它是由操作系统向进程发送的通知消息。信号的作用是通知进程发生了某种事件，如进程终止、进程收到某种输入、进程执行时间到达某一点等。信号的处理方式是通过信号处理函数来实现的。</p><p>子进程终止的识别主体是操作系统，因此，若操作系统能把子进程结束的信息告诉正忙于工作的父进程，将有助于构建更高效的程序</p><h3 id=信号与signal函数>信号与signal函数</h3><p>我们可以注册信号处理函数，当信号发生时，操作系统将调用相应的信号处理函数。信号处理函数的原型如下：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=ln>1</span><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;signal.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=ln>2</span><span class=cl><span class=cp></span><span class=kt>void</span> <span class=p>(</span><span class=o>*</span><span class=nf>signal</span><span class=p>(</span><span class=kt>int</span> <span class=n>signo</span><span class=p>,</span> <span class=kt>void</span> <span class=p>(</span><span class=o>*</span><span class=n>func</span><span class=p>)(</span><span class=kt>int</span><span class=p>)))(</span><span class=kt>int</span><span class=p>);</span>
</span></span><span class=line><span class=ln>3</span><span class=cl><span class=cm>/*
</span></span></span><span class=line><span class=ln>4</span><span class=cl><span class=cm>为了在产生信号时调用，返回之前注册的函数指针
</span></span></span><span class=line><span class=ln>5</span><span class=cl><span class=cm>函数名: signal
</span></span></span><span class=line><span class=ln>6</span><span class=cl><span class=cm>参数：int signo,void(*func)(int)
</span></span></span><span class=line><span class=ln>7</span><span class=cl><span class=cm>返回类型：参数类型为int型，返回 void 型函数指针
</span></span></span><span class=line><span class=ln>8</span><span class=cl><span class=cm>*/</span>
</span></span></code></pre></div><p>这个函数比较难,我这样理解</p><p>有函数为</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=ln>1</span><span class=cl><span class=kt>void</span> <span class=nf>func_a</span><span class=p>(</span><span class=kt>int</span><span class=p>)</span>
</span></span></code></pre></div><p>这个函数的是一个返回值为void,参数为int的函数.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=ln>1</span><span class=cl><span class=kt>void</span> <span class=p>(</span><span class=o>*</span><span class=n>func_b</span><span class=p>)(</span><span class=kt>int</span><span class=p>)</span>
</span></span><span class=line><span class=ln>2</span><span class=cl>
</span></span><span class=line><span class=ln>3</span><span class=cl><span class=c1>//相当于
</span></span></span><span class=line><span class=ln>4</span><span class=cl><span class=c1></span>
</span></span><span class=line><span class=ln>5</span><span class=cl><span class=c1>//定义一个类型,函数指针
</span></span></span><span class=line><span class=ln>6</span><span class=cl><span class=c1></span><span class=k>typedef</span> <span class=kt>void</span> <span class=p>(</span><span class=o>*</span><span class=p>)(</span><span class=kt>int</span><span class=p>)</span> <span class=n>func_a_pointer</span><span class=p>;</span>
</span></span><span class=line><span class=ln>7</span><span class=cl><span class=c1>// 定义一个指向函数的变量
</span></span></span><span class=line><span class=ln>8</span><span class=cl><span class=c1></span><span class=n>func_a_pointer</span> <span class=n>func_a_p</span> <span class=o>=</span> <span class=n>func_a</span><span class=p>;</span>
</span></span></code></pre></div><p>怎么理解函数指针<p class=imgp><img loading=lazy src=./chapter_10/image2.png alt></p></p><p>再难一点,定义函数的返回值 为函数指针</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=ln>1</span><span class=cl><span class=kt>void</span> <span class=p>(</span><span class=o>*</span><span class=nf>func_c</span><span class=p>(</span><span class=kt>int</span><span class=p>))(</span><span class=kt>int</span><span class=p>)</span>
</span></span><span class=line><span class=ln>2</span><span class=cl>
</span></span><span class=line><span class=ln>3</span><span class=cl><span class=k>typedef</span> <span class=kt>void</span> <span class=p>(</span><span class=o>*</span><span class=p>)(</span><span class=kt>int</span><span class=p>)</span> <span class=n>func_a_pointer</span><span class=p>;</span>
</span></span><span class=line><span class=ln>4</span><span class=cl><span class=c1>// 定义一个指向函数的变量
</span></span></span><span class=line><span class=ln>5</span><span class=cl><span class=c1></span><span class=n>func_a_pointer</span> <span class=nf>function_c</span><span class=p>(</span><span class=kt>int</span><span class=p>);</span>
</span></span></code></pre></div><p>再难一点,函数的返回值为函数指针,且函数的参数还有一个函数指针</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=ln>1</span><span class=cl><span class=kt>void</span> <span class=p>(</span><span class=o>*</span><span class=nf>signal</span><span class=p>(</span><span class=kt>int</span> <span class=n>signo</span><span class=p>,</span> <span class=kt>void</span> <span class=p>(</span><span class=o>*</span><span class=n>func</span><span class=p>)(</span><span class=kt>int</span><span class=p>)))(</span><span class=kt>int</span><span class=p>);</span>
</span></span></code></pre></div><p>调用上述函数时，第一个参数为特殊情况信息，第二个参数为特殊情况下将要调用的函数的地址值（指针）。发生第一个参数代表的情况时，调用第二个参数所指的函数。下面给出可以在 signal 函数中注册的部分特殊情况和对应的函数。</p><ul><li>SIGALRM：已到通过调用 alarm 函数时候产生</li><li>SIGINT：输入 ctrl+c</li><li>SIGCHLD：子进程终止</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=ln> 1</span><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;stdio.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=ln> 2</span><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;unistd.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=ln> 3</span><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;signal.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=ln> 4</span><span class=cl><span class=cp></span><span class=kt>void</span> <span class=nf>timeout</span><span class=p>(</span><span class=kt>int</span> <span class=n>sig</span><span class=p>)</span> <span class=c1>//信号处理器
</span></span></span><span class=line><span class=ln> 5</span><span class=cl><span class=c1></span><span class=p>{</span>
</span></span><span class=line><span class=ln> 6</span><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>sig</span> <span class=o>==</span> <span class=n>SIGALRM</span><span class=p>)</span>
</span></span><span class=line><span class=ln> 7</span><span class=cl>        <span class=nf>puts</span><span class=p>(</span><span class=s>&#34;Time out!&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=ln> 8</span><span class=cl>    <span class=nf>alarm</span><span class=p>(</span><span class=mi>2</span><span class=p>);</span> <span class=c1>//为了每隔 2 秒重复产生 SIGALRM 信号，在信号处理器中调用 alarm 函数
</span></span></span><span class=line><span class=ln> 9</span><span class=cl><span class=c1></span><span class=p>}</span>
</span></span><span class=line><span class=ln>10</span><span class=cl><span class=kt>void</span> <span class=nf>keycontrol</span><span class=p>(</span><span class=kt>int</span> <span class=n>sig</span><span class=p>)</span> <span class=c1>//信号处理器
</span></span></span><span class=line><span class=ln>11</span><span class=cl><span class=c1></span><span class=p>{</span>
</span></span><span class=line><span class=ln>12</span><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>sig</span> <span class=o>==</span> <span class=n>SIGINT</span><span class=p>)</span>
</span></span><span class=line><span class=ln>13</span><span class=cl>        <span class=nf>puts</span><span class=p>(</span><span class=s>&#34;CTRL+C pressed&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=ln>14</span><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=ln>15</span><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>(</span><span class=kt>int</span> <span class=n>argc</span><span class=p>,</span> <span class=kt>char</span> <span class=o>*</span><span class=n>argv</span><span class=p>[])</span>
</span></span><span class=line><span class=ln>16</span><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=ln>17</span><span class=cl>    <span class=kt>int</span> <span class=n>i</span><span class=p>;</span>
</span></span><span class=line><span class=ln>18</span><span class=cl>    <span class=nf>signal</span><span class=p>(</span><span class=n>SIGALRM</span><span class=p>,</span> <span class=n>timeout</span><span class=p>);</span> <span class=c1>//注册信号及相应处理器
</span></span></span><span class=line><span class=ln>19</span><span class=cl><span class=c1></span>    <span class=nf>signal</span><span class=p>(</span><span class=n>SIGINT</span><span class=p>,</span> <span class=n>keycontrol</span><span class=p>);</span>
</span></span><span class=line><span class=ln>20</span><span class=cl>    <span class=nf>alarm</span><span class=p>(</span><span class=mi>2</span><span class=p>);</span> <span class=c1>//预约 2 秒候发生 SIGALRM 信号
</span></span></span><span class=line><span class=ln>21</span><span class=cl><span class=c1></span>
</span></span><span class=line><span class=ln>22</span><span class=cl>    <span class=k>for</span> <span class=p>(</span><span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=mi>3</span><span class=p>;</span> <span class=n>i</span><span class=o>++</span><span class=p>)</span>
</span></span><span class=line><span class=ln>23</span><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=ln>24</span><span class=cl>        <span class=nf>puts</span><span class=p>(</span><span class=s>&#34;wait...&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=ln>25</span><span class=cl>        <span class=nf>sleep</span><span class=p>(</span><span class=mi>100</span><span class=p>);</span>
</span></span><span class=line><span class=ln>26</span><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=ln>27</span><span class=cl>    <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=ln>28</span><span class=cl><span class=p>}</span>
</span></span></code></pre></div><blockquote><p>发生信号时将唤醒由于调用 sleep 函数而进入阻塞状态的进程。</p></blockquote><h3 id=利用-sigaction-函数进行信号处理>利用 sigaction 函数进行信号处理</h3><p>还有一个函数，叫做 sigaction 函数，他类似于 signal 函数，而且可以完全代替后者，也更稳定。之所以稳定，是因为：</p><blockquote><p>signal 函数在 Unix 系列的不同操作系统可能存在区别，但 sigaction 函数完全相同</p></blockquote><p>实际上现在很少用 signal 函数编写程序，他只是为了保持对旧程序的兼容，下面介绍 sigaction 函数，只讲解可以替换 signal 函数的功能。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=ln>1</span><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;signal.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=ln>2</span><span class=cl><span class=cp></span>
</span></span><span class=line><span class=ln>3</span><span class=cl><span class=kt>int</span> <span class=nf>sigaction</span><span class=p>(</span><span class=kt>int</span> <span class=n>signo</span><span class=p>,</span> <span class=k>const</span> <span class=k>struct</span> <span class=n>sigaction</span> <span class=o>*</span><span class=n>act</span><span class=p>,</span> <span class=k>struct</span> <span class=n>sigaction</span> <span class=o>*</span><span class=n>oldact</span><span class=p>);</span>
</span></span><span class=line><span class=ln>4</span><span class=cl><span class=cm>/*
</span></span></span><span class=line><span class=ln>5</span><span class=cl><span class=cm>成功时返回 0 ，失败时返回 -1
</span></span></span><span class=line><span class=ln>6</span><span class=cl><span class=cm>act: 对于第一个参数的信号处理函数（信号处理器）信息。
</span></span></span><span class=line><span class=ln>7</span><span class=cl><span class=cm>oldact: 通过此参数获取之前注册的信号处理函数指针，若不需要则传递 0
</span></span></span><span class=line><span class=ln>8</span><span class=cl><span class=cm>*/</span>
</span></span></code></pre></div><p>声明并初始化 sigaction 结构体变量以调用上述函数，该结构体定义如下：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=ln>1</span><span class=cl><span class=k>struct</span> <span class=n>sigaction</span>
</span></span><span class=line><span class=ln>2</span><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=ln>3</span><span class=cl>    <span class=kt>void</span> <span class=p>(</span><span class=o>*</span><span class=n>sa_handler</span><span class=p>)(</span><span class=kt>int</span><span class=p>);</span>
</span></span><span class=line><span class=ln>4</span><span class=cl>    <span class=kt>sigset_t</span> <span class=n>sa_mask</span><span class=p>;</span>
</span></span><span class=line><span class=ln>5</span><span class=cl>    <span class=kt>int</span> <span class=n>sa_flags</span><span class=p>;</span>
</span></span><span class=line><span class=ln>6</span><span class=cl><span class=p>};</span>
</span></span></code></pre></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=ln> 1</span><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;stdio.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=ln> 2</span><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;unistd.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=ln> 3</span><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;signal.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=ln> 4</span><span class=cl><span class=cp></span>
</span></span><span class=line><span class=ln> 5</span><span class=cl><span class=kt>void</span> <span class=nf>timeout</span><span class=p>(</span><span class=kt>int</span> <span class=n>sig</span><span class=p>)</span>
</span></span><span class=line><span class=ln> 6</span><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=ln> 7</span><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>sig</span> <span class=o>==</span> <span class=n>SIGALRM</span><span class=p>)</span>
</span></span><span class=line><span class=ln> 8</span><span class=cl>        <span class=nf>puts</span><span class=p>(</span><span class=s>&#34;Time out!&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=ln> 9</span><span class=cl>    <span class=nf>alarm</span><span class=p>(</span><span class=mi>2</span><span class=p>);</span>
</span></span><span class=line><span class=ln>10</span><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=ln>11</span><span class=cl>
</span></span><span class=line><span class=ln>12</span><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>(</span><span class=kt>int</span> <span class=n>argc</span><span class=p>,</span> <span class=kt>char</span> <span class=o>*</span><span class=n>argv</span><span class=p>[])</span>
</span></span><span class=line><span class=ln>13</span><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=ln>14</span><span class=cl>    <span class=kt>int</span> <span class=n>i</span><span class=p>;</span>
</span></span><span class=line><span class=ln>15</span><span class=cl>    <span class=k>struct</span> <span class=n>sigaction</span> <span class=n>act</span><span class=p>;</span>
</span></span><span class=line><span class=ln>16</span><span class=cl>    <span class=n>act</span><span class=p>.</span><span class=n>sa_handler</span> <span class=o>=</span> <span class=n>timeout</span><span class=p>;</span>    <span class=c1>//保存函数指针
</span></span></span><span class=line><span class=ln>17</span><span class=cl><span class=c1></span>    <span class=nf>sigemptyset</span><span class=p>(</span><span class=o>&amp;</span><span class=n>act</span><span class=p>.</span><span class=n>sa_mask</span><span class=p>);</span>   <span class=c1>//将 sa_mask 成员的所有位初始化成0
</span></span></span><span class=line><span class=ln>18</span><span class=cl><span class=c1></span>    <span class=n>act</span><span class=p>.</span><span class=n>sa_flags</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>            <span class=c1>//sa_flags 同样初始化成 0
</span></span></span><span class=line><span class=ln>19</span><span class=cl><span class=c1></span>    <span class=nf>sigaction</span><span class=p>(</span><span class=n>SIGALRM</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>act</span><span class=p>,</span> <span class=mi>0</span><span class=p>);</span> <span class=c1>//注册 SIGALRM 信号的处理器。
</span></span></span><span class=line><span class=ln>20</span><span class=cl><span class=c1></span>
</span></span><span class=line><span class=ln>21</span><span class=cl>    <span class=nf>alarm</span><span class=p>(</span><span class=mi>2</span><span class=p>);</span> <span class=c1>//2 秒后发生 SIGALRM 信号
</span></span></span><span class=line><span class=ln>22</span><span class=cl><span class=c1></span>
</span></span><span class=line><span class=ln>23</span><span class=cl>    <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=mi>3</span><span class=p>;</span> <span class=n>i</span><span class=o>++</span><span class=p>)</span>
</span></span><span class=line><span class=ln>24</span><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=ln>25</span><span class=cl>        <span class=nf>puts</span><span class=p>(</span><span class=s>&#34;wait...&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=ln>26</span><span class=cl>        <span class=nf>sleep</span><span class=p>(</span><span class=mi>100</span><span class=p>);</span>
</span></span><span class=line><span class=ln>27</span><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=ln>28</span><span class=cl>    <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=ln>29</span><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h3 id=1034-利用信号处理技术消灭僵尸进程>10.3.4 利用信号处理技术消灭僵尸进程</h3><p>下面利用子进程终止时产生 SIGCHLD 信号这一点，来用信号处理来消灭僵尸进程。看以下代码：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=ln> 1</span><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;stdio.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=ln> 2</span><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;stdlib.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=ln> 3</span><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;unistd.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=ln> 4</span><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;signal.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=ln> 5</span><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;sys/wait.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=ln> 6</span><span class=cl><span class=cp></span>
</span></span><span class=line><span class=ln> 7</span><span class=cl><span class=kt>void</span> <span class=nf>read_childproc</span><span class=p>(</span><span class=kt>int</span> <span class=n>sig</span><span class=p>)</span>
</span></span><span class=line><span class=ln> 8</span><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=ln> 9</span><span class=cl>    <span class=kt>int</span> <span class=n>status</span><span class=p>;</span>
</span></span><span class=line><span class=ln>10</span><span class=cl>    <span class=kt>pid_t</span> <span class=n>id</span> <span class=o>=</span> <span class=nf>waitpid</span><span class=p>(</span><span class=o>-</span><span class=mi>1</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>status</span><span class=p>,</span> <span class=n>WNOHANG</span><span class=p>);</span>
</span></span><span class=line><span class=ln>11</span><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=nf>WIFEXITED</span><span class=p>(</span><span class=n>status</span><span class=p>))</span>
</span></span><span class=line><span class=ln>12</span><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=ln>13</span><span class=cl>        <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;Removed proc id: %d </span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>id</span><span class=p>);</span>             <span class=c1>//子进程的 pid
</span></span></span><span class=line><span class=ln>14</span><span class=cl><span class=c1></span>        <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;Child send: %d </span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=nf>WEXITSTATUS</span><span class=p>(</span><span class=n>status</span><span class=p>));</span> <span class=c1>//子进程的返回值
</span></span></span><span class=line><span class=ln>15</span><span class=cl><span class=c1></span>    <span class=p>}</span>
</span></span><span class=line><span class=ln>16</span><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=ln>17</span><span class=cl>
</span></span><span class=line><span class=ln>18</span><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>(</span><span class=kt>int</span> <span class=n>argc</span><span class=p>,</span> <span class=kt>char</span> <span class=o>*</span><span class=n>argv</span><span class=p>[])</span>
</span></span><span class=line><span class=ln>19</span><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=ln>20</span><span class=cl>    <span class=kt>pid_t</span> <span class=n>pid</span><span class=p>;</span>
</span></span><span class=line><span class=ln>21</span><span class=cl>    <span class=k>struct</span> <span class=n>sigaction</span> <span class=n>act</span><span class=p>;</span>
</span></span><span class=line><span class=ln>22</span><span class=cl>    <span class=n>act</span><span class=p>.</span><span class=n>sa_handler</span> <span class=o>=</span> <span class=n>read_childproc</span><span class=p>;</span>
</span></span><span class=line><span class=ln>23</span><span class=cl>    <span class=nf>sigemptyset</span><span class=p>(</span><span class=o>&amp;</span><span class=n>act</span><span class=p>.</span><span class=n>sa_mask</span><span class=p>);</span>
</span></span><span class=line><span class=ln>24</span><span class=cl>    <span class=n>act</span><span class=p>.</span><span class=n>sa_flags</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=ln>25</span><span class=cl>    <span class=nf>sigaction</span><span class=p>(</span><span class=n>SIGCHLD</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>act</span><span class=p>,</span> <span class=mi>0</span><span class=p>);</span>
</span></span><span class=line><span class=ln>26</span><span class=cl>
</span></span><span class=line><span class=ln>27</span><span class=cl>    <span class=n>pid</span> <span class=o>=</span> <span class=nf>fork</span><span class=p>();</span>
</span></span><span class=line><span class=ln>28</span><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>pid</span> <span class=o>==</span> <span class=mi>0</span><span class=p>)</span> <span class=c1>//子进程执行阶段
</span></span></span><span class=line><span class=ln>29</span><span class=cl><span class=c1></span>    <span class=p>{</span>
</span></span><span class=line><span class=ln>30</span><span class=cl>        <span class=nf>puts</span><span class=p>(</span><span class=s>&#34;Hi I&#39;m child process&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=ln>31</span><span class=cl>        <span class=nf>sleep</span><span class=p>(</span><span class=mi>10</span><span class=p>);</span>
</span></span><span class=line><span class=ln>32</span><span class=cl>        <span class=k>return</span> <span class=mi>12</span><span class=p>;</span>
</span></span><span class=line><span class=ln>33</span><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=ln>34</span><span class=cl>    <span class=k>else</span> <span class=c1>//父进程执行阶段
</span></span></span><span class=line><span class=ln>35</span><span class=cl><span class=c1></span>    <span class=p>{</span>
</span></span><span class=line><span class=ln>36</span><span class=cl>        <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;Child proc id: %d</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>pid</span><span class=p>);</span>
</span></span><span class=line><span class=ln>37</span><span class=cl>        <span class=n>pid</span> <span class=o>=</span> <span class=nf>fork</span><span class=p>();</span>
</span></span><span class=line><span class=ln>38</span><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=n>pid</span> <span class=o>==</span> <span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=ln>39</span><span class=cl>        <span class=p>{</span>
</span></span><span class=line><span class=ln>40</span><span class=cl>            <span class=nf>puts</span><span class=p>(</span><span class=s>&#34;Hi! I&#39;m child process&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=ln>41</span><span class=cl>            <span class=nf>sleep</span><span class=p>(</span><span class=mi>10</span><span class=p>);</span>
</span></span><span class=line><span class=ln>42</span><span class=cl>            <span class=nf>exit</span><span class=p>(</span><span class=mi>24</span><span class=p>);</span>
</span></span><span class=line><span class=ln>43</span><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=ln>44</span><span class=cl>        <span class=k>else</span>
</span></span><span class=line><span class=ln>45</span><span class=cl>        <span class=p>{</span>
</span></span><span class=line><span class=ln>46</span><span class=cl>            <span class=kt>int</span> <span class=n>i</span><span class=p>;</span>
</span></span><span class=line><span class=ln>47</span><span class=cl>            <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;Child proc id: %d </span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>pid</span><span class=p>);</span>
</span></span><span class=line><span class=ln>48</span><span class=cl>            <span class=k>for</span> <span class=p>(</span><span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=mi>5</span><span class=p>;</span> <span class=n>i</span><span class=o>++</span><span class=p>)</span>
</span></span><span class=line><span class=ln>49</span><span class=cl>            <span class=p>{</span>
</span></span><span class=line><span class=ln>50</span><span class=cl>                <span class=nf>puts</span><span class=p>(</span><span class=s>&#34;wait&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=ln>51</span><span class=cl>                <span class=nf>sleep</span><span class=p>(</span><span class=mi>5</span><span class=p>);</span>
</span></span><span class=line><span class=ln>52</span><span class=cl>            <span class=p>}</span>
</span></span><span class=line><span class=ln>53</span><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=ln>54</span><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=ln>55</span><span class=cl>    <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=ln>56</span><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h2 id=104-基于多任务的并发服务器>10.4 基于多任务的并发服务器</h2><p>之前的回声服务器每次只能同事向 1 个客户端提供服务。因此，需要扩展回声服务器，使其可以同时向多个客户端提供服务。下图是基于多进程的回声服务器的模型。</p><p><a href=https://camo.githubusercontent.com/f86fb2dff6d5c43cafa19721581224e98cfaf56f6971a97824e84039ec4ea680/68747470733a2f2f692e6c6f6c692e6e65742f323031392f30312f32312f356334353336363463646532362e706e67 target=_blank rel="noreferrer nofollow"><p class=imgp><img loading=lazy src=https://camo.githubusercontent.com/f86fb2dff6d5c43cafa19721581224e98cfaf56f6971a97824e84039ec4ea680/68747470733a2f2f692e6c6f6c692e6e65742f323031392f30312f32312f356334353336363463646532362e706e67 alt></p></a></p><p>从图中可以看出，每当有客户端请求时（连接请求），回声服务器都创建子进程以提供服务。如果请求的客户端有 5 个，则将创建 5 个子进程来提供服务，为了完成这些任务，需要经过如下过程：</p><ul><li>第一阶段：回声服务器端（父进程）通过调用 accept 函数受理连接请求</li><li>第二阶段：此时获取的套接字文件描述符创建并传递给子进程</li><li>第三阶段：子进程利用传递来的文件描述符提供服务</li></ul><blockquote><p>Q ? 如何传递给子进程文件描述符<br>A 子进程会复制父进程的所有的资源,所以不需要传递</p><p>Q: 子进程会复制父进程的server_sd（套接字文件描述符）吗? 那他会收到cient的数据吗?</p></blockquote><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=ln> 1</span><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;stdio.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=ln> 2</span><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;stdlib.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=ln> 3</span><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;string.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=ln> 4</span><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;unistd.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=ln> 5</span><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;signal.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=ln> 6</span><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;sys/wait.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=ln> 7</span><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;arpa/inet.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=ln> 8</span><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;sys/socket.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=ln> 9</span><span class=cl><span class=cp></span>
</span></span><span class=line><span class=ln>10</span><span class=cl><span class=cp>#define BUF_SIZE 30
</span></span></span><span class=line><span class=ln>11</span><span class=cl><span class=cp></span><span class=kt>void</span> <span class=nf>error_handling</span><span class=p>(</span><span class=kt>char</span> <span class=o>*</span><span class=n>message</span><span class=p>);</span>
</span></span><span class=line><span class=ln>12</span><span class=cl><span class=kt>void</span> <span class=nf>read_childproc</span><span class=p>(</span><span class=kt>int</span> <span class=n>sig</span><span class=p>);</span>
</span></span><span class=line><span class=ln>13</span><span class=cl>
</span></span><span class=line><span class=ln>14</span><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>(</span><span class=kt>int</span> <span class=n>argc</span><span class=p>,</span> <span class=kt>char</span> <span class=o>*</span><span class=n>argv</span><span class=p>[])</span>
</span></span><span class=line><span class=ln>15</span><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=ln>16</span><span class=cl>    <span class=kt>int</span> <span class=n>serv_sock</span><span class=p>,</span> <span class=n>clnt_sock</span><span class=p>;</span>
</span></span><span class=line><span class=ln>17</span><span class=cl>    <span class=k>struct</span> <span class=n>sockaddr_in</span> <span class=n>serv_adr</span><span class=p>,</span> <span class=n>clnt_adr</span><span class=p>;</span>
</span></span><span class=line><span class=ln>18</span><span class=cl>
</span></span><span class=line><span class=ln>19</span><span class=cl>    <span class=kt>pid_t</span> <span class=n>pid</span><span class=p>;</span>
</span></span><span class=line><span class=ln>20</span><span class=cl>    <span class=k>struct</span> <span class=n>sigaction</span> <span class=n>act</span><span class=p>;</span>
</span></span><span class=line><span class=ln>21</span><span class=cl>    <span class=kt>socklen_t</span> <span class=n>adr_sz</span><span class=p>;</span>
</span></span><span class=line><span class=ln>22</span><span class=cl>    <span class=kt>int</span> <span class=n>str_len</span><span class=p>,</span> <span class=n>state</span><span class=p>;</span>
</span></span><span class=line><span class=ln>23</span><span class=cl>    <span class=kt>char</span> <span class=n>buf</span><span class=p>[</span><span class=n>BUF_SIZE</span><span class=p>];</span>
</span></span><span class=line><span class=ln>24</span><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>argc</span> <span class=o>!=</span> <span class=mi>2</span><span class=p>)</span>
</span></span><span class=line><span class=ln>25</span><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=ln>26</span><span class=cl>        <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;Usgae : %s &lt;port&gt;</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>argv</span><span class=p>[</span><span class=mi>0</span><span class=p>]);</span>
</span></span><span class=line><span class=ln>27</span><span class=cl>        <span class=nf>exit</span><span class=p>(</span><span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=ln>28</span><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=ln>29</span><span class=cl>    <span class=n>act</span><span class=p>.</span><span class=n>sa_handler</span> <span class=o>=</span> <span class=n>read_childproc</span><span class=p>;</span> <span class=c1>//防止僵尸进程
</span></span></span><span class=line><span class=ln>30</span><span class=cl><span class=c1></span>    <span class=nf>sigemptyset</span><span class=p>(</span><span class=o>&amp;</span><span class=n>act</span><span class=p>.</span><span class=n>sa_mask</span><span class=p>);</span>
</span></span><span class=line><span class=ln>31</span><span class=cl>    <span class=n>act</span><span class=p>.</span><span class=n>sa_flags</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=ln>32</span><span class=cl>    <span class=n>state</span> <span class=o>=</span> <span class=nf>sigaction</span><span class=p>(</span><span class=n>SIGCHLD</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>act</span><span class=p>,</span> <span class=mi>0</span><span class=p>);</span>         <span class=c1>//注册信号处理器,把成功的返回值给 state
</span></span></span><span class=line><span class=ln>33</span><span class=cl><span class=c1></span>    <span class=n>serv_sock</span> <span class=o>=</span> <span class=nf>socket</span><span class=p>(</span><span class=n>PF_INET</span><span class=p>,</span> <span class=n>SOCK_STREAM</span><span class=p>,</span> <span class=mi>0</span><span class=p>);</span> <span class=c1>//创建服务端套接字
</span></span></span><span class=line><span class=ln>34</span><span class=cl><span class=c1></span>    <span class=nf>memset</span><span class=p>(</span><span class=o>&amp;</span><span class=n>serv_adr</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=k>sizeof</span><span class=p>(</span><span class=n>serv_adr</span><span class=p>));</span>
</span></span><span class=line><span class=ln>35</span><span class=cl>    <span class=n>serv_adr</span><span class=p>.</span><span class=n>sin_family</span> <span class=o>=</span> <span class=n>AF_INET</span><span class=p>;</span>
</span></span><span class=line><span class=ln>36</span><span class=cl>    <span class=n>serv_adr</span><span class=p>.</span><span class=n>sin_addr</span><span class=p>.</span><span class=n>s_addr</span> <span class=o>=</span> <span class=nf>htonl</span><span class=p>(</span><span class=n>INADDR_ANY</span><span class=p>);</span>
</span></span><span class=line><span class=ln>37</span><span class=cl>    <span class=n>serv_adr</span><span class=p>.</span><span class=n>sin_port</span> <span class=o>=</span> <span class=nf>htons</span><span class=p>(</span><span class=nf>atoi</span><span class=p>(</span><span class=n>argv</span><span class=p>[</span><span class=mi>1</span><span class=p>]));</span>
</span></span><span class=line><span class=ln>38</span><span class=cl>
</span></span><span class=line><span class=ln>39</span><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=nf>bind</span><span class=p>(</span><span class=n>serv_sock</span><span class=p>,</span> <span class=p>(</span><span class=k>struct</span> <span class=n>sockaddr</span> <span class=o>*</span><span class=p>)</span><span class=o>&amp;</span><span class=n>serv_adr</span><span class=p>,</span> <span class=k>sizeof</span><span class=p>(</span><span class=n>serv_adr</span><span class=p>))</span> <span class=o>==</span> <span class=o>-</span><span class=mi>1</span><span class=p>)</span> <span class=c1>//分配IP地址和端口号
</span></span></span><span class=line><span class=ln>40</span><span class=cl><span class=c1></span>        <span class=nf>error_handling</span><span class=p>(</span><span class=s>&#34;bind() error&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=ln>41</span><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=nf>listen</span><span class=p>(</span><span class=n>serv_sock</span><span class=p>,</span> <span class=mi>5</span><span class=p>)</span> <span class=o>==</span> <span class=o>-</span><span class=mi>1</span><span class=p>)</span> <span class=c1>//进入等待连接请求状态
</span></span></span><span class=line><span class=ln>42</span><span class=cl><span class=c1></span>        <span class=nf>error_handling</span><span class=p>(</span><span class=s>&#34;listen() error&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=ln>43</span><span class=cl>
</span></span><span class=line><span class=ln>44</span><span class=cl>    <span class=k>while</span> <span class=p>(</span><span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=ln>45</span><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=ln>46</span><span class=cl>        <span class=n>adr_sz</span> <span class=o>=</span> <span class=k>sizeof</span><span class=p>(</span><span class=n>clnt_adr</span><span class=p>);</span>
</span></span><span class=line><span class=ln>47</span><span class=cl>        <span class=n>clnt_sock</span> <span class=o>=</span> <span class=nf>accept</span><span class=p>(</span><span class=n>serv_sock</span><span class=p>,</span> <span class=p>(</span><span class=k>struct</span> <span class=n>sockaddr</span> <span class=o>*</span><span class=p>)</span><span class=o>&amp;</span><span class=n>clnt_adr</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>adr_sz</span><span class=p>);</span>
</span></span><span class=line><span class=ln>48</span><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=n>clnt_sock</span> <span class=o>==</span> <span class=o>-</span><span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=ln>49</span><span class=cl>            <span class=k>continue</span><span class=p>;</span>
</span></span><span class=line><span class=ln>50</span><span class=cl>        <span class=k>else</span>
</span></span><span class=line><span class=ln>51</span><span class=cl>            <span class=nf>puts</span><span class=p>(</span><span class=s>&#34;new client connected...&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=ln>52</span><span class=cl>        <span class=n>pid</span> <span class=o>=</span> <span class=nf>fork</span><span class=p>();</span> <span class=c1>//此时，父子进程分别带有一个套接字
</span></span></span><span class=line><span class=ln>53</span><span class=cl><span class=c1></span>        <span class=k>if</span> <span class=p>(</span><span class=n>pid</span> <span class=o>==</span> <span class=o>-</span><span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=ln>54</span><span class=cl>        <span class=p>{</span>
</span></span><span class=line><span class=ln>55</span><span class=cl>            <span class=nf>close</span><span class=p>(</span><span class=n>clnt_sock</span><span class=p>);</span>
</span></span><span class=line><span class=ln>56</span><span class=cl>            <span class=k>continue</span><span class=p>;</span>
</span></span><span class=line><span class=ln>57</span><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=ln>58</span><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=n>pid</span> <span class=o>==</span> <span class=mi>0</span><span class=p>)</span> <span class=c1>//子进程运行区域,此部分向客户端提供回声服务
</span></span></span><span class=line><span class=ln>59</span><span class=cl><span class=c1></span>        <span class=p>{</span>
</span></span><span class=line><span class=ln>60</span><span class=cl>            <span class=nf>close</span><span class=p>(</span><span class=n>serv_sock</span><span class=p>);</span> <span class=c1>//关闭服务器套接字，因为从父进程传递到了子进程
</span></span></span><span class=line><span class=ln>61</span><span class=cl><span class=c1></span>            <span class=k>while</span> <span class=p>((</span><span class=n>str_len</span> <span class=o>=</span> <span class=nf>read</span><span class=p>(</span><span class=n>clnt_sock</span><span class=p>,</span> <span class=n>buf</span><span class=p>,</span> <span class=n>BUFSIZ</span><span class=p>))</span> <span class=o>!=</span> <span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=ln>62</span><span class=cl>                <span class=nf>write</span><span class=p>(</span><span class=n>clnt_sock</span><span class=p>,</span> <span class=n>buf</span><span class=p>,</span> <span class=n>str_len</span><span class=p>);</span>
</span></span><span class=line><span class=ln>63</span><span class=cl>
</span></span><span class=line><span class=ln>64</span><span class=cl>            <span class=nf>close</span><span class=p>(</span><span class=n>clnt_sock</span><span class=p>);</span>
</span></span><span class=line><span class=ln>65</span><span class=cl>            <span class=nf>puts</span><span class=p>(</span><span class=s>&#34;client disconnected...&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=ln>66</span><span class=cl>            <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=ln>67</span><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=ln>68</span><span class=cl>        <span class=k>else</span>
</span></span><span class=line><span class=ln>69</span><span class=cl>            <span class=nf>close</span><span class=p>(</span><span class=n>clnt_sock</span><span class=p>);</span> <span class=c1>//通过 accept 函数创建的套接字文件描述符已经复制给子进程，因为服务器端要销毁自己拥有的
</span></span></span><span class=line><span class=ln>70</span><span class=cl><span class=c1></span>    <span class=p>}</span>
</span></span><span class=line><span class=ln>71</span><span class=cl>    <span class=nf>close</span><span class=p>(</span><span class=n>serv_sock</span><span class=p>);</span>
</span></span><span class=line><span class=ln>72</span><span class=cl>
</span></span><span class=line><span class=ln>73</span><span class=cl>    <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=ln>74</span><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=ln>75</span><span class=cl>
</span></span><span class=line><span class=ln>76</span><span class=cl><span class=kt>void</span> <span class=nf>error_handling</span><span class=p>(</span><span class=kt>char</span> <span class=o>*</span><span class=n>message</span><span class=p>)</span>
</span></span><span class=line><span class=ln>77</span><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=ln>78</span><span class=cl>    <span class=nf>fputs</span><span class=p>(</span><span class=n>message</span><span class=p>,</span> <span class=n>stderr</span><span class=p>);</span>
</span></span><span class=line><span class=ln>79</span><span class=cl>    <span class=nf>fputc</span><span class=p>(</span><span class=sc>&#39;\n&#39;</span><span class=p>,</span> <span class=n>stderr</span><span class=p>);</span>
</span></span><span class=line><span class=ln>80</span><span class=cl>    <span class=nf>exit</span><span class=p>(</span><span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=ln>81</span><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=ln>82</span><span class=cl><span class=kt>void</span> <span class=nf>read_childproc</span><span class=p>(</span><span class=kt>int</span> <span class=n>sig</span><span class=p>)</span>
</span></span><span class=line><span class=ln>83</span><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=ln>84</span><span class=cl>    <span class=kt>pid_t</span> <span class=n>pid</span><span class=p>;</span>
</span></span><span class=line><span class=ln>85</span><span class=cl>    <span class=kt>int</span> <span class=n>status</span><span class=p>;</span>
</span></span><span class=line><span class=ln>86</span><span class=cl>    <span class=n>pid</span> <span class=o>=</span> <span class=nf>waitpid</span><span class=p>(</span><span class=o>-</span><span class=mi>1</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>status</span><span class=p>,</span> <span class=n>WNOHANG</span><span class=p>);</span>
</span></span><span class=line><span class=ln>87</span><span class=cl>    <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;removed proc id: %d </span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>pid</span><span class=p>);</span>
</span></span><span class=line><span class=ln>88</span><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h4 id=1042-实现并发服务器>10.4.2 实现并发服务器</h4><h4 id=1043-通过-fork-函数复制文件描述符>10.4.3 通过 fork 函数复制文件描述符</h4><p><a href=https://github.com/riba2534/TCP-IP-NetworkNote/tree/master/ch10#1043-%e9%80%9a%e8%bf%87-fork-%e5%87%bd%e6%95%b0%e5%a4%8d%e5%88%b6%e6%96%87%e4%bb%b6%e6%8f%8f%e8%bf%b0%e7%ac%a6 target=_blank rel="noreferrer nofollow"></a></p><p>示例中给出了通过 fork 函数复制文件描述符的过程。父进程将 2 个套接字（一个是服务端套接字另一个是客户端套接字）文件描述符复制给了子进程。</p><p>调用 fork 函数时赋值父进程的所有资源，但是套接字不是归进程所有的，而是归操作系统所有，只是进程拥有代表相应套接字的文件描述符。</p><p><a href=https://camo.githubusercontent.com/8ccabd444c75005032ced58c0a132cb183cf667049d008142733e3e9cf7b8c6f/68747470733a2f2f73322e617831782e636f6d2f323031392f30312f32312f6b5037526a782e706e67 target=_blank rel="noreferrer nofollow"><p class=imgp><img loading=lazy src=https://camo.githubusercontent.com/8ccabd444c75005032ced58c0a132cb183cf667049d008142733e3e9cf7b8c6f/68747470733a2f2f73322e617831782e636f6d2f323031392f30312f32312f6b5037526a782e706e67 alt></p></a></p><p>如图所示，1 个套接字存在 2 个文件描述符时，只有 2 个文件描述符都终止（销毁）后，才能销毁套接字。如果维持图中的状态，即使子进程销毁了与客户端连接的套接字文件描述符，也无法销毁套接字（服务器套接字同样如此）。因此调用 fork 函数后，要将无关紧要的套接字文件描述符关掉，如图所示：</p><p><a href=https://camo.githubusercontent.com/83a617735ef7e79d738f4293a9a501205e962affd1cca3986f82e5ad32909537/68747470733a2f2f73322e617831782e636f6d2f323031392f30312f32312f6b5048375a542e706e67 target=_blank rel="noreferrer nofollow"><p class=imgp><img loading=lazy src=https://camo.githubusercontent.com/83a617735ef7e79d738f4293a9a501205e962affd1cca3986f82e5ad32909537/68747470733a2f2f73322e617831782e636f6d2f323031392f30312f32312f6b5048375a542e706e67 alt></p></a></p><h2 id=105-分割-tcp-的-io-程序>10.5 分割 TCP 的 I/O 程序</h2></main><br><footer><div class=footer-info><p>Copyright &copy; 2025 Rainboy. All rights reserved.
<span>| Last build: 2025-09-05 11:36:15</span></p></div><script defer>document.addEventListener("keydown",function(e){if(document.activeElement.isContentEditable)return!1;if(document.activeElement.tagName=="INPUT")return!1;if(e.altKey||e.ctrlKey||e.shiftKey)return!1;var t=e.key;if(t==="h")e.preventDefault(),e.stopPropagation(),window.location.href="/";else if(t==="t")e.preventDefault(),e.stopPropagation(),window.location.href=`https://${location.hostname}/tags`;else if(t==="i"){e.preventDefault(),e.stopPropagation();const t=document.querySelectorAll("input");for(let e=0;e<t.length;e++)if(t[e].offsetParent!==null){t[e].selectionStart=t[e].selectionEnd=t[e].value.length,t[e].focus();break}}return!1})</script><script defer>function throttle(e,t){var n=Date.now();return function(){var s=Date.now();n+t-s<0&&(e(),n=s)}}function scrollHandler(){const e=Array.from(document.querySelectorAll("body h2, body h3"));function t(){for(var n,s,o,i=window.pageYOffset||document.documentElement.scrollTop,t=0;t<e.length;t++)s=e[t].getAttribute("id"),n=document.querySelector('nav ul li a[href="#'+s+'"]'),n&&n.classList.remove("active-toc");for(t=e.length-1;t>=0;t--)if(o=e[t].offsetTop,i>o-75&&(s=e[t].getAttribute("id"),n=document.querySelector('nav ul li a[href="#'+s+'"]'),n)){n.classList.add("active-toc");break}}window.addEventListener("scroll",throttle(t,200))}setTimeout(scrollHandler,100)</script><script defer>function addCopyButtonToCodeBlocks(){const e=document.querySelectorAll('code[class^="language-"]:not(.output):not([class*="language-console"])');e.forEach(e=>{const t=document.createElement("button");t.classList.add("copy-code-button"),t.innerHTML="copy",t.addEventListener("click",()=>{const s=e.querySelectorAll(".cl");let n="";s.forEach(e=>{n+=e.innerText}),navigator.clipboard.writeText(n),t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},1500)}),e.parentNode.before(t)})}setTimeout(function(){addCopyButtonToCodeBlocks()},100)</script><script defer src=/js/theme-switcher.js></script><script src=//unpkg.com/heti/umd/heti-addon.min.js></script><script>const heti=new Heti(".heti");heti.autoSpacing()</script></footer></body></html>