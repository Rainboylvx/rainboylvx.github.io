<!doctype html><html lang=zh-cn><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta http-equiv=cache-control content="max-age=0"><meta http-equiv=cache-control content="no-cache"><meta http-equiv=expires content="0"><meta http-equiv=expires content="Tue, 01 Jan 1980 1:00:00 GMT"><meta http-equiv=pragma content="no-cache"><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png }><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=manifest href=/site.webmanifest><meta name=theme-color media="(prefers-color-scheme: light)" content="#ffffff"><meta name=theme-color media="(prefers-color-scheme: dark)" content="#1b1b1b"><meta name=description content><script>(function(){const e=localStorage.getItem("theme")||(window.matchMedia("(prefers-color-scheme: dark)").matches?"dark":"light");document.documentElement.setAttribute("data-theme",e)})()</script><title>| Rainboy's Blog</title><style>:root{--background:#ffffff}@media(prefers-color-scheme:dark){:root{--background:#1b1b1b}}html{background-color:var(--background)}body{background-color:var(--background)}</style><link rel=stylesheet type=text/css href=/style.min.4de9e3236bcb55312d0b2ff0fc62c694f607b9c0d95d0621f6c6dbacb7d6dbb5.css media=all><link rel=stylesheet href=/grid.css><link href="https://fonts.font.im/css?family=Roboto+Mono" rel=stylesheet><style>body,.heti,.heti--sans{font-family:roboto mono,monospace,times new roman,times,heti song,serif,apple color emoji,segoe ui emoji,segoe ui symbol}</style></head><body><nav><ul class=menu><li><a tabindex=-1 class=menu-link href=/><u>H</u>ome</a></li><li><a tabindex=-1 class=menu-link href=/tags><u>T</u>ags</a></li><li><span style=cursor:pointer id=theme-switcher class=menu-link type=button><svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-moon h-4 w-4"><path d="M12 3a6 6 0 009 9 9 9 0 11-9-9z"/></svg></span></li></ul></nav><div id=single-header><h1></h1><div id=single-meta></div></div><main class="heti heti--classic"><h1 id=第一章-理解网络编程和socket>第一章 理解网络编程和socket</h1><blockquote><p>![INFO]
网络编程就是编写程序使用两台连网的计算机相互交换数据.</p></blockquote><p>这就是整个网络编程的全部内容.我觉得不需要去详细的理解TCP/IP的细节.</p><p>下面我按我的理解这一章的内容.</p><p>如果我们想到在电脑上创建一个server端的软件,用来接收其它电脑上另一个程序通过网络发来的信息,应该如何做呢? 应该按下面的流程来做</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=ln>1</span><span class=cl>---
</span></span><span class=line><span class=ln>2</span><span class=cl>title: server socket 创建流程
</span></span><span class=line><span class=ln>3</span><span class=cl>---
</span></span><span class=line><span class=ln>4</span><span class=cl>flowchart TD
</span></span><span class=line><span class=ln>5</span><span class=cl>    step_1[1.创建socket,API:socket]
</span></span><span class=line><span class=ln>6</span><span class=cl>    step_2[2.绑定端口与ip: bind]
</span></span><span class=line><span class=ln>7</span><span class=cl>    step_3[3.开启监听 listen]
</span></span><span class=line><span class=ln>8</span><span class=cl>    step_4[4.接受产生的socket: accept ]
</span></span><span class=line><span class=ln>9</span><span class=cl>    step_1 --&gt; step_2 --&gt; step_3 --&gt; step_4;
</span></span></code></pre></div><h2 id=第一步创建-socket插座>第一步创建 socket(插座)</h2><p><p class=imgp><img loading=lazy src=chapter_1/assets/image.png alt="alt text"></p></p><p>如果我们家里需要网络通信,首先要有一个网络面板(网络插座)用来连接网络,然后才能通信. 同样我们也需要先创建一个socket,这个socket的作用就是用于后面的网络连接.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=ln>1</span><span class=cl><span class=kt>int</span> <span class=nf>socket</span><span class=p>(</span><span class=kt>int</span> <span class=n>domain</span><span class=p>,</span><span class=kt>int</span> <span class=n>type</span><span class=p>,</span><span class=kt>int</span> <span class=n>protocal</span><span class=p>)</span>
</span></span></code></pre></div><p>具体参数的含义与理解见一下章节</p><h2 id=第二步-bind函数>第二步 bind函数</h2><p>通过第一步我们创建了一个socket(插座),那么应该把它放在哪里呢?
其实就是根据哪些信息可以找到这个socket.</p><ol><li>信息首先要能发送给电脑,也就是需要知道电脑的IP,一个电脑可以有多个IP.</li></ol><p><p class=imgp><img loading=lazy src=chapter_1/assets/image-2.png alt=多网口></p></p><p>比如这个电脑就有两个网口,(单网口也可以有多IP)</p><ol start=2><li>可以想像到一个电脑上能进行网络通信的软件有多个,那么就有很多个socket.</li></ol><p><p class=imgp><img loading=lazy src=chapter_1/assets/image-3.png alt=2></p></p><p><p class=imgp><img loading=lazy src=chapter_1/assets/image-4.png alt=3></p></p><p><p class=imgp><img loading=lazy src=chapter_1/assets/image-5.png alt=4></p></p><p>电脑为了和外部通信,创建了端口这个概念.</p><p>你可以把端口想像成电脑一个一个孔洞,每一个数据通过这个孔洞发流入进电脑,如何你的socket"安装"在这个端口上,那么就可以接收到这个数据了.</p><p>然后这个socket和还需要和某一端口绑定在一起.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=ln>1</span><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;sys/socket.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=ln>2</span><span class=cl><span class=cp></span><span class=kt>int</span> <span class=nf>bind</span><span class=p>(</span><span class=kt>int</span> <span class=n>sockfd</span><span class=p>,</span><span class=k>struct</span> <span class=n>sockaddr_in</span> <span class=o>*</span> <span class=n>myaddr</span><span class=p>,</span><span class=kt>socklen_t</span> <span class=n>addrlen</span><span class=p>)</span>
</span></span></code></pre></div><h2 id=第三步-激活监听listen>第三步: 激活监听,listen</h2><p>现在我们有了一个socket,并把它放到了合适的位置(bind),接下就能通信了吗?
不能,还需要启用,激活它,就像家里弄了网络面板,网线,还需要网络公司给我们开通网络权限.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=ln>1</span><span class=cl><span class=kt>int</span> <span class=nf>listen</span><span class=p>(</span><span class=kt>int</span> <span class=n>sockfd</span><span class=p>,</span><span class=kt>int</span> <span class=n>backlog</span><span class=p>)</span>
</span></span></code></pre></div><p><code>listen</code>的其实是在<code>socket</code>创建一个监听队列,队列大小为<code>backlog</code>,每一个client请求连接后,就会加入到队列里,等待处理</p><h2 id=第四步-accept处理连接请求>第四步: accept,处理连接请求</h2><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=ln>1</span><span class=cl><span class=kt>int</span> <span class=nf>accept</span><span class=p>(</span><span class=kt>int</span> <span class=n>sockfd</span><span class=p>,</span><span class=k>struct</span> <span class=n>sockaddr</span> <span class=o>*</span> <span class=n>addr</span> <span class=p>,</span><span class=kt>socklen_t</span> <span class=o>*</span> <span class=n>addrlen</span><span class=p>);</span>
</span></span></code></pre></div><p>上一步,可以接收连接,然后加入到队列里,但是还需要对这些队列里的内容进行处理.</p><p><code>accept</code>的作用,从队列取出一个连接数据,然后创建一个<code>socket</code>.你可能会问,为什么又创建了一个socket,原来不是有一个吗?</p><p>首先我们要明确的知道一个概念,两个socket一在一起才能进行通信,或者说通信的两个电脑之间各有一个socket,不允许一socket对应多个socket.</p><p>第一个socket,我们的成为socket,我们称为<code>server socket</code>,它在同一时刻与一个client socket进行连接,然后接收到必要的信息之后.根据这些信息产生一个socket A.这个新的socket A已后只与这个client socket进行通信.</p><p>这个过程我们称为<code>accept</code></p><h2 id=server端代码>server端代码</h2><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=ln>1</span><span class=cl><span class=p>{{</span><span class=err>#</span><span class=n>include</span> <span class=n>code</span><span class=o>/</span><span class=mi>1</span><span class=o>-</span><span class=n>hello_world_server</span><span class=p>.</span><span class=n>c</span><span class=p>}}</span>
</span></span></code></pre></div><p>编译</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=ln>1</span><span class=cl>gcc -g -o server 1-hello_world_server.c
</span></span></code></pre></div><p>测试</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=ln>1</span><span class=cl>netcat -v 127.0.0.1 <span class=m>8989</span>
</span></span></code></pre></div><p>结果</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=ln>1</span><span class=cl>➞  netcat -v 127.0.0.1 8989                                                                                                                                  
</span></span><span class=line><span class=ln>2</span><span class=cl>localhost [127.0.0.1] 8989 (sunwebadmins) open
</span></span><span class=line><span class=ln>3</span><span class=cl>Hello World!%
</span></span></code></pre></div><h2 id=client端代码>client端代码</h2><p>client实现比较简单</p><ol><li>创建socket</li><li>调用connect,与server socket进行连接</li><li>发送数据</li><li>接收返回的数据</li><li>结束client socket</li></ol><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=ln>1</span><span class=cl><span class=p>{{</span><span class=err>#</span><span class=n>include</span> <span class=n>code</span><span class=o>/</span><span class=mi>1</span><span class=o>-</span><span class=n>hello_world_client</span><span class=p>.</span><span class=n>c</span><span class=p>}}</span>
</span></span></code></pre></div><p>运行结果</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=ln>1</span><span class=cl>➞  ./1-hello_world_client.out
</span></span><span class=line><span class=ln>2</span><span class=cl>Message from server: Hello World!
</span></span></code></pre></div><h2 id=inet_addr-函数>inet_addr 函数</h2><p><code>inet_addr</code> 是一个用于将 IPv4 地址从点分十进制字符串表示转换为网络字节序的 32 位二进制值的函数。它在 Linux 和其他类 Unix 系统的网络编程中广泛使用。</p><p><code>man 3 inet_addr</code></p><p>函数原型：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=ln>1</span><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;arpa/inet.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=ln>2</span><span class=cl><span class=cp></span><span class=kt>in_addr_t</span> <span class=nf>inet_addr</span><span class=p>(</span><span class=k>const</span> <span class=kt>char</span> <span class=o>*</span><span class=n>cp</span><span class=p>);</span>
</span></span></code></pre></div><p>参数：</p><ul><li><code>cp</code>：以点分十进制格式表示的 IPv4 地址字符串，例如 &ldquo;192.168.0.1&rdquo;。</li></ul><p>返回值：</p><ul><li>成功时，返回转换后的 32 位网络字节序的 IPv4 地址。</li><li>失败时，返回 <code>INADDR_NONE</code>（通常为 -1）。</li></ul><p><code>inet_addr</code> 函数将点分十进制格式的 IPv4 地址字符串转换为网络字节序的 32 位二进制值。它执行以下步骤：</p><ol><li>将点分十进制的 IPv4 地址字符串按照点号分隔符分割为四个部分，每个部分表示一个字节。</li><li>将每个部分转换为对应的整数值（0-255）。</li><li>将四个字节组合成一个 32 位的二进制值，并按照网络字节序排列。</li></ol><p>例如，对于 IP 地址 &ldquo;192.168.0.1&rdquo;，<code>inet_addr</code> 函数将返回一个 32 位的整数值 <code>0x0100A8C0</code>（网络字节序）。</p><p>使用示例：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=ln> 1</span><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;stdio.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=ln> 2</span><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;arpa/inet.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=ln> 3</span><span class=cl><span class=cp></span>
</span></span><span class=line><span class=ln> 4</span><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=ln> 5</span><span class=cl>    <span class=k>const</span> <span class=kt>char</span> <span class=o>*</span><span class=n>ip_str</span> <span class=o>=</span> <span class=s>&#34;192.168.0.1&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=ln> 6</span><span class=cl>    <span class=kt>in_addr_t</span> <span class=n>ip_addr</span> <span class=o>=</span> <span class=nf>inet_addr</span><span class=p>(</span><span class=n>ip_str</span><span class=p>);</span>
</span></span><span class=line><span class=ln> 7</span><span class=cl>    
</span></span><span class=line><span class=ln> 8</span><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>ip_addr</span> <span class=o>==</span> <span class=n>INADDR_NONE</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=ln> 9</span><span class=cl>        <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;无效的 IP 地址</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=ln>10</span><span class=cl>    <span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
</span></span><span class=line><span class=ln>11</span><span class=cl>        <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;IP 地址的网络字节序表示: 0x%08X</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>ip_addr</span><span class=p>);</span>
</span></span><span class=line><span class=ln>12</span><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=ln>13</span><span class=cl>    
</span></span><span class=line><span class=ln>14</span><span class=cl>    <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=ln>15</span><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>输出：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=ln>1</span><span class=cl>IP 地址的网络字节序表示: 0x0100A8C0
</span></span></code></pre></div><p>需要注意的是，<code>inet_addr</code> 函数只支持 IPv4 地址的转换，对于 IPv6 地址，需要使用 <code>inet_pton</code> 函数进行转换。</p><p>另外，由于 <code>inet_addr</code> 函数不能处理格式错误的 IP 地址字符串，因此在实际使用中，通常推荐使用更加健壮和通用的 <code>inet_pton</code> 函数来进行 IP 地址的转换。</p><h2 id=linux的文件操作>linux的文件操作</h2><p>每一个程序都有多个文件描述符,从 0 到 1023，这些0,1,2文件描述符被称为标准输入、标准输出、标准错误。</p><p>这个文件描述符是由linux系统维护的.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=ln>1</span><span class=cl><span class=kt>int</span> <span class=nf>open</span><span class=p>(</span><span class=k>const</span> <span class=kt>char</span> <span class=o>*</span><span class=n>pathname</span><span class=p>,</span> <span class=kt>int</span> <span class=n>flags</span><span class=p>);</span>
</span></span><span class=line><span class=ln>2</span><span class=cl><span class=kt>int</span> <span class=nf>close</span><span class=p>(</span><span class=kt>int</span> <span class=n>fd</span><span class=p>);</span>
</span></span><span class=line><span class=ln>3</span><span class=cl><span class=kt>ssize_t</span> <span class=nf>read</span><span class=p>(</span><span class=kt>int</span> <span class=n>fd</span><span class=p>,</span> <span class=kt>void</span> <span class=o>*</span><span class=n>buf</span><span class=p>,</span> <span class=kt>size_t</span> <span class=n>count</span><span class=p>);</span>
</span></span><span class=line><span class=ln>4</span><span class=cl><span class=kt>ssize_t</span> <span class=nf>write</span><span class=p>(</span><span class=kt>int</span> <span class=n>fd</span><span class=p>,</span> <span class=k>const</span> <span class=kt>void</span> <span class=o>*</span><span class=n>buf</span><span class=p>,</span> <span class=kt>size_t</span> <span class=n>count</span><span class=p>);</span>
</span></span></code></pre></div></main><br><footer><div class=footer-info><p>Copyright &copy; 2025 Rainboy. All rights reserved.
<span>| Last build: 2025-10-23 16:51:52</span></p></div><script defer>document.addEventListener("keydown",function(e){if(document.activeElement.isContentEditable)return!1;if(document.activeElement.tagName=="INPUT")return!1;if(e.altKey||e.ctrlKey||e.shiftKey)return!1;var t=e.key;if(t==="h")e.preventDefault(),e.stopPropagation(),window.location.href="/";else if(t==="t")e.preventDefault(),e.stopPropagation(),window.location.href=`https://${location.hostname}/tags`;else if(t==="i"){e.preventDefault(),e.stopPropagation();const t=document.querySelectorAll("input");for(let e=0;e<t.length;e++)if(t[e].offsetParent!==null){t[e].selectionStart=t[e].selectionEnd=t[e].value.length,t[e].focus();break}}return!1})</script><script defer>function throttle(e,t){var n=Date.now();return function(){var s=Date.now();n+t-s<0&&(e(),n=s)}}function scrollHandler(){const e=Array.from(document.querySelectorAll("body h2, body h3"));function t(){for(var n,s,o,i=window.pageYOffset||document.documentElement.scrollTop,t=0;t<e.length;t++)s=e[t].getAttribute("id"),n=document.querySelector('nav ul li a[href="#'+s+'"]'),n&&n.classList.remove("active-toc");for(t=e.length-1;t>=0;t--)if(o=e[t].offsetTop,i>o-75&&(s=e[t].getAttribute("id"),n=document.querySelector('nav ul li a[href="#'+s+'"]'),n)){n.classList.add("active-toc");break}}window.addEventListener("scroll",throttle(t,200))}setTimeout(scrollHandler,100)</script><script defer>function addCopyButtonToCodeBlocks(){const e=document.querySelectorAll('code[class^="language-"]:not(.output):not([class*="language-console"])');e.forEach(e=>{const t=document.createElement("button");t.classList.add("copy-code-button"),t.innerHTML="copy",t.addEventListener("click",()=>{const s=e.querySelectorAll(".cl");let n="";s.forEach(e=>{n+=e.innerText}),navigator.clipboard.writeText(n),t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},1500)}),e.parentNode.before(t)})}setTimeout(function(){addCopyButtonToCodeBlocks()},100)</script><script defer src=/js/theme-switcher.js></script></footer></body></html>