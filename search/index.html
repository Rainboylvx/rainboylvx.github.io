<!doctype html><html lang=en-us><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta http-equiv=cache-control content="max-age=0"><meta http-equiv=cache-control content="no-cache"><meta http-equiv=expires content="0"><meta http-equiv=expires content="Tue, 01 Jan 1980 1:00:00 GMT"><meta http-equiv=pragma content="no-cache"><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png }><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=manifest href=/site.webmanifest><meta name=theme-color media="(prefers-color-scheme: light)" content="#ffffff"><meta name=theme-color media="(prefers-color-scheme: dark)" content="#1b1b1b"><meta name=description content="Search Results"><script>(function(){const e=localStorage.getItem("theme")||(window.matchMedia("(prefers-color-scheme: dark)").matches?"dark":"light");document.documentElement.setAttribute("data-theme",e)})()</script><title>Search Results | Rainboy's Blog</title><style>:root{--background:#ffffff}@media(prefers-color-scheme:dark){:root{--background:#1b1b1b}}html{background-color:var(--background)}body{background-color:var(--background)}</style><link rel=stylesheet type=text/css href=/style.min.4949779f25399e232f316539d65018755245f3462edc4a256da50fd779d87ccc.css media=all><link rel=stylesheet href=/grid.css></head><body><nav><ul class=menu><li><a tabindex=-1 class=menu-link href=/><u>H</u>ome</a></li><li><a tabindex=-1 class=menu-link href=/tags><u>T</u>ags</a></li><li><span style=cursor:pointer id=theme-switcher class=menu-link type=button>🌙</span></li></ul></nav><main id=main class=post><header><h1 id=search-title>Search Results</h1></header><form id=search-form action=/search method=get><label hidden for=search-input>Search site</label>
<input tabindex=-1 type=text id=search-input name=query placeholder="search [i] ..."></form><ul id=search-results></ul></main><script>window.store={"https://hugo-dead-simple.netlify.com/tags/aggregation/":{title:"Aggregation",tags:[],content:"",url:"https://hugo-dead-simple.netlify.com/tags/aggregation/"},"https://hugo-dead-simple.netlify.com/tags/css/":{title:"CSS",tags:[],content:"",url:"https://hugo-dead-simple.netlify.com/tags/css/"},"https://hugo-dead-simple.netlify.com/typescript/debug/":{title:"debug",tags:[],content:`来自: https://www.bilibili.com/video/BV1zT411z7y7/
安装typescript 与ts-node 写一个ts的脚本 1let a = 1 2a = a+1 3console.log(a) 点击行下段点 点击vscode上的调试按钮 `,url:"https://hugo-dead-simple.netlify.com/typescript/debug/"},"https://hugo-dead-simple.netlify.com/tags/exercises/":{title:"Exercises",tags:[],content:"",url:"https://hugo-dead-simple.netlify.com/tags/exercises/"},"https://hugo-dead-simple.netlify.com/frontend/":{title:"FrontEnds",tags:[],content:"",url:"https://hugo-dead-simple.netlify.com/frontend/"},"https://hugo-dead-simple.netlify.com/tags/hugo/":{title:"Hugo",tags:[],content:"",url:"https://hugo-dead-simple.netlify.com/tags/hugo/"},"https://hugo-dead-simple.netlify.com/tags/javascript/":{title:"JavaScript",tags:[],content:"",url:"https://hugo-dead-simple.netlify.com/tags/javascript/"},"https://hugo-dead-simple.netlify.com/tags/mongodb/":{title:"MongoDB",tags:[],content:"",url:"https://hugo-dead-simple.netlify.com/tags/mongodb/"},"https://hugo-dead-simple.netlify.com/mongodb/lookup/":{title:"MongoDB - Lookup 操作详解",tags:["MongoDB","Aggregation"],content:`FAQ 如果实现类似的sql的 join 功能呢?
查看官方文档
$lookup（聚合）— MongoDB 手册 v8.0 ask ask : 我在写在mongodb的相关内容, 有一个user collection ,还有一个comment collection,commment通过 userid 与user 进行了关联,,我在查询comment ,如何得到每个comment 里的user 的相关属性? Answser 在 MongoDB 中，如果 comment 集合中的每个文档通过 userId 字段与 user 集合中的用户进行关联，并且你希望在查询 comment 时获取每个评论对应的 user 的相关属性，你可以使用 $lookup 聚合操作来实现联表查询。
示例数据结构 user 集合:
1{ 2 &#34;_id&#34;: ObjectId(&#34;user1&#34;), 3 &#34;name&#34;: &#34;Alice&#34;, 4 &#34;email&#34;: &#34;alice@example.com&#34;, 5 &#34;age&#34;: 30 6} comment 集合:
1{ 2 &#34;_id&#34;: ObjectId(&#34;comment1&#34;), 3 &#34;content&#34;: &#34;This is a comment&#34;, 4 &#34;userId&#34;: ObjectId(&#34;user1&#34;), 5 &#34;timestamp&#34;: ISODate(&#34;2024-12-09T10:00:00Z&#34;) 6} 使用 $lookup 进行联表查询 你可以使用聚合框架（aggregate()）结合 $lookup 来连接 comment 和 user 集合，并将每个评论对应的用户信息合并到评论数据中。
聚合查询示例 1db.comment.aggregate([ 2 { 3 $lookup: { 4 from: &#34;user&#34;, // 关联的集合是 &#34;user&#34; 5 localField: &#34;userId&#34;, // 当前集合中关联字段是 &#34;userId&#34; 6 foreignField: &#34;_id&#34;, // 关联到 &#34;user&#34; 集合中的 &#34;_id&#34; 字段 7 as: &#34;userDetails&#34; // 结果会放入 &#34;userDetails&#34; 数组字段 8 } 9 }, 10 { 11 $unwind: &#34;$userDetails&#34; // 将 &#34;userDetails&#34; 数组展开成单个对象（如果每个评论只能有一个用户的话） 12 } 13]) 查询结果 假设 comment 集合有一个文档，如下所示：
1{ 2 &#34;_id&#34;: ObjectId(&#34;comment1&#34;), 3 &#34;content&#34;: &#34;This is a comment&#34;, 4 &#34;userId&#34;: ObjectId(&#34;user1&#34;), 5 &#34;timestamp&#34;: ISODate(&#34;2024-12-09T10:00:00Z&#34;), 6 &#34;userDetails&#34;: { 7 &#34;_id&#34;: ObjectId(&#34;user1&#34;), 8 &#34;name&#34;: &#34;Alice&#34;, 9 &#34;email&#34;: &#34;alice@example.com&#34;, 10 &#34;age&#34;: 30 11 } 12} 解析说明 $lookup: 在 comment 集合中的 userId 字段和 user 集合中的 _id 字段之间建立连接，将匹配到的用户信息加入到每个评论中，并存储在 userDetails 字段中。
$unwind: 如果你确定每个评论只有一个对应的用户（即 userId 字段指向的是唯一用户），使用 $unwind 将 userDetails 数组拆解成单个对象。这样，你就可以直接在每个评论文档中获取到用户的属性。
如果一个评论可能有多个用户（例如评论可能有多个作者），你可以跳过 $unwind，这样每个评论的 userDetails 会是一个数组，包含匹配的所有用户。
其他改进 如果你只关心某些特定的用户字段，可以通过 $project 对返回的字段进行过滤，减少数据传输量。例如：
1db.comment.aggregate([ 2 { 3 $lookup: { 4 from: &#34;user&#34;, 5 localField: &#34;userId&#34;, 6 foreignField: &#34;_id&#34;, 7 as: &#34;userDetails&#34; 8 } 9 }, 10 { 11 $unwind: &#34;$userDetails&#34; 12 }, 13 { 14 $project: { 15 content: 1, // 只保留评论的内容 16 &#34;userDetails.name&#34;: 1, // 只返回用户的名字 17 &#34;userDetails.email&#34;: 1 // 只返回用户的邮箱 18 } 19 } 20]) 这样，结果将只包含评论内容以及用户的名字和邮箱。
总结 使用 aggregate() 方法结合 $lookup 可以轻松地在查询评论时获取每个评论对应用户的详细信息。如果你只关心部分用户字段，可以使用 $project 来限制返回的字段，优化查询效率。
`,url:"https://hugo-dead-simple.netlify.com/mongodb/lookup/"},"https://hugo-dead-simple.netlify.com/mongodb/find_on_array/":{title:"MongoDB - 在数组上查询",tags:["MongoDB","Querying"],content:`查询数组 - MongoDB 手册 v8.0
$ne操作在数组的查询与我想的不一样
如果你希望能够匹配数组中有部分元素与 &ldquo;red&rdquo; 不匹配的文档，可以使用 $elemMatch 来精确匹配数组中的单个元素：
1db.newdb.find({ 2 tags: { $elemMatch: { $ne: &#34;red&#34; } } 3}) 查询数组元素
多个条件
1const cursor = db.collection(&#39;inventory&#39;).find({ 2 dim_cm: { $gt: 15, $lt: 20 } 3}); 数学描述
∃x∈A(x&gt;=15)∧∃x∈A(x&lt;=20) \\exists x \\in A( x&gt;=15) \\land \\exists x \\in A (x &lt;=20) ∃x∈A(x&gt;=15)∧∃x∈A(x&lt;=20)1const cursor = db.collection(&#39;inventory&#39;).find({ 2 dim_cm: { $elemMatch: { $gt: 22, $lt: 30 } } 3}); ∃x∈A(x&gt;=15∧x&lt;=20) \\exists x \\in A( x&gt;=15 \\land x &lt;=20) ∃x∈A(x&gt;=15∧x&lt;=20)1const cursor = db.collection(&#39;inventory&#39;).find({ 2 dim_cm: {$eq:20} 3}); ∃x∈A(x=20) \\exists x \\in A( x=20) ∃x∈A(x=20)1const cursor = db.collection(&#39;inventory&#39;).find({ 2 dim_cm: {$ne:20} 3}); !!!注意这个查询是上面的查询的反面
¬∃x∈A(x=20)∀¬(x=20)∀(x!=20) \\begin{matrix} \\neg \\exists x \\in A(x = 20) \\\\ \\forall \\neg (x = 20) \\\\ \\forall (x != 20) \\end{matrix} ¬∃x∈A(x=20)∀¬(x=20)∀(x!=20)​`,url:"https://hugo-dead-simple.netlify.com/mongodb/find_on_array/"},"https://hugo-dead-simple.netlify.com/mongodb/":{title:"MongoDB 学习笔记",tags:[],content:`这里是我学习 MongoDB 过程中记录的所有笔记和练习。
MongoDB - Lookup 操作详解 MongoDB 练习 1 MongoDB 练习 2 MongoDB 练习 3 MongoDB 练习 4 MongoDB - 在数组上查询 `,url:"https://hugo-dead-simple.netlify.com/mongodb/"},"https://hugo-dead-simple.netlify.com/mongodb/mongodb/":{title:"MongoDB 学习笔记",tags:[],content:`安装 docker 安装,根据文档来: https://www.mongodb.com/zh-cn/docs/manual/tutorial/install-mongodb-community-with-docker/
安装完后,我根据 https://www.w3resource.com/mongodb-exercises/ 做练习
这里的客户端选择了mongodb compass: https://www.mongodb.com/try/download/compass
最重要的就是mongodb的官方文档: https://www.mongodb.com/zh-cn/docs/manual/
一些概念 1数据 --&gt; 集合-&gt; 文档 学习路线 我认为学习的路线为
增删改查 注意数组上查询的反直觉行为 注意$ne在数组的查询问题 聚合 索引 `,url:"https://hugo-dead-simple.netlify.com/mongodb/mongodb/"},"https://hugo-dead-simple.netlify.com/mongodb/exercise/":{title:"MongoDB 练习 1",tags:["MongoDB","Exercises"],content:`5 Write a MongoDB query to display all the restaurant which is in the borough Bronx. 这个简单,本质是查询固定的值
1db[&#34;restaurants&#34;].find({&#39;borough&#39;:&#39;Bronx&#39;}) 8 Write a MongoDB query to find the restaurants who achieved a score more than 90. 让我们查询一个数组,数组里面有一个Object的值&gt;=0
1db[&#34;restaurants&#34;].find({&#39;grades.score&#39;: {$gt : 90}}).count() 1db[&#34;restaurants&#34;].find({ &#39;grades&#39; : {$elemMatch : { &#34;score&#34; :{$gt : 90} } } }) 这两个的结果是等价的,只不过第二个用到了数组匹配操作符$elemMatch
9 Write a MongoDB query to find the restaurants that achieved a score, more than 80 but less than 100. 这个题目的意思是: grades里存在一个分数,这个分数在80与90之间
1db[&#34;restaurants&#34;].find({ &#39;grades&#39; : {$elemMatch : { &#34;score&#34; :{$gt : 80,$lt:100} } } }) 10 Write a MongoDB query to find the restaurants which locate in latitude value less than -95.754168. 这里考察我们如何查询数组里某个下标的值
1db.restaurants.find({&#34;address.coord.0&#34;:{$lte : -95.754168} }) 11 Write a MongoDB query to find the restaurants that do not prepare any cuisine of &lsquo;American&rsquo; and their grade score more than 70 and latitude less than -65.754168. 1db[&#34;restaurants&#34;].count({cuisine:{$not: {$regex: /.*American.*/ } },grades:{$elemMatch : { &#34;score&#34;:{$gte:70} }} }) 这里考查我们有多个条件,同时成立的查询
发现一个问题:
我查询了文档
mongodb在数组上的查询 https://www.mongodb.com/zh-cn/docs/manual/tutorial/query-arrays/#specify-multiple-conditions-for-array-elements mongodb - mongo $ne query with an array not working as expected - Stack Overflow $ne操作在数组的查询与我想的不一样
如果你希望能够匹配数组中有部分元素与 &ldquo;red&rdquo; 不匹配的文档，可以使用 $elemMatch 来精确匹配数组中的单个元素：
1db.newdb.find({ 2 tags: { $elemMatch: { $ne: &#34;red&#34; } } 3}) 这里官方给出的答案
1db.restaurants.find( 2 {$and: 3 [ 4 {&#34;cuisine&#34; : {$ne :&#34;American &#34;}}, 5 {&#34;grades.score&#34; : {$gt : 70}}, 6 {&#34;address.coord&#34; : {$lt : -65.754168}} 7 ] 8 }); 12 Write a MongoDB query to find the restaurants which do not prepare any cuisine of &lsquo;American&rsquo; and achieved a score more than 70 and located in the longitude less than -65.754168. Note : Do this query without using $and operator. 和上一个问题的问题一样,只是不让我们使用$and$符号
1db.restaurants.find( 2 { 3 &#34;cuisine&#34; : {$ne : &#34;American &#34;}, 4 &#34;grades.score&#34; :{$gt: 70}, 5 &#34;address.coord&#34; : {$lt : -65.754168} 6 } 7 ); 13 Write a MongoDB query to find the restaurants which do not prepare any cuisine of &lsquo;American&rsquo; and achieved a grade point &lsquo;A&rsquo; not belongs to the borough Brooklyn. The document must be displayed according to the cuisine in descending order. 前面的条件还好,这里只是多了一个排序的要求
1db.restaurants.find( { 2 &#34;cuisine&#34; : {$ne : &#34;American&#34;}, 3 &#34;grades.grade&#34; :&#34;A&#34;, 4 &#34;borough&#34;: {$ne : &#34;Brooklyn&#34;} 5 } 6 ).sort({&#34;cuisine&#34;:-1}); 14 Write a MongoDB query to find the restaurant Id, name, borough and cuisine for those restaurants which contain &lsquo;Wil&rsquo; as first three letters for its name. 查询的条件是name的首个三个字母是3个Wil字符.
我这里的写法与官方不一样,因为我不理解官方的第二个参数,为什么这样写,因为我查询的nodejs api 不是这样的.
https://mongodb.github.io/node-mongodb-native/6.11/interfaces/FindOptions.html#projection
1db[&#34;restaurants&#34;].find ({name:/AWil/}).projection({name:1,restaurant_id:1,borough:1,cuisine:1}}) 为什么会这样? ,AI 告诉我这是一个差异!!!
你提出的问题涉及到 MongoDB Node.js Driver 的 find 方法的第二个参数，它实际上是一个 选项对象（options），而 投影（projection） 是该选项对象中的一个字段。这是 MongoDB Node.js Driver 和 MongoDB Shell（mongosh）之间的一个差异。
MongoDB Node.js Driver 的 find 方法 根据你提供的链接，在 MongoDB 的 Node.js Driver 版本 3.6 中，find 方法的第二个参数 必须是一个选项对象，该对象中可以包含多个选项，例如 projection, sort, limit 等。
find 方法的签名（Node.js Driver） 1find(filter, options) filter: 查询条件。 options: 选项对象，其中包括多个可选的字段，例如 projection, sort, limit 等。 投影（Projection）在选项对象中 在 MongoDB Node.js Driver 中，投影（projection） 是通过选项对象中的 projection 字段来指定的。因此，第二个参数的形式通常是一个包含 projection 字段的对象，而 投影（projection） 本身是一个文档，定义了需要包含或排除的字段。
示例代码： 1const { MongoClient } = require(&#39;mongodb&#39;); 2 3async function queryRestaurants() { 4 const client = new MongoClient(&#39;mongodb://localhost:27017&#39;); 5 await client.connect(); 6 const db = client.db(&#39;test&#39;); // 假设你的数据库名是 &#39;test&#39; 7 const collection = db.collection(&#39;restaurants&#39;); 8 9 // 使用 find 查询并投影 10 const cursor = collection.find( 11 { name: /^Wil/ }, 12 { 13 projection: { 14 &#34;restaurant_id&#34;: 1, 15 &#34;name&#34;: 1, 16 &#34;borough&#34;: 1, 17 &#34;cuisine&#34;: 1 18 } 19 } 20 ); 21 22 // 获取查询结果并打印 23 const results = await cursor.toArray(); 24 console.log(results); 25 26 await client.close(); 27} 28 29queryRestaurants().catch(console.error); 为什么必须使用 projection 字段？ 在 Node.js MongoDB Driver 的 find 方法中，第二个参数是一个 选项对象（options），因此你需要明确指定 projection 字段来设置查询返回的字段。这是与 MongoDB Shell（mongosh） 的差异，后者可以直接将投影文档作为第二个参数。
Node.js Driver 的选项对象结构 在 Node.js 中，你可以传递一个包含多个选项字段的对象，例如：
1{ 2 projection: { &#34;restaurant_id&#34;: 1, &#34;name&#34;: 1, &#34;borough&#34;: 1, &#34;cuisine&#34;: 1 }, 3 sort: { name: 1 }, 4 limit: 10 5} projection: 指定返回的字段。 sort: 指定排序规则。 limit: 限制返回的文档数量。 总结 在 MongoDB Node.js Driver 中，第二个参数是一个 选项对象（options），其中包含 projection 字段来指定投影。而在 MongoDB Shell（mongosh） 中，第二个参数直接是一个投影文档，可以省略 projection 字段名。
Node.js Driver 使用 projection： 1db.restaurants.find( 2 { name: /^Wil/ }, 3 { projection: { &#34;restaurant_id&#34;: 1, &#34;name&#34;: 1, &#34;borough&#34;: 1, &#34;cuisine&#34;: 1 } } 4); MongoDB Shell 中直接传递投影文档： 1db.restaurants.find( 2 { name: /^Wil/ }, 3 { &#34;restaurant_id&#34;: 1, &#34;name&#34;: 1, &#34;borough&#34;: 1, &#34;cuisine&#34;: 1 } 4); 好吧,经过我的查询,这真的是一个差异:
https://stackoverflow.com/questions/67090307/mongodb-projection-syntax https://www.mongodb.com/zh-cn/docs/manual/reference/method/db.collection.findOne/ 两者确实不一样.
15 Write a MongoDB query to find the restaurant Id, name, borough and cuisine for those restaurants which contain &lsquo;ces&rsquo; as last three letters for its name. 和上一个问题一样,但是要查询的值是最后三个字符,还是使用regex
1db.restaurants.find( 2{name: /ces$/}, 3{ 4&#34;restaurant_id&#34; : 1, 5&#34;name&#34;:1,&#34;borough&#34;:1, 6&#34;cuisine&#34; :1 7} 8); 1db[&#34;restaurants&#34;].find ({name:/ces$/}).projection({name:1, 2restaurant_id:1,borough:1,cuisine:1}) 16 包含Reg+投影 Write a MongoDB query to find the restaurant Id, name, borough and cuisine for those restaurants which contain &lsquo;Reg&rsquo; as three letters somewhere in its name. 改变一下reg就可以了.
1db[&#34;restaurants&#34;].find({name:/Reg/},{name:1}).count() 2db[&#34;restaurants&#34;].find({name:/Reg/},{name:1}).count() 3 4db.restaurants.find( 5{&#34;name&#34;: /.*Reg.*/}, 6{ 7&#34;restaurant_id&#34; : 1, 8&#34;name&#34;:1,&#34;borough&#34;:1, 9&#34;cuisine&#34; :1 10} 11); 17 Write a MongoDB query to find the restaurants which belong to the borough Bronx and prepared either American or Chinese dish. 1db[&#34;restaurants&#34;].find({&#34;cuisine&#34;: {$in :[&#39;Chinese&#39;, &#39;American &#39;]} , 2 &#34;borough&#34;: &#34;Bronx&#34; 3},{&#34;cuisine&#34;:1}).count() 1db.restaurants.find( 2{ 3&#34;borough&#34;: &#34;Bronx&#34; , 4$or : [ 5{ &#34;cuisine&#34; : &#34;American &#34; }, 6{ &#34;cuisine&#34; : &#34;Chinese&#34; } 7] 8} 9); 18 Write a MongoDB query to find the restaurant Id, name, borough and cuisine for those restaurants which belong to the borough Staten Island or Queens or Bronxor Brooklyn.
和我的上一个执行$in的语法一样
1db.restaurants.find( 2 {&#34;borough&#34; :{$in :[&#34;Staten Island&#34;,&#34;Queens&#34;,&#34;Bronx&#34;,&#34;Brooklyn&#34;]}}, 3 { 4 &#34;restaurant_id&#34; : 1, 5 &#34;name&#34;:1,&#34;borough&#34;:1, 6 &#34;cuisine&#34; :1 7 } 8 ); 19 Write a MongoDB query to find the restaurant Id, name, borough and cuisine for those restaurants which are not belonging to the borough Staten Island or Queens or Bronxor Brooklyn.
从数理逻辑的角度来看,a∉{borough Staten Island , Queens , Bronxor Brooklyn}a \\notin \\{\\text{borough Staten Island , Queens , Bronxor Brooklyn} \\}a∈/{borough Staten Island , Queens , Bronxor Brooklyn} 当这个条件为true的时候,这里使用$nin操作
1db.restaurants.find( 2{&#34;borough&#34; :{$nin :[&#34;Staten Island&#34;,&#34;Queens&#34;,&#34;Bronx&#34;,&#34;Brooklyn&#34;]}}, 3{ 4&#34;restaurant_id&#34; : 1, 5&#34;name&#34;:1,&#34;borough&#34;:1, 6&#34;cuisine&#34; :1 7} 8); 20 Write a MongoDB query to find the restaurant Id, name, borough and cuisine for those restaurants which achieved a score which is not more than 10.
这里的核心就在于 not more than 10 ,数学写法
¬(grades.score&gt;10)⇔grades.score&lt;=10 \\neg (grades.score &gt; 10) \\Leftrightarrow grades.score &lt;= 10 ¬(grades.score&gt;10)⇔grades.score&lt;=101db[&#34;restaurants&#34;].find({&#34;grades.score&#34;: {$lte: 10}}).count() 2 3db.restaurants.find( {&#34;grades.score&#34; : { $not: {$gt : 10} } }).count() 恩&hellip;&hellip;&hellip;.., 两者竟然是不一样的.
题目应该问的是: 所有的分都不超过10.
$lte:10 应该是只要有一个(存在)&lt;=10 就成立
遇到这种事件,应该首先查文档: https://www.mongodb.com/zh-cn/docs/manual/reference/operator/query/not/,但文档上没有说.
find({ &quot;grades.score&quot;: {$gt : 10} }) 表示的意思其实是: ∃(x&gt;10)\\exists (x &gt; 10)∃(x&gt;10)
find({ &quot;grades.score&quot;: {$not :{ $gt : 10} }}) 表示的意思其实是: ¬∃(x&gt;10)→∀(x&lt;=10)\\neg \\exists (x &gt; 10) \\to \\forall (x&lt;=10)¬∃(x&gt;10)→∀(x&lt;=10),这样就能理解了
`,url:"https://hugo-dead-simple.netlify.com/mongodb/exercise/"},"https://hugo-dead-simple.netlify.com/mongodb/exercise2/":{title:"MongoDB 练习 2",tags:["MongoDB","Exercises"],content:`21 Write a MongoDB query to find the restaurant Id, name, borough and cuisine for those restaurants which prepared dish except &lsquo;American&rsquo; and &lsquo;Chinees&rsquo; or restaurant&rsquo;s name begins with letter &lsquo;Wil&rsquo;.
1db.restaurants.find({ 2 $or : [ 3 {&#34;name&#34;: /^Wil/}, 4 {&#34;cuisine&#34; : { $nin :[&#34;American &#34;,&#34;Chinees&#34;] }} 5 ] 6 }) 这两个写法是一样的
1db.restaurants.find( 2{$or: [ 3 {name: /^Wil/}, 4 {&#34;$and&#34;: [ 5 {&#34;cuisine&#34; : {$ne :&#34;American &#34;}}, 6 {&#34;cuisine&#34; : {$ne :&#34;Chinees&#34;}} 7 ]} 8]} 9,{&#34;restaurant_id&#34; : 1,&#34;name&#34;:1,&#34;borough&#34;:1,&#34;cuisine&#34; :1} 10); 22 Write a MongoDB query to find the restaurant Id, name, and grades for those restaurants which achieved a grade of &ldquo;A&rdquo; and scored 11 on an ISODate &ldquo;2014-08-11T00:00:00Z&rdquo; among many of survey dates. 达到了 grade A 且 scored 11. 首先,我们要理解这里的意思到底是什么意思?
有三个条件:
时间: ISODate &ldquo;2014-08-11T00:00:00Z 分值: 11 grade: A 这里的关键在于,数组grades其中的一条满足这3个条件.那么里这里要用到的$elemMatch
1db.restaurants.find({ 2 grades:{ $elemMatch : { grade:&#39;A&#39;,date:ISODate(&#34;2014-08-11T00:00:00Z&#34;), scored: 11}} 3 }) 但是给出的答案是,理解我写在注释里
1db.restaurants.find( 2 { // 这里是and 3 &#34;grades.date&#34;: ISODate(&#34;2014-08-11T00:00:00Z&#34;), // 这里只要有一个数组的元素成立 4 &#34;grades.grade&#34;:&#34;A&#34; , // 这里只要有一个数组的元素成立 5 &#34;grades.score&#34; : 11// 这里只要有一个数组的元素成立 6 }, 7 {&#34;restaurant_id&#34; : 1,&#34;name&#34;:1,&#34;grades&#34;:1} 8 ); 这里怎么用数学描述: 设集合A为A = [{},{},{},{}], 满足条件a∈A∧b∈A∧c∈Aa \\in A \\land b \\in A \\land c \\in Aa∈A∧b∈A∧c∈A
23 Write a MongoDB query to find the restaurant Id, name and grades for those restaurants where the 2nd element of grades array contains a grade of &ldquo;A&rdquo; and score 9 on an ISODate &ldquo;2014-08-11T00:00:00Z&rdquo;.
arrayElemAt（如果你需要明确选择数组中的特定元素）
如果你明确只想要查询数组的第二个元素，elemMatch 不能直接做这件事。不过，你可以结合 $arrayElemAt 来选择数组中的第二个元素进行条件匹配：
1db.collection.find({ 2 &#34;$expr&#34;: { 3 &#34;$eq&#34;: [ 4 { &#34;$arrayElemAt&#34;: [&#34;$grades&#34;, 1] }, // 获取第二个元素 5 { &#34;grade&#34;: &#34;A&#34;, &#34;score&#34;: 9, &#34;date&#34;: ISODate(&#34;2014-08-11T00:00:00Z&#34;) } // 条件 6 ] 7 } 8}) 那么还是官方给的答案比较简单:
1db.restaurants.find( 2 { &#34;grades.1.date&#34;: ISODate(&#34;2014-08-11T00:00:00Z&#34;), 3 &#34;grades.1.grade&#34;:&#34;A&#34; , 4 &#34;grades.1.score&#34; : 9 5 }, 6 {&#34;restaurant_id&#34; : 1,&#34;name&#34;:1,&#34;grades&#34;:1} 7 ); 24 Write a MongoDB query to find the restaurant Id, name, address and geographical location for those restaurants where 2nd element of coord array contains a value which is more than 42 and upto 52.
没有争议
1db.restaurants.find( 2 { 3 &#34;address.coord.1&#34;: {$gt : 42, $lte : 52} 4 }, 5 {&#34;restaurant_id&#34; : 1,&#34;name&#34;:1,&#34;address&#34;:1,&#34;coord&#34;:1} 6 ); 25,26 Write a MongoDB query to arrange the name of the restaurants in ascending order along with all the columns. Write a MongoDB query to arrange the name of the restaurants in descending along with all the columns. 就是排序而已
1db.restaurants.find().sort({&#34;name&#34;:1}); 2db.restaurants.find().sort( {&#34;name&#34;:-1}); 27 Write a MongoDB query to arranged the name of the cuisine in ascending order and for that same cuisine borough should be in descending order.
还是排序,不过同时要排序两个元素
1db.restaurants.find().sort( 2 {&#34;cuisine&#34;:1,&#34;borough&#34; : -1,} 3 ); 28 Write a MongoDB query to know whether all the addresses contains the street or not.
查询元素的存在性
1db.restaurants.find( {&#34;address.street&#34; : { $exists : true } } ); 29 Write a MongoDB query which will select all documents in the restaurants collection where the coord field value is Double.
查询元素的类型
对于 field 为数组的文档，$type 返回的文档中至少有一个数组元素与传递给 $type 的类型匹配。
对 $type: &ldquo;array&rdquo; 的查询会返回字段本身为数组的文档。
$type — MongoDB 手册 v8.0
1db.restaurants.find( {&#34;address.coord&#34; : {$type : 1} }); 30 Write a MongoDB query which will select the restaurant Id, name and grades for those restaurants which returns 0 as a remainder after dividing the score by 7.
这里用到了 $mod - MongoDB 手册 v8.0
1db.restaurants.find( 2 {&#34;grades.score&#34; : 3 {$mod : [7,0]} 4 }, 5 {&#34;restaurant_id&#34; : 1,&#34;name&#34;:1,&#34;grades&#34;:1} 6 ); 31 Write a MongoDB query to find the restaurant name, borough, longitude and attitude and cuisine for those restaurants which contains &lsquo;mon&rsquo; as three letters somewhere in its name.
正则查询
1db.restaurants.find( 2 { name : 3 { $regex : &#34;mon.*&#34;, $options: &#34;i&#34; } 4 }, 5 { 6 &#34;name&#34;:1, 7 &#34;borough&#34;:1, 8 &#34;address.coord&#34;:1, 9 &#34;cuisine&#34; :1 10 } 11 ); 32 Write a MongoDB query to find the restaurant name, borough, longitude and latitude and cuisine for those restaurants which contain &lsquo;Mad&rsquo; as first three letters of its name.
正则查询
1db.restaurants.find( 2 { name : 3 { $regex : /^Mad/i, } 4 }, 5 { 6 &#34;name&#34;:1, 7 &#34;borough&#34;:1, 8 &#34;address.coord&#34;:1, 9 &#34;cuisine&#34; :1 10 } 11 ); 33 Write a MongoDB query to find the restaurants that have at least one grade with a score of less than 5.
数组查询
1db.restaurants.find({ &#34;grades.score&#34;: { $lt: 5 } }) 34 Write a MongoDB query to find the restaurants that have at least one grade with a score of less than 5 and that are located in the borough of Manhattan.
怎么变简单了?
1db.restaurants.find({ &#34;grades.score&#34;: { $lt: 5 }, &#34;borough&#34;: &#34;Manhattan&#34; }) 35 Write a MongoDB query to find the restaurants that have at least one grade with a score of less than 5 and that are located in the borough of Manhattan or Brooklyn.
还是简单
1db.restaurants.find({ 2 $and: [ 3 { 4 $or: [ // 可以用$in 5 {borough: &#34;Manhattan&#34;}, 6 {borough: &#34;Brooklyn&#34;} 7 ] 8 }, 9 { 10 &#34;grades.score&#34;: { $lt: 5 } 11 } 12 ] 13}) 36 Write a MongoDB query to find the restaurants that have at least one grade with a score of less than 5 and that are located in the borough of Manhattan or Brooklyn, and their cuisine is not American.
官方给的这个答案,可以不用最外层的$and
1db.restaurants.find({ 2 $and: [ 3{ $or: [{ borough: &#34;Manhattan&#34; }, { borough: &#34;Brooklyn&#34; }] }, 4{ &#34;grades.score&#34;: { $lt: 5 } }, 5{ cuisine: { $ne: &#34;American&#34; } } 6 ] 7}) 37 Write a MongoDB query to find the restaurants that have at least one grade with a score of less than 5 and that are located in the borough of Manhattan or Brooklyn, and their cuisine is not American or Chinese.
这里用到了不是...,也不是....这个也语法
$nor - MongoDB 手册 v8.0
选择数组中所有查询谓词均未通过的文档
1$nor :[ expr1 ,expr2...] 那么查询的文档满足的条件是：
1expr1(doc1) == false and expr2(doc2) == false 38 Write a MongoDB query to find the restaurants that have a grade with a score of 2 and a grade with a score of 6.
grades 含有2，和6
我写的
1db.restaurants.find({ 2 &#34;grades.score&#34;: 2, 3 &#34;grades.score&#34;: 6, 4 }) 效果一样的官方答案。
1db.restaurants.find({ 2 $and: [ 3 {&#34;grades.score&#34;: 2}, 4 {&#34;grades.score&#34;: 6} 5 ] 6}) 39 Write a MongoDB query to find the restaurants that have a grade with a score of 2 and a grade with a score of 6 and are located in the borough of Manhattan.
没有什么难度
1db.restaurants.find({ 2 $and: [ 3 {&#34;grades.score&#34;: 2}, 4 {&#34;grades.score&#34;: 6}, 5 {&#34;borough&#34;: &#34;Manhattan&#34;} 6 ] 7}) 40 Write a MongoDB query to find the restaurants that have a grade with a score of 2 and a grade with a score of 6 and are located in the borough of Manhattan or Brooklyn.
1db.restaurants.find({ 2 $and: [ 3 {&#34;grades.score&#34;: 2}, 4 {&#34;grades.score&#34;: 6}, 5 {&#34;borough&#34;: {&#34;$in&#34;: [&#34;Manhattan&#34;, &#34;Brooklyn&#34;]}} 6 ] 7}) `,url:"https://hugo-dead-simple.netlify.com/mongodb/exercise2/"},"https://hugo-dead-simple.netlify.com/mongodb/exercise3/":{title:"MongoDB 练习 3",tags:["MongoDB","Exercises"],content:`41 Write a MongoDB query to find the restaurants that have a grade with a score of 2 and a grade with a score of 6 and are located in the borough of Manhattan or Brooklyn, and their cuisine is not American.
没有什么难度
1db.restaurants.find({ 2 $and: [ 3 {borough: {$in: [&#34;Manhattan&#34;, &#34;Brooklyn&#34;]}}, 4 {&#34;grades.score&#34;: {$all: [2, 6]}}, 5 {cuisine: {$ne: &#34;American&#34;}} 6 ] 7}) 这里用到了$all运算符, 表示后面的值[2,6]都要单独同时匹配
42 Write a MongoDB query to find the restaurants that have a grade with a score of 2 and a grade with a score of 6 and are located in the borough of Manhattan or Brooklyn, and their cuisine is not American or Chinese.
1db.restaurants.find({ 2 $and: [ 3{ borough: { $in: [&#34;Manhattan&#34;, &#34;Brooklyn&#34;] } }, 4{ cuisine: { $nin: [&#34;American&#34;, &#34;Chinese&#34;] } }, 5{ grades: { $elemMatch: { score: 2 } } }, 6{ grades: { $elemMatch: { score: 6 } } } 7 ] 8}) 43 Write a MongoDB query to find the restaurants that have a grade with a score of 2 or a grade with a score of 6.
1db.restaurants.find({ 2 $or: [ 3{ &#34;grades.score&#34;: 2 }, 4{ &#34;grades.score&#34;: 6 } 5 ] 6}) 44 Write a MongoDB query to find the restaurants that have a grade with a score of 2 or a grade with a score of 6 and are located in the borough of Manhattan.
没有什么难度
1db.restaurants.find({ 2 $and: [ 3 { 4 $or: [ 5{ &#34;grades.score&#34;: 2 }, 6{ &#34;grades.score&#34;: 6 } 7 ] 8 }, 9{ &#34;borough&#34;: &#34;Manhattan&#34; } 10 ] 11}) 45 Write a MongoDB query to find the restaurants that have a grade with a score of 2 or a grade with a score of 6 and are located in the borough of Manhattan or Brooklyn.
1db.restaurants.find({ 2 $and: [ 3 { 4 $or: [ 5{ borough: &#34;Manhattan&#34; }, 6{ borough: &#34;Brooklyn&#34; } 7 ] 8 }, 9 { 10 $or: [ 11{ &#34;grades.score&#34;: 2 }, 12{ &#34;grades.score&#34;: 6 } 13 ] 14 } 15 ] 16}) 48 Write a MongoDB query to find the restaurants that have all grades with a score greater than 5.
这个是比较有意思的查询: 所有grade.score都要大于5
正确的查询数组里的值,都是存在,现在要转成\\forall
1db.restaurants.find({ 2 &#34;grades&#34;: { 3 &#34;$not&#34;: { 4 &#34;$elemMatch&#34;: { 5 &#34;score&#34;: { 6 &#34;$lte&#34;: 5 7 } 8 } 9 } 10 } 11}) 49 Write a MongoDB query to find the restaurants that have all grades with a score greater than 5 and are located in the borough of Manhattan.
多个条件,关键就在于这个条件:所有的
50 Write a MongoDB query to find the restaurants that have all grades with a score greater than 5 and are located in the borough of Manhattan or Brooklyn.
不难,这里有一个条件,或者
1db.restaurants.find({ 2 &#34;borough&#34;: { 3 &#34;$in&#34;: [&#34;Manhattan&#34;, &#34;Brooklyn&#34;] 4 }, 5 &#34;grades&#34;: { 6 &#34;$not&#34;: { 7 &#34;$elemMatch&#34;: { 8 &#34;score&#34;: { 9 &#34;$lte&#34;: 5 10 } 11 } 12 } 13 } 14}) `,url:"https://hugo-dead-simple.netlify.com/mongodb/exercise3/"},"https://hugo-dead-simple.netlify.com/mongodb/exercise4/":{title:"MongoDB 练习 4",tags:["MongoDB","Exercises"],content:`51 Write a MongoDB query to find the average score for each restaurant.
一个数组的平均值
这里我遇到的第一个 aggregate
1db.restaurants.aggregate([{ 2 $unwind: &#34;$grades&#34; 3 }, 4 { 5 $group: { 6 _id: &#34;$name&#34;, 7 avgScore: { 8 $avg: &#34;$grades.score&#34; 9 } 10 } 11 } 12]) 这里gpt给出的多种求平均值的方法
在 MongoDB 中，要求数组的平均值可以使用 聚合框架 来处理。MongoDB 的聚合框架提供了强大的数据操作功能，包括计算数组中元素的平均值。可以通过以下几种方式来实现：
假设我们有以下文档集合： 1{ 2 &#34;_id&#34;: 1, 3 &#34;scores&#34;: [90, 80, 70, 85] 4}, 5{ 6 &#34;_id&#34;: 2, 7 &#34;scores&#34;: [60, 75, 85, 90] 8} 方法 1：使用 $avg 操作符 MongoDB 的聚合框架允许在管道中使用 $avg 操作符来计算某个数组的平均值。为了计算数组 scores 的平均值，我们需要先将数组元素展开（使用 $unwind），然后计算平均值。
聚合管道示例： 1db.collection.aggregate([ 2 { 3 $project: { 4 averageScore: { $avg: &#34;$scores&#34; } 5 } 6 } 7]) 解释： $project：用于指定输出的字段，在这里我们指定了一个新字段 averageScore。 $avg：用于计算指定字段的平均值。在这里，我们应用 $avg 操作符来计算 scores 数组的平均值。 方法 2：使用 $unwind 与 $group 来求平均值 如果你想更细粒度地处理数组中的元素，可以使用 $unwind 来展平数组，然后使用 $group 来求数组的平均值。
聚合管道示例： 1db.collection.aggregate([ 2 { $unwind: &#34;$scores&#34; }, 3 { $group: { _id: null, averageScore: { $avg: &#34;$scores&#34; } } } 4]) 解释： $unwind：将 scores 数组中的每个元素展平为单独的文档。每个文档将包含一个数组元素。 $group：将所有展平后的文档组合在一起，并使用 $avg 来计算这些文档中 scores 字段的平均值。 这个方法适用于当你希望对数组中的所有元素进行处理并计算平均值的情况。
方法 3：直接计算字段的平均值 如果数组字段本身已经包含了所有的数值，且你只想计算这个数组字段的平均值，而不是数组中的每个元素，可以直接在 aggregate 阶段中计算平均值：
示例： 1db.collection.aggregate([ 2 { 3 $project: { 4 averageScore: { $avg: &#34;$scores&#34; } 5 } 6 } 7]) 总结： $avg 用于计算一个数值字段的平均值，可以直接在聚合管道中对数组字段进行操作。 $unwind + $group 适用于需要将数组元素分开处理，并求所有元素的平均值。 根据需求选择适合的方法，通常情况下，直接使用 $avg 对数组字段求平均值最为简单和高效。
52 Write a MongoDB query to find the highest score for each restaurant.
这里用到了 $group阶段的$max操作
1db.restaurants.aggregate([{ 2 $unwind: &#34;$grades&#34; 3 }, 4 { 5 $group: { 6 _id: &#34;$name&#34;, 7 highest_score: { 8 $max: &#34;$grades.score&#34; 9 } 10 } 11 } 12]) 53 Write a MongoDB query to find the lowest score for each restaurant.
和上一个题目一样，用$min
1db.restaurants.aggregate([{ 2 $unwind: &#34;$grades&#34; 3 }, 4 { 5 $group: { 6 _id: &#34;$name&#34;, 7 lowest_score: { 8 $min: &#34;$grades.score&#34; 9 } 10 } 11 } 12]) 54 Write a MongoDB query to find the count of restaurants in each borough.
用到了count
1db.restaurants.aggregate([{ 2 $group: { 3 _id: &#34;$borough&#34;, 4 count: { 5 $sum: 1 6 } 7 } 8}]) 55 Write a MongoDB query to find the count of restaurants for each cuisine.
只是用到了$sum
1db.restaurants.aggregate([{ 2 $group: { 3 _id: &#34;$cuisine&#34;, 4 count: { 5 $sum: 1 6 } 7 } 8}]) 56 如何按两个值进行分组 1db.restaurants.aggregate([{ 2 $group: { 3 _id: { 4 cuisine: &#34;$cuisine&#34;, 5 borough: &#34;$borough&#34; 6 }, 7 count: { 8 $sum: 1 9 } 10 } 11}]) 57 多阶段配合 Write a MongoDB query to find the count of restaurants that received a grade of &lsquo;A&rsquo; for each cuisine.
多阶段
unwind match group 1db.restaurants.aggregate([ 2 { 3 $unwind: &#34;$grades&#34; 4 }, 5 { 6 $match: { &#34;grades.grade&#34;: &#34;A&#34; } 7 }, 8 { 9 $group: { 10 _id: &#34;$cuisine&#34;, 11count: { $sum: 1 } 12 } 13 } 14]) 58 同上 Write a MongoDB query to find the count of restaurants that received a grade of &lsquo;A&rsquo; for each borough.
1db.restaurants.aggregate([ 2 { 3 $unwind: &#34;$grades&#34; 4 }, 5 { 6 $match: { &#34;grades.grade&#34;: &#34;A&#34; } 7 }, 8 { 9 $group: { 10 _id: &#34;$borough&#34;, 11count: { $sum: 1 } 12 } 13 } 14]) 59 Write a MongoDB query to find the count of restaurants that received a grade of &lsquo;A&rsquo; for each cuisine and borough.
聚合确实能达到
这里没有unwind
1db.restaurants.aggregate([ 2 { 3 $match: { &#34;grades.grade&#34;: &#34;A&#34; } 4 }, 5 { 6 $group: { 7 _id: { cuisine: &#34;$cuisine&#34;, borough: &#34;$borough&#34; }, 8count: { $sum: 1 } 9 } 10 }, 11 { 12 $sort: { count: -1 } 13 } 14]); 60 Write a MongoDB query to find the number of restaurants that have been graded in each month of the year.
问一年中，每个月分评级的restaurants分别有多少个,那显然要$group
1db.restaurants.aggregate([ 2 { 3 $unwind: &#34;$grades&#34; 4 }, 5 { 6 $project: { 7month: { $month: { $toDate: &#34;$grades.date&#34; } }, 8year: { $year: { $toDate: &#34;$grades.date&#34; } } 9 } 10 }, 11 { 12 $group: { 13 _id: { month: &#34;$month&#34;, year: &#34;$year&#34; }, 14count: { $sum: 1 } 15 } 16 }, 17 { 18 $sort: { 19 &#34;_id.year&#34;: 1, 20 &#34;_id.month&#34;: 1 21 } 22 } 23]); 61-66 平均分,最高低分 上面求过了
67 Write a MongoDB query to find the name and address of the restaurants that received a grade of &lsquo;A&rsquo; on a specific date
查询一个array里满足特定条件的。
1db.restaurants.find( 2 { 3 &#34;grades&#34;: { 4 &#34;$elemMatch&#34;: { 5 &#34;date&#34;: { 6 &#34;$eq&#34;: ISODate(&#34;2013-07-22T00:00:00Z&#34;) 7 }, 8 &#34;grade&#34;: { 9 &#34;$eq&#34;: &#34;A&#34; 10 } 11 } 12 } 13 }, 14 { 15 &#34;name&#34;: 1, 16 &#34;address&#34;: 1, 17 &#34;_id&#34;: 0 18 } 19) 68 Write a MongoDB query to find the name and address of the restaurants that received a grade of &lsquo;B&rsquo; or &lsquo;C&rsquo; on a specific date.
1db.restaurants.find( 2 { 3 &#34;grades&#34;: { 4 $elemMatch: { 5 &#34;date&#34;: ISODate(&#34;2013-04-05&#34;), 6 &#34;grade&#34;: { $in: [ &#34;B&#34;, &#34;C&#34; ] } 7 } 8 } 9 }, 10 { 11 &#34;name&#34;: 1, 12 &#34;address&#34;: 1 13 } 14) 69 Write a MongoDB query to find the name and address of the restaurants that have at least one &lsquo;A&rsquo; grade and one &lsquo;B&rsquo; grade.
啊！ 查询数组里： 至少含有一个A，且至少含有一个B ,\\exits A in arr \\and \\exits B in arr
70 Write a MongoDB query to find the name and address of the restaurants that have at least one &lsquo;A&rsquo; grade and no &lsquo;B&rsquo; grades.
one A no B.两个条件同时成立
no b -&gt; not exits b in Arr -&gt; {$not : { &quot;grades.score&quot; : 'A'}
和我想的差不多
1db.restaurants.find({ 2 $and: [ 3{ &#34;grades.grade&#34;: &#34;A&#34; }, 4{ &#34;grades.grade&#34;: { $not: { $eq: &#34;B&#34; } } } 5 ] 6}, 7{ name: 1, address: 1, _id: 0 }) 71 Write a MongoDB query to find the name ,address and grades of the restaurants that have at least one &lsquo;A&rsquo; grade and no &lsquo;C&rsquo; grades.
同上
1db.restaurants.find({ 2 $and: [ 3{ &#34;grades.grade&#34;: &#34;A&#34; }, 4{ &#34;grades.grade&#34;: { $not: { $eq: &#34;C&#34; } } } 5 ] 6}, 7{ name: 1, address: 1, &#34;grades.grade&#34;:1, _id: 0 }) 72 Write a MongoDB query to find the name, address, and grades of the restaurants that have at least one &lsquo;A&rsquo; grade, no &lsquo;B&rsquo; grades, and no &lsquo;C&rsquo; grades.
同上
1db.restaurants.find({ 2 $and: [ 3{ &#34;grades.grade&#34;: &#34;A&#34; }, 4{ &#34;grades.grade&#34;: { $not: { $eq: &#34;B&#34; } } }, 5{ &#34;grades.grade&#34;: { $not: { $eq: &#34;C&#34; } } } 6 ] 7}, 8{ name: 1, address: 1, &#34;grades.grade&#34;:1, _id: 0 }) 73 Write a MongoDB query to find the name and address of the restaurants that have the word &lsquo;coffee&rsquo; in their name
正则
1db.restaurants.find({ name: { $regex: /coffee/i } }, { name: 1, address: 1 }) 74 Write a MongoDB query to find the name and address of the restaurants that have a zipcode that starts with &lsquo;10&rsquo;.
这里我觉得官方给的答案不对。
75 Write a MongoDB query to find the name and address of the restaurants that have a cuisine that starts with the letter &lsquo;B&rsquo;.
1db.restaurants.find( 2	{ &#34;cuisine&#34;: { $regex: /^B/ } }, 3	{ &#34;name&#34;: 1, 4	&#34;address&#34;: 1, 5	&#34;cuisine&#34; : 1, 6	&#34;_id&#34;: 0 } 7) 76 77 正则 没有什么好写的
78 找最大值，那就需要排序
1db.restaurants.aggregate([ 2 {$unwind: &#34;$grades&#34;}, 3 {$group: { 4 _id: &#34;$restaurant_id&#34;, 5avgScore: {$avg: &#34;$grades.score&#34;} 6 }}, 7 {$sort: {avgScore: -1}}, 8 {$limit: 1}, 9 {$project: {_id: 1, avgScore: 1}} 10]) 79 找最大的值A的那些restaurants的id，用到聚合
1db.restaurants.aggregate([ 2 {$unwind: &#34;$grades&#34;}, 3 {$match: {&#34;grades.grade&#34;: &#34;A&#34;}}, 4 {$group: { 5 _id: &#34;$restaurant_id&#34;, 6count: {$sum: 1} 7 }}, 8 {$sort: {count: -1}}, 9 {$group: { 10 _id: &#34;$count&#34;, 11restaurants: {$push: &#34;$_id&#34;} 12 }}, 13 {$sort: {_id: -1}}, 14 {$limit: 1}, 15 {$project: {restaurants: 1}} 16]) 80 Write a MongoDB query to find the cuisine type that is most likely to receive a &lsquo;C&rsquo; grade.
哪个区域的C最多,用到了聚合
1db.restaurants.aggregate([ 2 {$unwind: &#34;$grades&#34;}, 3 {$match: {&#34;grades.grade&#34;: &#34;C&#34;}}, 4 {$group: {_id: &#34;$cuisine&#34;, count: {$sum: 1}}}, 5 {$sort: {count: -1}} 6]) 81 Write a MongoDB query to find the restaurant that has the highest average score for thecuisine &ldquo;Turkish&rdquo;.
聚合。
82 Write a MongoDB query to find the restaurants that achieved the highest total score.
连续的聚合,聚合就是一种管道。
1db.restaurants.aggregate([ 2{ $unwind: &#34;$grades&#34; }, 3{ $group: { 4 _id: &#34;$name&#34;, 5totalScore: { $sum: &#34;$grades.score&#34; } 6 }}, 7{ $sort: { totalScore: -1 } }, 8{ $group: { 9 _id: &#34;$totalScore&#34;, 10restaurants: { $push: &#34;$_id&#34; } 11 }}, 12{ $sort: { _id: -1 } }, 13{ $limit: 1 }, 14{ $unwind: &#34;$restaurants&#34; }, 15{ $group: { 16 _id: &#34;$_id&#34;, 17restaurants: { $push: &#34;$restaurants&#34; } 18 }} 19]) 83 `,url:"https://hugo-dead-simple.netlify.com/mongodb/exercise4/"},"https://hugo-dead-simple.netlify.com/tags/querying/":{title:"Querying",tags:[],content:"",url:"https://hugo-dead-simple.netlify.com/tags/querying/"},"https://hugo-dead-simple.netlify.com/tags/":{title:"Tags",tags:[],content:"",url:"https://hugo-dead-simple.netlify.com/tags/"},"https://hugo-dead-simple.netlify.com/typescript/typeof%E7%9A%84%E4%BD%BF%E7%94%A8/":{title:"typeof的使用",tags:[],content:`在 TypeScript 中，typeof 是一个非常强大的运算符，它有两个主要用途：一种用于 获取值的类型，另一种用于 获取类型的构造函数。下面我们分别解释这两种用途，并给出一些示例。
1. typeof 用于获取值的类型 在 TypeScript 中，typeof 可以用来获取一个值的类型。你可以通过 typeof 来推断或显式地获取变量的类型。
示例：获取值的类型 1let x = &#34;hello&#34;; 2let y: typeof x; // y 的类型会自动推断为 string 3 4y = &#34;world&#34;; // 正确 5// y = 42; // 错误: 类型 &#39;number&#39; 不能赋值给类型 &#39;string&#39; typeof x 会推断出变量 x 的类型。在这个例子中，x 是一个 string，所以 y 的类型也会被推断为 string。 你可以将 typeof 用于变量声明，或者在类型注解中指定类型。 示例：获取对象属性的类型 1const person = { name: &#34;Alice&#34;, age: 30 }; 2let nameType: typeof person.name; // nameType 的类型是 string 3let ageType: typeof person.age; // ageType 的类型是 number 这里，typeof person.name 会得到 person.name 的类型（即 string），typeof person.age 会得到 number。 2. typeof 用于获取类型 typeof 还可以用来获取 类型的构造函数，特别是在你需要引用某个类型或类型的构造函数时。这个用途通常与 keyof 一起使用来限制某个值的类型。
示例：获取类的构造函数类型 1class Person { 2 name: string; 3 constructor(name: string) { 4 this.name = name; 5 } 6} 7 8let PersonConstructor: typeof Person; // PersonConstructor 的类型是 \`typeof Person\`，即构造函数类型 9PersonConstructor = Person; // 正确 10// PersonConstructor = String; // 错误: 类型 &#39;typeof String&#39; 不兼容类型 &#39;typeof Person&#39; 在这个例子中，typeof Person 会获取 Person 类的构造函数类型，即 typeof Person 实际上是 new (name: string) =&gt; Person，表示可以用来创建 Person 实例的构造函数类型。 示例：通过 typeof 引用类型构造函数 1let x: number = 42; 2let y: typeof x; // y 的类型是 number 3y = 123; // 正确 4// y = &#34;hello&#34;; // 错误: 类型 &#39;string&#39; 不能赋值给类型 &#39;number&#39; 这里，typeof x 取得了 x 的类型，x 是 number 类型，因此 y 的类型也是 number。 3. typeof 用于类型推断与类型保护 typeof 还可以用于类型保护，即在类型判断中帮助我们明确变量的类型。这对于某些复杂的类型检查很有用。
示例：typeof 在类型保护中的应用 1function printLength(value: string | string[]) { 2 if (typeof value === &#34;string&#34;) { 3 console.log(value.length); // value 是 string 类型 4 } else { 5 console.log(value.length); // value 是 string[] 类型 6 } 7} 8 9printLength(&#34;Hello&#34;); // 输出: 5 10printLength([&#34;a&#34;, &#34;b&#34;, &#34;c&#34;]); // 输出: 3 typeof value === &quot;string&quot; 用来判断 value 是否是 string 类型，帮助 TypeScript 确定在 if 语句块中的类型。 同理，可以使用 typeof 来判断其他基本类型，如 number、boolean 等。 4. typeof 用于联合类型和字面量类型的推断 typeof 也能用来推断字面量类型（literal types）。
示例：推断字面量类型 1const color = &#34;red&#34;; 2type Color = typeof color; // Color 的类型是 &#34;red&#34; 3 4let myColor: Color = &#34;red&#34;; // 正确 5// let anotherColor: Color = &#34;blue&#34;; // 错误: 类型 &#39;&#34;blue&#34;&#39; 不能赋值给类型 &#39;&#34;red&#34;&#39; 在这个例子中，typeof color 会推断出 color 变量的字面量类型 &quot;red&quot;，因此 Color 类型实际上是 &quot;red&quot;，而不是 string。 总结 typeof 获取值的类型：你可以用 typeof 获取一个变量或对象的类型，通常用于类型推断或动态类型赋值。 typeof 获取构造函数类型：当你使用 typeof 对类进行操作时，它会获取类的构造函数类型，可以用于引用类型的构造函数。 类型保护：typeof 在类型保护中可以帮助你根据值的类型做出判断。 字面量类型推断：typeof 可以用于推断变量的字面量类型，从而实现更精确的类型定义。 通过 typeof，你可以更灵活地在 TypeScript 中进行类型推断、类型保护和类型约束，增强代码的类型安全性和可维护性。
`,url:"https://hugo-dead-simple.netlify.com/typescript/typeof%E7%9A%84%E4%BD%BF%E7%94%A8/"},"https://hugo-dead-simple.netlify.com/typescript/typescript_program/":{title:"typescript_program",tags:[],content:` 本文由 简悦 SimpRead 转码， 原文地址 chengjingchao.com
第 1 章 导言使用 TypeScript 开发的程序更安全，常见的错误都能检查出来，写出的代码还可以作为文档。
发表于 2022-01-01 | 更新于: 2022-01-06
使用 TypeScript 开发的程序更安全，常见的错误都能检查出来，写出的代码还可以作为文档。
更安全是指类型安全
类型安全：借助类型避免程序做无效的事情（无效指的是运行时程序崩溃或未崩溃，但做的事情毫无意义
举个 🌰
数字乘以一个列表
接收数字的函数却传入了字符串
调用对象上不存在的方法
导入已经被移除的模块
13 + [] // &#34;3&#34; 2 3 4let obj = {} 5obj.foo // undefined 6 7 8function a(b) { 9 return b/2 10} 11a(&#39;z&#39;) // NaN 在做无效事情的时候，JavaScript 没有抛出异常，而是尽自己所能，避免抛出异常。
而 JavaScript 这种特性让代码中错误的产生与发现脱节了。导致 bug 往往是由他人转告给你的。 到真正运行时可能才会发现错误。
而 TypeScript 给出错误的时间点：在输入代码的过程中，代码编辑器会给出错误消息，来提醒你。
13 + [] // Error TS2365: Operator &#39;+&#39; cannot be applied to types &#39;3&#39; and &#39;never[]&#39;. 2 3 4let obj = {} 5obj.foo // Error TS2339: Property &#39;foo&#39; does not exist on type &#39;{}&#39; 6 7function (a: number) { 8 return b / 2 9} 10a(&#39;z&#39;) // Error TS2345: Argument of type &#39;&#34;z&#34;&#39; is not assignable to parameter of type &#39;number&#39;. 编译器 TypeScript 编译器（TSC）
通常运行程序的大致流程
把程序解析为 AST AST 编译成字节码 运行时计算字节码 运行程序就是让运行时计算由编译器从源码解析得来的 AST 生成的字节码。
TypeScript 的特殊之处在于，不直接编译成字节码，而是编译成 JavaScript。然后再像往常一样，在浏览器 / NodeJS 中运行。
TypeScript 编译器生成 AST 之后，真正运行代码之前会对代码做类型检查。
类型检查器：检查代码是否符合安全要求的特殊程序
编译和运行 TypeScript (1-3 由 TSC 操作，4-6 由浏览器 / NodeJS 操作)
TypeScript 源码 -&gt; TypeScript AST
类型检查器检查 AST
TypeScript AST -&gt; JavaScript 源码
JavaScript 源码 -&gt; JavaScript AST
AST -&gt; 字节码
运行时计算字节码
类型只在类型检查这一步使用，TSC 把 TS 编译成 JS 时，不会考虑类型。可以确保可以随意改动、更新和改进程序中的类型，而无需担心会破坏应用的功能。
类型系统 类型系统：类型检查器为程序分配类型时使用的一系列规则
一般来说，类型系统有两种，各有利弊
通过显式句法告诉编译器所有值的类型 自动推导值的类型 JavaScript 在运行时推导类型 TypeScript 身兼两种类型系统，可以显式注解类型，也可以自动推导多数类型。
显示声明类型需要使用注解。注解的形式 value: type，就像是告诉类型检查器，“嘿，看到这个 value 了吗？它的类型是 type。”
1// 显示注解 2let a: number = 1 3let b: string = &#39;hello&#39; 4let c: boolean[] = [true, false] 5 6// 自动推导 7let a = 1; 8let b = &#39;hello&#39; 9let c = [true, false] TypeScript VS JavaScript 类型系统特性JavaScriptTypeScript类型是如何绑定的？动态静态是否自动转换类型？是否（多数时候）何时检查类型？运行时编译时何时报告错误？运行时（多数时候）编译时（多数时候） TypeScript 能做的是把纯 JavaScript 代码中那些运行时愈发和类型相关的错误提前到编译时报告。在代码编辑器中显示，输入代码后立即就有反馈。
类型是如何绑定的？ JavaScript 动态绑定类型，必须运行程序才能知道类型。 TypeScript 渐进式类型语言，在编译时知道所有类型
类型：一系列值及对其执行的操作
example
类型包含的值可以执行的操作booleantrue、false||、&&、!number所有数字+、-、*、/、%、&&、? .toFixed()、.toString()string所有字符串+、||、&& .concat()、.toUpperCase() 对 T 类型的值来说，我们不仅知道值的类型是 T，还知道可以 / 不可以对该值做什么操作。 类型检查器通过使用的类型和具体用法判断是否有效。
TypeScript 的类型层次结构 类型术语 类型注解（可以理解为某种界限
1function squareOf(n: number) { 2 return n * n; 3} 4squareOf(2); // 4 类型浅谈 any 在 TypeScript 中，编译时一切都要有类型，如果你和 TypeScript（类型检查器）无法确认类型是什么，默认为 any。这是兜底类型，应该尽量避免使用。
类型的定义（一系列值及可以对其执行的操作）any 包含所有值，而且可以对其做什么操作。any 类型的值就像常规的 JavaScript 一样，类型检查器完全发挥不了作用。
使用 any 需要显示注解。
tsconfig.json noImplicitAny: true;
noImplicitAny 隶属于 TSC 的 strict 标志家族，
unknown unknown 与 any 类似，也表示任何值。但是 TypeScript 会要求你在做检查，细化类型。
类型包含的值可以执行的操作unknown==、===、||、&amp;&amp;、?、!、typeof、instance of 1// example 2let a: unknown = 30; // unknown 3let b = a === 123; // boolean 4let c = a + 10; // Error TS 2571: Object is of type &#39;unknown&#39; 5if (typeof a === &#39;number&#39;) { 6 let d = a + 10; // number 7} unknown 的用法
TypeScript 不会把任何值推导为 unknown 类型，必须显示注解（a） unknown 类型的值可以比较（b） 执行操作时不能假定 unknown 类型的值为某种特定类型（c），必须先向 TypeScript 证明一个值确实是某个类型（d） boolean 类型包含的值可以执行的操作booleantrue、false==、===、||、&amp;&amp;、? 1// example 2let a = true // boolean 3let b = false // boolean 4const c = true // true 5let d: boolean = true // boolean 6let e: true = true // true 7let f: true = false // Error TS2322: Type &#39;false&#39; is not assignable to type &#39;true&#39;. TypeScript 推导出值的类型为 boolean（a 和 b） 使用 const，让 TypeScript 推导出值为某个具体的布尔值（c） 显式注解，声明值的类型为 boolean（d） 显式注解，声明值为某个具体的布尔值（e 和 f）。把类型设定为某个值，就限制了 e 和 f 在所有布尔值中只能取指定的那个值。这种特性被称为类型字面量。 类型字面量——仅表示一个值的类型
变量 e f 是使用类型字面量显示注解了变量，变量 c 则是由 TypeScript 推导出一个字面量类型，因为使用的是 const。 const 声明的基本类型的值，赋值之后无法修改，因此 TypeScript 推导出的是范围最窄的类型，所以 TypeScript 推导出的 c 的类型为 true，而不是 boolean。
number 类型包含的值可以执行的操作number整数、浮点数、正数、负数、Infinity、NaN 等算术运算 比较 1// example 2let a = 1234 // number 3let b = Infinity * 0.1 // number 4const c = 5678 // 5678 5let d = a &lt; b // boolean 6let e: number = 100 // number 7let f: 26.218 = 26.218 // 26.218 8let g: 26.218 = 10 // Error TS2322: Type &#39;10&#39; is not assignable to type &#39;26.218&#39; TypeScript 推导出值的类型为 number（a 和 b） 使用 const，让 TypeScript 推导出值为某个具体的数字（c） 显式注解，声明值的类型为 number（e） 显式注解，声明值为某个具体的数字（f 和 g） tips：处理较长的数字时可以使用数字分隔符。
1let oneMillion = 1_000_ 000 // 等同于 1000000 2let twoMillion: 2_000_000 = 2_000_000 bigint 是 JavaScript 和 TypeScript 新引入的类型，在处理较大的整数时，不用再担心舍入误差。
number 类型表示的整数最大为 253，bigint 可以表示任意大的整数。
类型包含的值可以执行的操作bigint所有 BigInt 数算术运算 比较 1// example 2let a = 1234n // bigint 3const b = 5678n // 5678n 4let c = a + b // bigint 5let d = a &lt; 1235 // boolean 6let e = 88.5n // Error TS1353: A bigint literal must be an integer. 7let f: bigint = 100n // bigint 8let g: 100n = 100n // 100n 9let h: bigint = 100 // Error TS2322: Type &#39;100&#39; is not assignable ty type &#39;bigint&#39;. 与 boolean 和 number 一样，声明 bigint 类型也有四种方式。尽量让 TypeScript 自动推导。
string 类型包含的值可以执行的操作string所有字符串字符串可以进行的操作 例如 +、.slice() 1// example 2let a = &#39;hello&#39; // string 3let b = &#39;billy&#39; // string 4const c = &#39;!&#39; // ! 5let d = a + &#39; &#39; + b + c // string 6let e: string = &#39;zoom&#39; // string 7let f: &#39;john&#39; = &#39;john&#39; // john 8let g: &#39;john&#39; = &#39;zoe&#39; // Error TS2322: Type &#39;zoe&#39; is not assignable to type &#39;john&#39; 同样也是尽量让 TypeScript 自动推导 string 类型。
symbol symbol 经常用于代替对象和映射的字符串健，防止被意外设置。 symbol 的类型就是 symbol，每一个 symbol 都是唯一的，不与其他任何符号相等，即便再使用相同的名称创建一个 symbol 也是如此。
1// example 2let a = Symbol(&#39;a&#39;) // symbol 3let b: symbol = Symbol(&#39;b&#39;) // symbol 4let c = a === b // boolean 5let d = a + &#39;x&#39; // Error TS2469: The &#39;+&#39; operator cannot be applied to type &#39;symbol&#39;. 1// example 2const e = Symbol(&#39;e&#39;) // unique symbol 3const f: unique symbol = Symbol(&#39;f&#39;) // unique symbol 4let g: unique symbol = Symbol(&#39;f&#39;) // Error TS1332: A variable whose type is a &#39;unique symbol&#39; type must be &#39;const&#39;. 5let h = e === e // boolean 6let i = e === f // Error TS2367: This condition will always return &#39;false&#39; since the type &#39;unique symbol&#39; and &#39;unique symbol&#39; have no overlap. 创建 symbol 的方式
使用 const，TypeScript 会推导为 unique symbol 类型。 显式注解 const 变量的类型为 unique symbol unique symbol 类型的值始终与自身相等 TypeScript 在编译时知道一个 unique symbol 绝对不会与另一个 unique symbol 相等 unique symbol 与其他字面量类型其实是一样的。
对象 TypeScript 的对象类型表示对象的结构。
结构化类型–一种编程设计风格，只关心对象有哪些属性，而不管属性使用什么名称（名义化类型）。在某些语言中也叫鸭子类型（即不以貌取人）
1// example 2let b: object = { 3 b: &#39;x&#39; 4} 5a.b // Error TS2339: Property &#39;b&#39; does not exist on type &#39;object&#39;. object 只能表示该值是一个 JavaScript 对象（而且不是 null）
1// 对象字面量 2 3// 自动推导 4let a = { 5 b: &#39;x&#39; 6} 7 8// or 9let a: { b: string } = { 10 b: &#39;x&#39; 11} 对象字面量句法的意思是，“这个东西的结构是这样过的。”
使用 const 声明对象不会导致 TypeScript 把推导的类型缩窄。与上面的基本类型不同。这是因为 JavaScript 对象是可变的，所以在 TypeScript 看来，创建对象之后你可能会更新对象的字段。
1let a: { b: number } 2b = {} // Error TS2741: Property &#39;b&#39; is missing in type &#39;{}&#39; but required in type &#39;{b: number}&#39;. 3 4b = { 5 a: 1, 6 b: 2 7} // Error TS2322: Type &#39;{b: number; c: number}&#39; is not assignable to type &#39;{b: number}&#39;. Object literal may only specify known properties, and &#39;c&#39; does not exist in type &#39;{b: number}&#39;. 默认情况下，TypeScript 对对象的属性要求十分严格。如果声明对象有个类型为 number 的属性 b，TypeScript 将预期对象有且只有这个属性。缺少或者多了，TypeScript 都会报错。
1let a: { 2 b: number 3 c?: string // 可能有个类型为 string 的属性 c。其值可以为 undefined 4 readonly firstName: string // 为字段赋初始值后无法修改。类似于使用 const 声明对象的属性 5 [key: number]: boolean // 可能有任意多个数字属性，其值为布尔值 6} [key: T]: U 句法称为索引签名，通过这种方式告诉 TypeScript，指定的对象可能有更多的 key。这种句法的意思是，“在这个对象中，类型为 T 的健对应的值为 U 类型。”
索引签名 key 的类型 T 必须可赋值给 number 或 string。（JavaScript 对象的健为字符串；数组是特殊的对象，健为数字。） key 的名称可以是任意词，不一定非的用 key 对象字面量表示法有一个特例：空对象类型 {}。除 null 和 undefined 之外的任何类型都可以赋值给空对象类型，应该尽量避免使用。
在 TypeScript 中声明对象类型有四种方式
对象字面量表示法 {a: string}，也称对象结构 空对象字面量表示法 {}。避免使用 object 类型。如果需要个对象，当对这个对象的字段没有要求，使用这种方式。 Object。避免使用 对一个值，在类型允许的情况下，可以对其执行特定的操作。其实在类型自身上也可以执行一些操作。
类型别名
1type Age = number 2 3type Person = { 4 name: string 5 age: Age 6} 7 8let driver: Person = { 9 name: &#39;Jack&#39; 10 age: 18 11} 类型别名采用块级作用域。在同一作用于中不能重复声明相同类型。
并集和交集
1type Cat = { name: string, purrs: boolean } 2type Dog ={ name: string, barks: boolean, wags: boolean } 3 4type CatOrDogOrBoth = Cat | Dog // 并集 5type CatAndDog = Cat &amp; Dog // 交集 6 7// CatOrDogOrBoth 可以是 Cat 类型的值，可以是 Dog 类型的值，还可以二者兼具。 8// Cat 9let a: CatOrDogOrBoth = { 10 name: &#39;Bonkers&#39;, 11 purrs: true 12} 13 14// Dog 15a = { 16 name: &#39;Domino&#39;, 17 barks: true, 18 wags: true 19} 20 21// 二者兼具 22a = { 23 name: &#39;Donkers&#39;, 24 barsk: true, 25 purrs: true, 26 wags: true 27} 28 29// CatAndDot 30let b: CatAndDog = { 31 name: &#39;Domino&#39;, 32 barks: true, 33 purrs: true, 34 wags: true 35} 并集通常更常用
函数返回值可能是一个字符串，也可能是 null。string | null 混合类型的数组 数组
1let a = [1, 2, 3] // number[] 2let b = [&#39;a&#39;, &#39;b&#39;] // string[] 3let c: string[] = [&#39;a&#39;] // string[] 4let d = [1, &#39;a&#39;] // (number | string)[] 5const e = [2, &#39;b&#39;] // (number | string)[] 6let f = [&#39;red&#39;] // string[] 7 8f.push(&#39;blue&#39;) 9f.push(true) // Error TS2345: Argument of type &#39;true&#39; is not assignable to parameter of type &#39;string&#39;. 10 11let g = [] // any[] 12g.push(1) // number[] 13g.push(&#39;red&#39;) // (number | string)[] 14 15let h: number[] = [] // number[] 16h.push(1) // number[] 17h.push(&#39;red&#39;) // Error TS2345: Argument of type &#39;&#34;red&#34;&#39; is not assignable to parameter of type &#39;number&#39;. TypeScript 支持两种注解数组类型的句法
T[] Array 一般情况下，数组应该保持同质。
元祖
array 的子类型，长度固定，各索引位上的值具有固定的已知类型。
声明元组时必须显式注解类型。
1let a: [number] = 1 2let b: [string, string, number] = [&#39;jack&#39;, &#39;boy&#39;, 1963] 3b = [&#39;tom&#39;, &#39;boy&#39;, &#39;li&#39;, 1926] // Error TS2322: Type &#39;string&#39; is not assignable to type &#39;number&#39;. 元组也支持可选元素
1let trainFares: [number, number?][] = [ 2 [3.75], 3 [8.25, 7.70], 4 [10.60], 5] 6 7// 等价于 8let moreTrainFares: ([number, number] | [number])[] = [ 9 // ... 10] 元组也支持剩余元素，即为元组定义最小长度
1// 字符串列表，至少有一个元素 2let friends: [string, ...string[]] = [&#39;Sara&#39;, &#39;Tali&#39;, &#39;Chloe&#39;, &#39;Claire&#39;] 3 4// 元素类型不同的列表 5let list: [number, boolean, ...string[]] = [1, false, &#39;a&#39;, &#39;b&#39;, &#39;c&#39;] 只读数组和元祖
1let as: readonly number[] = [1, 2, 3] // readonly number[] 2let bs: readonly number[] = as.concat(4) // readonly number[] 3let three = bs[2] // number 4as[4] = 5 // Error TS2542: Index signature in type &#39;readonly number[]&#39; only permits reading. 5as.push(6) // Error TS2339: Property &#39;push&#39; does not exist on type &#39;readonly number[]&#39;. 6 7// Readonly 和 ReadonlyArray 句法 8type A = readonly string[] // readonly string[] 9type B = ReadonlyArray&lt;string&gt; // readonly string[] 10type C = Readonly&lt;string[]&gt; // readonly string[] 11 12type D = readonly [number, string] // readonly [number, string] 13type E = Readonly&lt;[number, string]&gt; // readonly [number, string] null、undefined、void 和 never | 类型 | 含义 | | — | — | | null | 缺少值 | | undefined | 尚未赋值的变量 | | void | 没有 return 语句的函数 | | never | 永不返回的函数 |
1// 返回 never 的函数 2function d() { 3 throw TypeError(&#39;I always error&#39;) 4} 5 6function e() { 7 while (true) { 8 doSomething() 9 } 10} never 是所有类型的子类型，可以赋值给其他任何类型。
枚举
枚举的作用是列举类型中包含的各个值。是一种无序数据结构，把键映射到值上。
枚举可以理解为编译时键固定的对象，访问键时，TypeScript 将检查指定的键是否存在。
枚举分为两种
字符串到字符串之间的映射 字符串到数字之间的映射 1enum Language { 2 English, 3 Spaish, 4 Russian 5} 按约定，枚举名称为大写单数形式。枚举中的键也大写。
TypeScript 可以自动为枚举中的各个成员推导对应的数字，也可以手动设置。
1enum Language { 2 English = 0, 3 Spanish = 1, 4 Russian = 2 5} 枚举中的值访问方式和对象一样
1let myFirstLanguage = Language.Russian 2let mySecondLanguage = Language[&#39;English&#39;] 一个枚举可以分成几次声明，TypeScript 将自动把各部分合并在一起
1enum Language { 2 English = 0, 3 Spanish = 1, 4} 5 6enum Language { 7 Russian = 2 8} meiju
小结 类型子类型booleanBoolean 字面量bigintBigInt 字面量numberNumber 字面量stringString 字面量symbolunique symbolobjectObject 字面量数组元组enumconst enum 声明和调用函数 在 JavaScript 中，函数是一等对象。这意味着，可以向对象那样使用函数
可以赋值给变量 可以作为参数传给其他函数 可以作为函数的返回值 可以赋值给对象和原型 可以赋予属性 可以读取属性 TypeScript 通常会显示注解函数的参数
1function add(a: number, b: number) { 2 return a + b 3} 返回类型能推导出来，不过也可以显示注解
1function add(a: number, b: number): number { 2 return a + b 3} TypeScript 中声明函数
1// 具名函数 2function greet(name: string) { 3 return &#39;hello &#39; + name 4} 5 6// 函数表达式 7let greet2 = function(name: string) { 8 retunr &#39;hello &#39; + name 9} 10 11// 箭头函数表达式 12let greet3 = (name: string) =&gt; { 13 return &#39;hello &#39; + name 14} 15 16// 箭头函数表达式简写 17let greet4 = (name: string) =&gt; &#39;hello &#39; + name 18 19// 函数构造方法 20let greet5 = new Function(&#39;name&#39;, &#39;return &#34;hello &#34; + name&#39;) 除了函数构造方法，其他几种句法在 TypeScript 中都可以放心使用，能够保证类型安全。通常需要注解参数的类型，而返回类型不要求必须注解。 在调用函数时，TypeScript 将检查传入的实参是否于函数形参类型兼容。
可选参数和默认参数 可选参数必须在末尾
1function log(message: string, userId?: string) { 2 let time = new Date().toLocaleTimeString() 3 console.log(time, message, userId || &#39;Not signed in&#39;) 4} 5 6log(&#39;Page loded&#39;) 7log(&#39;User signed in&#39;, &#39;da763be&#39;) 8 9// 默认值参数（类似可选参数功能 10function log(message: string, userId = &#39;Not signed in&#39;) { // userId 会自动推导类型 11 let time = new Date().toLocaleTimeString() 12 console.log(time, message, userId) 13} 14 15// 显式注解默认参数类型 16type Context = { 17 appId?: string 18 userId?: string 19} 20 21function log(message: string, context: Context = {}) { 22 let time = new Date().toLocaleTimeString() 23 console.log(time, message, context.userId) 24} 默认参数更常用，默认参数可以自动类型推导。
多态 上面都是讲的具体类型的用法和用途
boolean string Date[] {a: number} | {b: string} (numbers: number[]) =&gt; number 使用具体类型的前提是类型已知
如果事先不知道需要什么类型 不想限制函数只能接受某个类型
1// example 2function filter(array, f) { 3 let result = [] 4 for (let i = 0; i &lt; array.length; i++) { 5 let item = array[i] 6 if (f(item)) { 7 result.push(item) 8 } 9 } 10 return result 11} 12 13filtre([1, 2, 3, 4], (item) =&gt; item &lt; 3) // [1, 2] 例子中，数组元素的类型可以为 number，不过 filter 函数的作用应该更一般，可以筛选数字数组、字符串数字、对象数组等。 下面通过重载描述下函数签名
1type Filter = { 2 (array: number[], f: (item: number) =&gt; boolean): number[] 3 (array: string[], f: (item: string) =&gt; boolean): string[] 4} 5 6// 加上对象类型 7type Filter = { 8 (array: number[], f: (item: number) =&gt; boolean): number[] 9 (array: object[], f: (item: object) =&gt; boolean): object[] 10} object 无法描述对象的结构，访问数组中元素属性就会报错。 为了解决这种问题，就有了泛形参数
泛型参数——在类型层面施加约束的占位类型，也称多态类型参数，简称泛形
1// example 2type Filter = { 3 &lt;T&gt;(array: T[], f: (item: T): boolean): T[] 4} 这么做的意思是 Filter 使用了一个泛形参数 T，事先不知道具体类型是什么，调用的时候根据传入的参数推导 T 的类型。
知识点
泛形使用尖括号声明，可以把尖括号理解为 type 关键字，只不过声明的是泛形。 尖括号位置限制泛形作用域尖括号中可以声明任意多个以逗号分隔 T 就是一个类型名称（类似变量名称），可以使用任意名称，通常会使用 T U V W 泛形可以理解为一种约束，把泛形 T 所在位置的类型约束为 T 类型 什么时候绑定泛型 声明泛形的位置不仅限定泛形作用域，还决定什么时候为泛形绑定具体的值
1// 1 在调用签名中声明 2type Filter = { 3 &lt;T&gt;(array: T[], f: (item: T): boolean): T[] 4} 5// 调用函数时为 T 绑定具体类型 6let filter: Filter = (array, f) =&gt; { 7 // ... 8} 9 10 11// 2 在类型别名 Filter 中 12type Filter&lt;T&gt; = { 13 (array: T[], f: (item: T): boolean): T[] 14} 15// 使用 Filter 时显式绑定具体类型 16let filter: Filter&lt;number&gt; = (array, f) =&gt; { 17 // ... 18} 可以在什么地方声明泛形 1// 1 2type Filter = { 3 &lt;T&gt;(array: T[], f: (item: T): boolean): T[] 4} 5 6// 2 7type Filter&lt;T&gt; = { 8 (array: T[], f: (item: T): boolean): T[] 9} 10 11// 3 1 的简写 12type Filter = &lt;T&gt;(array: T[], f: (item: T): boolean): T[] 13 14// 4 2 的简写 15type Filter&lt;T&gt;( = array: T[], f: (item: T): boolean): T[] 16 17// 5 具名函数调用签名，每次调用 filter 时绑定举腿类型 18function filter&lt;T&gt;(array: T[], f: (item: T) =&gt; boolean): T[] { 19 // ... 20} 泛形别名 泛形约束 `,url:"https://hugo-dead-simple.netlify.com/typescript/typescript_program/"},"https://hugo-dead-simple.netlify.com/tags/web%E5%BC%80%E5%8F%91/":{title:"Web开发",tags:[],content:"",url:"https://hugo-dead-simple.netlify.com/tags/web%E5%BC%80%E5%8F%91/"},"https://hugo-dead-simple.netlify.com/frontend/switch_light_drak_theme/":{title:"完美实现 Hugo 博客暗黑模式切换：从原理到实践",tags:["Hugo","Web开发","JavaScript","CSS"],content:`在当今的用户体验设计中，提供暗黑模式（Dark Mode）几乎已成为标配。它不仅能减少眼部疲劳，在低光环境下也更加舒适。本文将详细记录如何为一个 Hugo 网站（实际上适用于任何静态网站）添加一个功能完善、体验流畅的主题切换器。
我们将解决一个常见痛点：页面刷新时的“闪烁”问题，并最终实现一个堪称完美的解决方案。
最终效果 一个位于导航栏的按钮，用于在浅色（Light）和深色（Dark）主题间切换。 用户的选择会被浏览器记住，下次访问时自动应用。 如果用户首次访问，则会根据其操作系统的偏好自动选择主题。 最重要的：页面在加载和刷新时绝不会出现恼人的颜色闪烁。 核心实现原理 我们的主题切换功能主要依赖两大现代 Web 技术的结合：
CSS 自定义属性 (CSS Variables) 通过 JavaScript 操作 HTML 标签的 data-* 属性 基本思路是：我们在 CSS 中定义两套颜色变量，一套用于浅色主题，另一套用于深色主题。然后，通过 JavaScript 动态地在 &lt;html&gt; 根元素上切换一个 data-theme 属性（例如，data-theme=&quot;light&quot; 或 data-theme=&quot;dark&quot;）。CSS 会根据这个属性的值，自动应用对应的颜色变量集，从而实现整个网站的颜色切换。
1/* 基础/浅色主题变量 */ 2:root { 3 --background: #ffffff; 4 --text: #000000; 5 --link: #3366cc; 6 /* ... 其他颜色变量 */ 7} 8 9/* 深色主题变量 */ 10[data-theme=&#39;dark&#39;] { 11 --background: #1b1b1b; 12 --text: #d8d8d8; 13 --link: #88a9e9; 14 /* ... 其他颜色变量 */ 15} 16 17/* 在组件中使用变量 */ 18body { 19 background-color: var(--background); 20 color: var(--text); 21} 22 23a { 24 color: var(--link); 25} 这种方法的优势在于，我们无需加载不同的 CSS 文件，只需改变一个属性，就能高效地重绘整个页面的颜色，非常灵活且性能优秀。
恼人的“闪烁”问题及解决方案 很多主题切换方案都存在一个通病：当用户选择深色模式并刷新页面时，页面会先以默认的浅色模式短暂显示，然后“闪烁”一下再变成深色。
闪烁原因：这是因为负责切换主题的 JavaScript 脚本通常放在 &lt;body&gt; 底部加载。浏览器会先按照 CSS 的默认设置（通常是浅色主题）渲染页面，等 JS 加载并执行后，才把主题切换过来，这个过程就造成了闪烁。
解决方案：答案是在浏览器渲染 &lt;body&gt; 之前就确定好主题。我们将一小段关键的 JavaScript 代码作为内联脚本直接放在 &lt;head&gt; 标签中。
这段脚本的任务非常纯粹：
检查 localStorage 中是否有用户之前保存的主题偏好。 如果没有，则检查用户的操作系统是否偏好深色模式。 根据结果，立即在 &lt;html&gt; 标签上设置 data-theme 属性。 因为这段脚本在 &lt;head&gt; 中，它会比页面的任何可见元素（&lt;body&gt; 内的内容）都先执行，从而确保了浏览器在“第一帧”渲染时就使用了正确的主题，彻底消除了闪烁。
分步实现指南 第 1 步：在 header.html 中添加核心脚本和切换按钮 首先，我们需要将实现无闪烁切换的核心脚本和按钮添加到主题的 header.html 中。
1// filepath: layouts/partials/header.html 2 3&lt;head&gt; 4 {{/* ... 其他 head 内容 ... */}} 5 6 {{/* 核心：防止闪烁的内联脚本 */}} 7 &lt;script&gt; 8 // 在页面加载或切换主题时，此脚本应内联在 &lt;head&gt; 中以避免 FOUC (Flash of Unstyled Content) 9 (function() { 10 const theme = localStorage.getItem(&#39;theme&#39;) || (window.matchMedia(&#39;(prefers-color-scheme: dark)&#39;).matches ? &#39;dark&#39; : &#39;light&#39;); 11 document.documentElement.setAttribute(&#39;data-theme&#39;, theme); 12 })(); 13 &lt;/script&gt; 14 15 {{/* ... 其他 head 内容，如 CSS 链接等 ... */}} 16&lt;/head&gt; 17 18&lt;body&gt; 19 &lt;nav&gt; 20 &lt;ul class=&#34;menu&#34;&gt; 21 {{/* ... 其他菜单项 ... */}} 22 &lt;li&gt;&lt;a href=&#34;/posts&#34;&gt;文章&lt;/a&gt;&lt;/li&gt; 23 {{/* 主题切换按钮 */}} 24 &lt;li&gt;&lt;button id=&#34;theme-switcher&#34; class=&#34;menu-link&#34; type=&#34;button&#34;&gt;🌗&lt;/button&gt;&lt;/li&gt; 25 &lt;/ul&gt; 26 &lt;/nav&gt; 27 {{/* ... */}} 第 2 步：创建处理按钮交互的 JavaScript 接下来，我们创建一个单独的 JS 文件来处理按钮的点击事件。这个脚本可以放在 &lt;body&gt; 底部加载，因为它不负责初始主题的设定，只负责响应用户操作。
1// filepath: static/js/theme-switcher.js 2 3(function() { 4 const themeSwitcher = document.getElementById(&#39;theme-switcher&#39;); 5 if (!themeSwitcher) { 6 return; 7 } 8 9 // 页面加载时，根据当前主题设置按钮图标 10 let currentTheme = document.documentElement.getAttribute(&#39;data-theme&#39;); 11 themeSwitcher.textContent = currentTheme === &#39;dark&#39; ? &#39;☀️&#39; : &#39;🌗&#39;; 12 13 // 监听按钮点击事件 14 themeSwitcher.addEventListener(&#39;click&#39;, () =&gt; { 15 // 切换主题 16 currentTheme = document.documentElement.getAttribute(&#39;data-theme&#39;) === &#39;dark&#39; ? &#39;light&#39; : &#39;dark&#39;; 17 document.documentElement.setAttribute(&#39;data-theme&#39;, currentTheme); 18 19 // 将用户的选择存入 localStorage 20 localStorage.setItem(&#39;theme&#39;, currentTheme); 21 22 // 更新按钮图标 23 themeSwitcher.textContent = currentTheme === &#39;dark&#39; ? &#39;☀️&#39; : &#39;🌗&#39;; 24 }); 25})(); 别忘了在 footer_scripts.html 或类似的地方引入这个脚本： &lt;script src=&quot;{{ &quot;js/theme-switcher.js&quot; | relURL }}&quot;&gt;&lt;/script&gt;
第 3 步：配置 CSS 颜色变量 最后，也是最关键的一步，是配置好我们的 CSS 文件，让它能够响应 data-theme 属性的变化。
1/* filepath: assets/css/main.css */ 2 3/* 默认/浅色主题变量 */ 4:root { 5 --background: #ffffff; 6 --text: black; 7 --link: #3366cc; 8 --card-background: #f9f9f9; 9 /* ... 更多颜色 */ 10} 11 12/* 当 data-theme=&#39;light&#39; 时应用的变量（可选，用于明确指定） */ 13[data-theme=&#39;light&#39;] { 14 --background: #ffffff; 15 --text: black; 16 --link: #3366cc; 17 --card-background: #f9f9f9; 18 /* ... */ 19} 20 21/* 当 data-theme=&#39;dark&#39; 时应用的变量 */ 22[data-theme=&#39;dark&#39;] { 23 --background: #1b1b1b; 24 --text: #d8d8d8; 25 --link: #88a9e9; 26 --card-background: #272727; 27 /* ... 更多颜色 */ 28} 29 30/* ... 之后的 CSS 规则全部使用 var() 来引用颜色 ... */ 31body { 32 background-color: var(--background); 33 color: var(--text); 34} 35 36.subcategory-card { 37 background-color: var(--card-background); 38} 总结 通过将主题决策逻辑前置到 &lt;head&gt; 并结合 CSS 变量，我们构建了一个健壮、高效且用户体验极佳的主题切换系统。这个方案不仅解决了恼人的“闪烁”问题，其模块化的结构也使得未来的样式维护和扩展变得异常简单。希望这篇文章能对你有所帮助！
data-theme 自定义属性原理 1:root { 2 --complimentary: #815205; 3 --text: black; 4 --code: black; 5 --accent-color: #00aaff; 6 --accent-color-light: rgba(0, 170, 255, 0.1); 7 --card-background: #cccccc5f; 8 --card-background-hover: #6e6b6bff; 9 --card-text-color: #100101ff; 10 --shadow-color: rgba(0, 0, 0, 0.1); 11 --text-dim: #444; 12 --link: #3366cc; 13 --link-visited: #795cb2; 14 --code-background: #f3f5f7; 15 --code-border: #eaecf0; 16 --code-border: transparent; 17 --code-hl: #e6e6e6; 18 --border-general: #cccfd4; 19 --table-th: #e1e5ea; 20 --table-tr: #edeff2; 21 --toc-background: #f9f9f9; 22 --toc-border: #aaa; 23 --output-background: #d5dbe3; 24 --output-foreground: #805105; 25} 26 27[data-theme=&#39;light&#39;] { 28 --background: #ffffff; 29} 30 31[data-theme=&#39;dark&#39;] { 32 --background: #1b1b1b; 33 --text: #d8d8d8; 34 --code: #cbcbcb; 35 --accent-color: #00aaff; 36 --accent-color-light: rgba(0, 170, 255, 0.2); 37 --card-background: #272727; 38 --card-background-hover: #444; 39 --card-text-color: #d8d8d8; 40 --shadow-color: rgba(0, 0, 0, 0.3); 41 --text-dim: #a7a7a7; 42 --link: #88a9e9; 43 --link-visited: #a390ca; 44 --code-background: #272727; 45 --code-border: transparent; 46 --code-hl: #5a5a5a; 47 --border-general: #495057; 48 --table-th: #414141; 49 --table-tr: #343434; 50 --toc-background: #343434; 51 --toc-border: #495057; 52 --output-background: #020202; 53} 向我解释上面的代码,并向我解释 data-theme的原理
当然，我很乐意为你解释这段代码以及 data-theme 的工作原理。
简单来说，这段 CSS 代码使用 CSS 变量（也叫自定义属性）和 data- 属性来创建一套灵活的主题系统，可以轻松地在浅色模式 (light mode) 和深色模式 (dark mode) 之间切换。
代码解析 这段代码主要分为三个部分：
1. :root — 全局默认变量 1:root { 2 --complimentary: #815205; 3 --text: black; 4 /* ... 其他变量 ... */ 5} :root 选择器：这个选择器指向文档的根元素，在 HTML 中就是 &lt;html&gt; 标签。在这里定义的变量是全局的，可以在整个页面的任何地方使用。 CSS 变量 (Custom Properties)：以 -- 开头的都是 CSS 变量。你可以把它们看作是值的“占位符”。例如，--text: black; 定义了一个名为 text 的变量，它的值是黑色。 作用：这个部分定义了网站的默认主题，或者说是“基础”颜色。当没有指定特定主题时，网站就会使用这些颜色。 2. [data-theme='light'] — 浅色主题 1[data-theme=&#39;light&#39;] { 2 --background: #ffffff; 3} [data-theme='light']：这是一个属性选择器。它的意思是：“选择任何带有 data-theme 属性并且该属性的值为 light 的元素”。 作用：当 &lt;html&gt; 或 &lt;body&gt; 标签被设置为 &lt;html data-theme=&quot;light&quot;&gt; 时，这个规则就会生效。它定义了浅色主题下的特定变量。在这里，它只定义了 --background 为白色 (#ffffff)。其他没有被重新定义的变量（如 --text）会继续使用 :root 中的默认值。 3. [data-theme='dark'] — 深色主题 1[data-theme=&#39;dark&#39;] { 2 --background: #1b1b1b; 3 --text: #d8d8d8; 4 /* ... 其他变量 ... */ 5} [data-theme='dark']：与上面类似，这个属性选择器会匹配 &lt;html data-theme=&quot;dark&quot;&gt; 这样的元素。 作用：当网站切换到深色模式时，这个规则会生效。它会覆盖 :root 中定义的许多变量，将它们替换为适合在深色背景下显示的颜色值（例如，背景变为深灰色，文字变为浅灰色）。 data-theme 的工作原理 data-theme 是一个自定义数据属性 (Custom Data Attribute)。这是 HTML5 的一个很棒的功能，允许你将自定义的数据存储在 HTML 元素上，而不会影响其样式和行为。
它的工作原理就像一个状态开关 🚦，具体步骤如下：
定义样式：就像你上面提供的 CSS 代码一样，我们为不同的 data-theme 值（如 light 和 dark）定义不同的 CSS 变量。
设置初始状态：在 HTML 的根元素（通常是 &lt;html&gt;）上设置一个初始主题。
1&lt;html data-theme=&#34;light&#34;&gt; 2 &lt;/html&gt; 当页面加载时，浏览器看到 data-theme=&quot;light&quot;，于是 [data-theme='light'] 的 CSS 规则被应用，页面显示为浅色主题。
使用变量：在你的其他 CSS 文件中，你不会直接使用颜色代码，而是使用 var() 函数来调用这些变量。
1body { 2 background-color: var(--background); /* 使用 --background 变量 */ 3 color: var(--text); /* 使用 --text 变量 */ 4} 5 6a { 7 color: var(--link); /* 使用 --link 变量 */ 8} 这样做的好处是，你只需要改变变量的值，所有使用该变量的元素的样式都会自动更新。
用 JavaScript 切换主题：当用户点击一个“切换主题”按钮时，你会用 JavaScript 来改变 &lt;html&gt; 标签上 data-theme 属性的值。
1// 获取 &lt;html&gt; 元素 2const htmlElement = document.documentElement; 3 4// 假设当前是 &#39;light&#39;，我们要切换到 &#39;dark&#39; 5htmlElement.setAttribute(&#39;data-theme&#39;, &#39;dark&#39;); 切换瞬间发生了什么？
当 JavaScript 将 data-theme 的值从 'light' 改为 'dark' 时，浏览器会立即重新计算样式：
之前匹配的 CSS 规则 [data-theme='light'] 不再生效。 新的 CSS 规则 [data-theme='dark'] 开始生效。 所有 CSS 变量（--background, --text 等）的值被立刻更新为深色主题的值。 所有使用了 var() 函数的元素（比如 body）的样式都会自动重新渲染，页面瞬间就从浅色模式变成了深色模式，无需刷新页面。 总结 总而言之，这种方法通过 CSS 变量将设计系统的颜色集中管理，然后利用 data-theme 属性作为开关，最后通过 JavaScript 来“拨动”这个开关，从而实现了一种非常现代化、高效且易于维护的网站主题切换方案。
`,url:"https://hugo-dead-simple.netlify.com/frontend/switch_light_drak_theme/"},"https://hugo-dead-simple.netlify.com/typescript/%E5%AF%B9%E8%B1%A1%E5%AD%97%E9%9D%A2%E9%87%8F/":{title:"对象字面量",tags:[],content:`在 TypeScript 中，对象字面量（Object Literal）是通过花括号 {} 来创建一个对象，并可以直接为其添加属性和值。这与 JavaScript 中的对象字面量使用方式类似，但 TypeScript 为对象字面量提供了类型系统，可以通过类型注解来限制对象的结构。
1. 基本的对象字面量 对象字面量用于创建一个新的对象，可以直接指定其属性和值：
1const person = { 2 name: &#34;Alice&#34;, 3 age: 30 4}; 这里 person 是一个对象字面量，包含了两个属性：name 和 age。
2. 使用类型注解指定对象字面量的类型 TypeScript 允许你为对象字面量指定类型，从而限制对象的属性和类型。这使得代码更加安全，能够防止错误的属性赋值。
示例：使用 type 或 interface 定义对象类型 1interface Person { 2 name: string; 3 age: number; 4} 5 6const person: Person = { 7 name: &#34;Alice&#34;, 8 age: 30 9}; 在这个例子中，Person 是一个接口（interface），它定义了 name 和 age 属性的类型。然后我们通过类型注解 const person: Person 来确保 person 对象符合这个类型。
你也可以使用 type 来定义类型：
1type Person = { 2 name: string; 3 age: number; 4}; 5 6const person: Person = { 7 name: &#34;Alice&#34;, 8 age: 30 9}; 3. 在对象字面量中使用可选属性 在对象字面量中，你可以定义可选属性，通过在属性名后添加 ? 来实现。
1interface Person { 2 name: string; 3 age: number; 4 address?: string; // 可选属性 5} 6 7const person: Person = { 8 name: &#34;Alice&#34;, 9 age: 30 10 // address 是可选的，可以不提供 11}; 在这个例子中，address 属性是可选的，因此你可以在创建 person 对象时不提供该属性。
4. 只读属性 TypeScript 还允许你为对象字面量定义只读属性，这意味着这些属性的值在初始化后不能被修改。可以使用 readonly 修饰符来实现。
1interface Person { 2 readonly name: string; 3 readonly age: number; 4} 5 6const person: Person = { 7 name: &#34;Alice&#34;, 8 age: 30 9}; 10 11// person.name = &#34;Bob&#34;; // 这是不允许的，会报错 在这个例子中，name 和 age 是只读的，因此你不能修改它们的值。
5. 对象字面量与函数类型 你还可以将方法作为对象字面量的一部分来使用。函数类型可以在对象字面量中直接定义。
1interface Person { 2 name: string; 3 greet: () =&gt; void; // greet 是一个函数 4} 5 6const person: Person = { 7 name: &#34;Alice&#34;, 8 greet: () =&gt; { 9 console.log(\`Hello, my name is \${person.name}\`); 10 } 11}; 12 13person.greet(); // 输出：Hello, my name is Alice 6. 使用索引签名 索引签名允许对象字面量具有任意数量的属性，并且这些属性的类型是预定义的。通过 index signature，你可以指定对象可以有任意数量的键，并限制键值的类型。
1interface Dictionary { 2 [key: string]: number; // 键是 string 类型，值是 number 类型 3} 4 5const myDictionary: Dictionary = { 6 apple: 10, 7 banana: 20 8}; 9 10console.log(myDictionary.apple); // 输出：10 在这个例子中，Dictionary 接口定义了一个索引签名，允许任何字符串键，且这些键对应的值都必须是 number 类型。
7. 使用类型推断 TypeScript 会自动推断字面量对象的类型。如果你没有显式地为对象指定类型，TypeScript 会根据对象的结构自动推断类型。
1const person = { 2 name: &#34;Alice&#34;, 3 age: 30 4}; // TypeScript 推断 person 的类型为 { name: string; age: number; } 5 6person.name = &#34;Bob&#34;; // 允许修改 7// person.name = 100; // 错误，因为 name 应该是 string 类型 8. 禁止额外的属性 有时，你希望对象字面量只能包含某些特定的属性，禁止添加任何额外的属性。可以使用 exact 类型来实现这一点（通过 as const 来确保字面量类型的精确性）。
1const person = { 2 name: &#34;Alice&#34;, 3 age: 30 4} as const; // 使用 &#39;as const&#39; 来确保属性是只读的并且精确匹配 5 6// person.name = &#34;Bob&#34;; // 错误，因为 &#39;name&#39; 是只读的，不能修改 7// person.address = &#34;NY&#34;; // 错误，因为 \`address\` 属性并不在对象字面量中 总结 对象字面量 是通过 {} 创建的普通 JavaScript 对象，在 TypeScript 中可以通过类型注解来指定其结构。 你可以使用 interface 或 type 来定义对象的结构，确保对象符合某种预期的形状。 TypeScript 还支持可选属性、只读属性、索引签名、方法等功能。 TypeScript 会自动推断对象字面量的类型，如果你不提供类型注解。 通过这些方式，你可以在 TypeScript 中创建灵活、类型安全的对象字面量。
`,url:"https://hugo-dead-simple.netlify.com/typescript/%E5%AF%B9%E8%B1%A1%E5%AD%97%E9%9D%A2%E9%87%8F/"},"https://hugo-dead-simple.netlify.com/typescript/%E7%90%86%E8%A7%A3%E7%B1%BB%E5%A3%B0%E6%98%8E%E5%80%BC%E4%B8%8E%E7%B1%BB%E5%9E%8B/":{title:"理解类声明值与类型",tags:[],content:`这段代码涉及到了 TypeScript 中类的构造函数、实例对象、类型等概念。让我们逐步解析每个部分，特别是 console.log(C.a) 报错的原因。
代码解析 1class C { 2 a = &#34;123&#34;; // 类实例属性 3} 4 5let c: C = new C(); // 创建 C 类的一个实例 6 7console.log(c); // 输出: C { a: &#39;123&#39; } 8console.log(C); // 输出: [Function: C]，C 是构造函数 9// console.log(C.a); // 报错：Property &#39;a&#39; does not exist on type &#39;C&#39;. 10console.log(c.a); // 输出: 123 11console.log(c instanceof C); // 输出: true 1. console.log(C) 输出的是构造函数 1console.log(C); // 输出: [Function: C] C 是一个类，类的本质在 JavaScript 中是一个构造函数。C 本身是一个函数，用来创建 C 类的实例。 当你打印 C 时，输出的是类的构造函数。换句话说，C 是一个 构造函数，而不是一个对象实例或类的 实例类型。 2. console.log(C.a) 报错的原因 1// console.log(C.a); // 报错：Property &#39;a&#39; does not exist on type &#39;C&#39;. 在类定义 class C { a = &quot;123&quot;; } 中，a 是一个 实例属性，而不是 类属性。 也就是说，a 属于类的实例（例如通过 new C() 创建的 c 实例），并且在构造函数中初始化。 因此，C 作为构造函数并不直接包含 a 属性，a 只能通过类的 实例对象 访问。 console.log(C.a) 会导致报错，因为 a 并不是 C 这个类本身的属性，而是实例的属性。 3. console.log(c.a) 正常输出 123 1console.log(c.a); // 输出: 123 c 是 C 类的一个实例对象，c.a 是访问 C 类实例上的属性 a。 由于 a 是实例属性，所以你可以通过 c.a 正常访问到值 &quot;123&quot;。 4. console.log(c instanceof C) 输出 true 1console.log(c instanceof C); // 输出: true instanceof 运算符用于检查对象是否是某个类的实例。 c instanceof C 返回 true，说明 c 确实是 C 类的实例。instanceof 会检查 c 是否是通过 C 构造函数创建的对象，或者是否位于 C 的原型链上。 总结 C 是构造函数：类 C 在 TypeScript 和 JavaScript 中本质上是一个构造函数。通过 new C() 创建的对象才是 C 类的实例。 实例属性 vs. 类属性：a 是类的实例属性，因此只能通过类的实例来访问；而 C 是类本身的构造函数，不包含实例属性 a。 instanceof 运算符：c instanceof C 检查对象 c 是否是 C 类的实例，返回 true 表示 c 是通过 C 构造函数创建的。 所以，错误的根源是将 C 类本身误认为是实例对象，试图直接访问 a。而实际 a 是 C 类实例的属性，必须通过实例对象（如 c.a）来访问。
`,url:"https://hugo-dead-simple.netlify.com/typescript/%E7%90%86%E8%A7%A3%E7%B1%BB%E5%A3%B0%E6%98%8E%E5%80%BC%E4%B8%8E%E7%B1%BB%E5%9E%8B/"},"https://hugo-dead-simple.netlify.com/typescript/src/decorator/":{title:"装饰器",tags:[],content:`装饰器（Decorator）是一种语法结构，用来在定义时修改类（class）的行为。
我的结构
装饰器是一个函数,本质是对类进行修改(Decorator),然后得到一个新的类,使这个类,有新的功能.
index
要使用这个代码,需要配置tsconfig.json
1&#34;experimentalDecorators&#34;: true, /* Enable experimental support for legacy experimental decorators. */ `,url:"https://hugo-dead-simple.netlify.com/typescript/src/decorator/"},"https://hugo-dead-simple.netlify.com/":{title:"首页",tags:[],content:` 这里是rainboy写的文章,所在的GitHub仓库
`,url:"https://hugo-dead-simple.netlify.com/"},"https://hugo-dead-simple.netlify.com/blog/":{title:"Blogs",tags:[],content:"",url:"https://hugo-dead-simple.netlify.com/blog/"},"https://hugo-dead-simple.netlify.com/blog/newnew/":{title:"Newnew",tags:[],content:`test git action webhook
`,url:"https://hugo-dead-simple.netlify.com/blog/newnew/"},"https://hugo-dead-simple.netlify.com/blog/hugo%E8%87%AA%E5%8A%A8%E5%8F%91%E5%B8%83/":{title:"Hugo自动发布",tags:[],content:`自动deploy blog 到github 参考
https://letere-gzj.github.io/hugo-stack/p/hugo/custom-blog/#3-github%E9%83%A8%E7%BD%B2 对应的视频教程: https://www.bilibili.com/video/BV1bovfeaEtQ 另一个 可以 发布blog到vps服务器 下面是新另外一个blog
本文由 简悦 SimpRead 转码， 原文地址 blog.wjhwjhn.com
背景 我一直计划迁移我的博客，一方面是认为之前主题的代码展示能力不强，文章的信息密度低，不适宜于技术内容的展示；另一方面，我曾认为极为安全的 Typecho，在 2023 年 6 月爆出了 XSS 漏洞，这加剧了我迁移的紧迫性。
注意
本文最后更新于 2024-02-13，文中内容可能已过时。
背景 我一直计划迁移我的博客，一方面是认为之前主题的代码展示能力不强，文章的信息密度低，不适宜于技术内容的展示；另一方面，我曾认为极为安全的 Typecho，在 2023 年 6 月爆出了 XSS 漏洞，这加剧了我迁移的紧迫性。鉴于此，我早就转向一款既美观又实用的静态博客平台——我选择了 Hugo，并选用了 FixIt 主题。恰逢过年，我拥有了许多碎片化的时间，这成为了我迁移博客的绝佳时机。
问题和解决方案 在迁移博客的过程中，我遇到了一系列问题。为了帮助同样面对这些挑战的读者，我在下面详细记录了我所面临的问题以及我采取的解决措施，希望这些经验能为您提供实际的帮助和指引。
警告
在迁移之前，请务必备份原有博客的文件和数据库数据，以防意外发生。
文章迁移 文章内容：文章内容储存在 typecho_contents 表的 text 字段中，提取比较容易，只需要去除 &lt;!--markdown--&gt; 标记即可，原先编写文章时就使用的是 markdown，所以直接创建文件即可，不过在这个过程中也遇到了不少问题 在我刚建立这个博客时，因为对 markdown 语法的不熟悉，导致以前的很多文章使用了 markdown 的方言。这些文章，在 Typecho 中显示正常，但是在 Hugo 中就出现了排版错误，好在有问题的文章不是很多，这里手动编辑了一下； 在 Hugo 中，文章的元信息（文章创建时间、文章类别、文章标题等…）都内嵌文章开头的 yaml 元信息中，这些信息需要从 Typecho 的数据库中提取并生成，例如 typecho_contents 表的 created 、modified 、title 字段； 原先的 Typecho 的 typecho_contents 表的 status 字段，如果是非 public 的文章，则设置 hiddenFromHomePage: true、hiddenFromSearch: true、hiddenFromRss: true、hiddenFromRelated: true 以及 password: {password} 密码字段，由主题进行加密处理。 原博客链接跳转 问题：原博客的链接是使用 /archives/{cid}/ 这种形式的，而新博客的链接是使用 /posts/{name} 这种形式的； 解决方案：利用文章元信息中的 aliases 字段来生成一个额外的别名链接。 评论和阅读量迁移 使用了 Twikoo 的评论系统，并解决了链接转换问题
Twikoo 的评论系统运行在 docker 设备中，并且映射到 8099 端口。为了安全性，我使用 ufw 将此端口设置为 deny，但发现无效，在 xianyu 的帮助下 (Orz)，使用了 ufw-docker，并成功解决； 因为 Twikoo 原生只支持使用 http，而我的博客使用的是 https，导致 twikoo 被 block。这里使用了反向代理来解决，设置了 https://blog.wjhwjhn.com/twikoo 代理到 http://localhost:8099 ； 阅读量是我在数据库中新增的 viewsNum 字段，我进行了导出生成，并转化为 Twikoo 的数据格式； 在评论和阅读量中需要提供文章的地址和标题，而在数据库中的都是先前的地址和标题。这里编写了 Python 脚本，逻辑如下 在新版博客中，去访问原来的路径下访问 html 文件（通过 aliases 字段生成的跳转文件），并使用正则（meta http-equiv=&quot;refresh&quot; content=&quot;0; url=http://[^/]+(/[^&quot;]+)&quot;）取出更新后的地址。 前往新版博客的地址下使用正则（&lt;title&gt;([^&lt;]+)&lt;/title&gt;）取出标题。 图片链接修复 让 ChatGPT 编写正则，提取出图片链接，从原来的图片链接中下载到本地，并替换原有链接
发现以前有部分旧文章的图片使用的是 http，导致图片无法访问，编写了 SQL 语句进行了替换 UPDATE typecho_contents SET text = REPLACE(text, 'http://blog.wjhwjhn', 'https://blog.wjhwjhn');。 发现以前有部分图片无法访问到：之前有过一段时间的博客文章编写是在石墨上的，而石墨的导出 markdown 功能也经过两次的转变 我最早接触的时候，石墨的导出功能是可以直接导出文章内的图片的，并且使用了石墨的图片储存服务链接； 估计后来石墨发现盗链的人过多，于是对访问来源做了检测，导致了我当时有大量的博客图片无法访问。我编写了一个插件，在导入时对文章内外链图片进行检测，如果存在外链图片，则下载到本地并替换链接，具体内容查看 博客外链图片已恢复 这篇文章； 再后面文章内图片使用 base64 进行编码嵌入在 markdown 文件中，但如果图片过大，markdown 文件过大，甚至无法在 Typecho 中储存。因此我也就不用石墨写文章了，通常会在本地 (使用本地图床) 写好文章，然后通过插件自动下载图床图片并修正到本地链接； 插件的鲁棒性不佳，存在下载失败的情况，不过好在下载失败的情况不多，我手动补了几张图片就解决了。 markdown 内图片链接提取，一般分为两种形式，都是使用正则来匹配 直接嵌入的图片![{text}]({url})，匹配正则：!\\[.*?\\]\\((.*?)\\)； 在文章底部使用 [{id}]:{url} 定义了一个脚注或引用链接，在使用时使用 ![{text}][{id}] 来引用，匹配正则：\\[\\d+\\]:\\s*(.*?)\\s*(?=&quot;#|$)。 GitHub Action 警告
为确保与您的服务器配置、仓库路径和特定需求相匹配，请适当修改以下代码段。避免直接复制粘贴，以预防潜在的兼容性问题或配置错误。
在过去的博客中，发布文章仅需在后台编辑后直接发送，便可立即在页面上看到效果。然而，自从转换到静态博客平台后，原本简洁的发布流程变得复杂。经过参考众多文章与资料，我目前采用了 GitHub Action 来简化这一流程。
新增文章流程 在本地操作 Hugo 新增文章，并使用 git 进行管理，并 push 到 GitHub 上； GitHub Action 检测到 push 并自动执行编译，编译后的页面结果存放在 gh-pages 分支中； 编译完毕后，GitHub Action 使用 Webhook 通知博客服务器来 GitHub 上拉取 gh-pages 的博客数据。 因为我的 GitHub 仓库是私有的，所以还需要把博客服务器的 SSH keys 添加到 GitHub，才能够拉取私有仓库。
GitHub Action 代码流程 配置解读
当 master 分支被 push 时自动执行； 运行在 Ubuntu-22.04 的环境上； 使用 Hugo 最新扩展版对博客源文件进行编译； 将编译后的 public 文件夹部署到 gh-pages 分支上； 通过 Webhook 来通知博客服务器来同步最新的静态页面数据。 1name: GitHub Pages 2 3on: 4 push: 5 branches: 6 - master # Set a branch to deploy 7 pull_request: 8 9jobs: 10 deploy: 11 runs-on: ubuntu-22.04 12 concurrency: 13 group: \${{ github.workflow }}-\${{ github.ref }} 14 steps: 15 - uses: actions/checkout@v4 16 with: 17 submodules: true # Fetch Hugo themes (true OR recursive) 18 fetch-depth: 0 # Fetch all history for .GitInfo and .Lastmod 19 20 - name: Setup Hugo 21 uses: peaceiris/actions-hugo@v2 22 with: 23 hugo-version: &#39;latest&#39; 24 extended: true 25 26 - name: Build 27 run: hugo --minify 28 29 - name: Deploy 30 uses: peaceiris/actions-gh-pages@v3 31 if: github.ref == &#39;refs/heads/master&#39; 32 with: 33 github_token: \${{ secrets.GH_TOKEN }} 34 publish_dir: ./public 35 36 - name: Update Blog Server 37 uses: distributhor/workflow-webhook@v1 38 env: 39 webhook_url: \${{ secrets.WEBHOOK_URL }} 40 webhook_secret: \${{ secrets.WEBHOOK_SECRET }} 实际效果展示
Webhook 执行脚本 1#!/bin/bash 2 3# Start of the script 4echo &#34;$(date &#34;+%Y-%m-%d %H:%M:%S&#34;) Run&#34; 5 6# Define variables 7gitPath=&#34;/www/wwwroot/newblog&#34; 8gitSSH=&#34;git@github.com:wjhwjhn/blog.git&#34; 9 10echo &#34;Web site path: $gitPath&#34; 11 12# Check if the directory exists 13if [ -d &#34;$gitPath&#34; ]; then 14 # Attempt to enter the directory 15 cd &#34;$gitPath&#34; || { echo &#34;Failed to enter directory $gitPath&#34;; exit 1; } 16 17 echo &#34;------&#34; 18 # Check if .git needs to be cloned 19 if [ ! -d &#34;.git&#34; ]; then 20 echo &#34;Cloning git into this directory&#34; 21 if git clone -b gh-pages &#34;$gitSSH&#34; gittemp &amp;&amp; mv gittemp/.git . &amp;&amp; rm -rf gittemp; then 22 echo &#34;Clone successful&#34; 23 else 24 echo &#34;Clone failed&#34; 25 exit 1 26 fi 27 fi 28 29 # Update the git repository 30 if git reset --hard gh-pages &amp;&amp; git pull; then 31 echo &#34;Update successful&#34; 32 else 33 echo &#34;Update failed&#34; 34 exit 1 35 fi 36 37 # Change ownership 38 chown -R www:www &#34;$gitPath&#34; 39 echo &#34;Finish&#34; 40else 41 echo &#34;The project path does not exist&#34; 42 echo &#34;Finish&#34; 43fi Typora 图片设置 Typora 支持便捷地在本地保存文件。但是如果设置不当，它可能无法兼容 Hugo 的图片存储方式，这里对 Typora 的配置做了以下调整
格式 -&gt; 图像 -&gt; 设置图片根目录，设置目录为 Hugo 源文件下的 static 文件夹
偏好设置 -&gt; 图像 -&gt; 插入图片处设置路径为 Hugo 源文件下的 static\\images\\ 文件夹
设置完毕后，在 Typora 中 Ctrl + V 粘贴图片就会自动以 /images/xxx.png 的链接呈现，并把图片保存在 static\\images\\ 文件夹，这个图片链接形式在 Typora 中和 Hugo 博客中都可以正常浏览。
总结 此次迁移历时三天，过程中虽然遇到了不少挑战，但也收获颇丰。通过提出问题、构思解决方案，以及运用编程技术解决实际问题的过程，为我带来了极大的满足感。
四年前，我建立了这个博客，那时对 Linux 的操作感到极度畏惧，我的理解也仅限于书本知识。在过去的四年中，我对 Linux（尤其是 Ubuntu）的了解和熟悉程度有了显著提高，逐渐体会到了类 Unix 系统的独特魅力。与此同时，我的云服务器也从最初以 Windows 系统为主、Linux 系统为辅，转变为全面采用 Linux 系统。
现在，回顾起我当初配置的服务器，我意识到了许多安全上的疏漏，同样，重新审视我早期的文章时，我也意识到了当时的视野局限和思维的稚嫩。我相信，四年后的自己再回看今日所做，可能会对某些决定感到可笑或有所遗憾。然而，我认为这正体现了人生的一环——持续学习，回望过往，对曾经的自己会心一笑。
`,url:"https://hugo-dead-simple.netlify.com/blog/hugo%E8%87%AA%E5%8A%A8%E5%8F%91%E5%B8%83/"},"https://hugo-dead-simple.netlify.com/posts/my-first-post/":{title:"My First Post",tags:[],content:`hdsdf
`,url:"https://hugo-dead-simple.netlify.com/posts/my-first-post/"},"https://hugo-dead-simple.netlify.com/posts/":{title:"Posts",tags:[],content:"",url:"https://hugo-dead-simple.netlify.com/posts/"},"https://hugo-dead-simple.netlify.com/blog/helloworld/":{title:"Helloworld",tags:[],content:`hello world write by Rainboy
`,url:"https://hugo-dead-simple.netlify.com/blog/helloworld/"},"https://hugo-dead-simple.netlify.com/group_theory/1%E7%AD%89%E4%BB%B7%E5%85%B3%E7%B3%BB%E4%B8%8E%E9%9B%86%E5%90%88%E7%9A%84%E5%88%86%E7%B1%BB/":{title:"1等价关系与集合的分类",tags:[],content:`对应视频的p1-p6
定义二元关系RRR 等价关系 反身性：∀a→aRa\\forall a \\to aRa∀a→aRa 对称性：aRb⇒bRaaRb \\Rightarrow bRaaRb⇒bRa 传递性：aRb∧bRc⇒aRcaRb \\land bRc \\Rightarrow aRcaRb∧bRc⇒aRc 等价类 定义：[a][a][a]表示所有与aaa等价的元素的集合 等价类是满足以下条件的集合：任意两个元素aaa和bbb都属于同一个等价类当且仅当aRbaRbaRb 公式定义: [a]={x∈S∣xRa}[a]= \\{ x \\in S | xRa \\}[a]={x∈S∣xRa} 类在这里的意思为:&ldquo;物以群分&rdquo;,分类的意思,等价类就是把满足等价关系的元素归为一类. 商集: SSS的全体等价类构成的集合,集合SSS在等价关系下的商集记作S/∽S / \\backsimS/∽ 集合的分类 定义：SSS是一个集合，如果存在一个等价关系RRR使得SSS的所有元素都可以划分为等价类，则称SSS为RRR的分类 如果非空集合SSS是它的某些两两不相交的非空子集的并,则称这些子集为集合SSS的一种分类(partition),其中每个子集称为集合SSS的一个类(class) 若集合SSS的子集族{Si∣i∈I}\\{S_i | i \\in I\\}{Si​∣i∈I}构成了S的一种分类当且仅当
S=⋃i∈ISiS = \\bigcup_{i \\in I} S_iS=⋃i∈I​Si​ Si∩Sj=∅S_i \\cap S_j = \\varnothingSi​∩Sj​=∅ (i.e., SiS_iSi​ and SjS_jSj​ are pairwise disjoint) 集合SSS的任何一种等价关系都确定了SSS的一种分类。
例题 例5 aRb⇔m∣a−b,∀a,b∈Z(1) aRb \\Leftrightarrow m \\mid a - b , \\forall a,b \\in \\mathbb{Z} \\tag 1 aRb⇔m∣a−b,∀a,b∈Z(1)证明1式是等价关系.也就是证明m∣a−bm | a -b m∣a−b是等价关系.
公式的含义解释: m是a与b差的因子,则说明a,b对于m同余.这两者是等价的.
下面证明这两者是等价关系.
设 A:a≡b(mod m)a \\equiv b (\\mod m)a≡b(modm), B: m∣a−bm \\mid a-bm∣a−b.
A→BA \\to BA→B,把a,b写成带余数除法的形式.
a=k1×m+rb=k2×m+ra−b=m(k1−k2)→m∣a−b a = k_1 \\times m + r \\\\ b = k_2 \\times m + r \\\\ a - b = m(k_1 - k_2) \\to m \\mid a - b a=k1​×m+rb=k2​×m+ra−b=m(k1​−k2​)→m∣a−b必要性证明完毕,证明充分性.
m∣a−b→a−b=k×m→a=b+k×m→amod m=(b+k×m)mod m→amod m=bmod m m \\mid a - b \\\\ \\to a -b = k \\times m \\\\ \\to a = b + k \\times m \\\\ \\to a \\mod m = (b+k \\times m) \\mod m \\\\ \\to a \\mod m = b \\mod m m∣a−b→a−b=k×m→a=b+k×m→amodm=(b+k×m)modm→amodm=bmodmqed;
证明自反性:
aRa⇔m∣a−a aRa \\Leftrightarrow m \\mid a - a aRa⇔m∣a−a显然成立.
证明对称性:
根据 m∣x→m∣−x m \\mid x \\to m \\mid -x m∣x→m∣−x那么
m∣a−b→m∣−(a−b)→m∣b−a m \\mid a - b \\to m \\mid -(a - b) \\to m \\mid b - a m∣a−b→m∣−(a−b)→m∣b−a证明传递性:
m∣a−b∧m∣b−c→m∣a−cm | a - b \\land m| b - c \\to m | a - cm∣a−b∧m∣b−c→m∣a−c
a=k1×m+rb=k2×m+rc=k3×m+r→a−c=k1×m+r−k3×m−r→m∣a−c a = k_1 \\times m + r \\\\ b = k_2 \\times m + r \\\\ c = k_3 \\times m + r \\\\ \\to a - c = k_1 \\times m + r - k_3 \\times m - r\\\\ \\to m \\mid a - c a=k1​×m+rb=k2​×m+rc=k3​×m+r→a−c=k1​×m+r−k3​×m−r→m∣a−c证明完毕
说明同余是一种等价关系.
书上又定义了什么叫做同余剩余类.
例9 这个见书.
课后题目 习题1. 试分别举出满足下列条件的关系： (1)有对称性，传递性，但无反身性； (2)有反身性，传递性，但无对称性； (3)有反身性，对称性，但无传递性. 解:设集合S={a,b,c}S = \\{a,b,c\\}S={a,b,c}
(1) ,R={(a,b),(b,a),(a,a),b,b}R = \\{(a,b),(b,a),(a,a),{b,b}\\}R={(a,b),(b,a),(a,a),b,b},因为没有(c,c)(c,c)(c,c)所以不满足反身性. (2) ,R={(a,a),(b,b),(c,c),(a,b)}R = \\{(a,a),(b,b),(c,c),(a,b)\\}R={(a,a),(b,b),(c,c),(a,b)},因为没有(b,a)(b,a)(b,a)所以不满足对称性. (3) ,R={(a,a),(b,b),(c,c),(a,b),(b,a),(c,a),(c,b)}R = \\{(a,a),(b,b),(c,c),(a,b),(b,a),(c,a),(c,b)\\}R={(a,a),(b,b),(c,c),(a,b),(b,a),(c,a),(c,b)},因为没有(a,c)(a,c)(a,c)所以不满足传递性. 习题2.找出下面证明中的错误： 有人断言，若S的关系R有对称性和传递性，则必有反身性.这晨因 为，对任意的a∈S,由对称性，如果aRb,则bRa.再由传递性，得aRa,所 以R有反身性.
关键在于a∈Sa \\in Sa∈S，但如果aaa就没有自己的关系呢?例如习题1的(1),就没有c的关系,所以不能说R有反身性. 因为不一定有cRbcRbcRb这个关系.
`,url:"https://hugo-dead-simple.netlify.com/group_theory/1%E7%AD%89%E4%BB%B7%E5%85%B3%E7%B3%BB%E4%B8%8E%E9%9B%86%E5%90%88%E7%9A%84%E5%88%86%E7%B1%BB/"},"https://hugo-dead-simple.netlify.com/group_theory/":{title:"Group_theories",tags:[],content:"",url:"https://hugo-dead-simple.netlify.com/group_theory/"},"https://hugo-dead-simple.netlify.com/typescript/preverseconstenums/":{title:"preserveConstEnums编译器选项",tags:["typescript"],content:`preserveConstEnums 是 TypeScript 编译器选项之一，作用是控制 TypeScript 编译过程中是否保留 const enum 的常量值。
详细作用： 当你在 TypeScript 中使用 const enum 时，它们会在编译时被内联展开为常量值，而不会生成单独的枚举代码。默认情况下，TypeScript 会将 const enum 编译为常量值，而不会生成任何枚举相关的 JavaScript 代码。
如果你启用 preserveConstEnums，TypeScript 编译器将不会内联 const enum，而是保留这些枚举，并生成相应的 JavaScript 代码。这样，编译后的代码将包含枚举的实际定义，而不是直接替换为常量值。
使用场景： preserveConstEnums: true: 如果你希望 const enum 在编译后依然保留为枚举定义（而不是被内联展开为常量值），可以开启这个选项。 preserveConstEnums: false（默认值）：会直接内联 const enum 的值，生成的 JavaScript 代码中不会包含枚举类型定义。 示例： 1. preserveConstEnums: false (默认) TypeScript 编译器将内联 const enum：
1const enum Color { 2 Red = 1, 3 Green = 2, 4 Blue = 3 5} 6 7let c = Color.Green; // 编译后直接替换成 2 编译后的 JavaScript 代码：
1var c = 2; 2. preserveConstEnums: true 如果启用 preserveConstEnums，编译后的代码会保留枚举定义：
1const enum Color { 2 Red = 1, 3 Green = 2, 4 Blue = 3 5} 6 7let c = Color.Green; 编译后的 JavaScript 代码：
1var Color; 2(function (Color) { 3 Color[Color[&#34;Red&#34;] = 1] = &#34;Red&#34;; 4 Color[Color[&#34;Green&#34;] = 2] = &#34;Green&#34;; 5 Color[Color[&#34;Blue&#34;] = 3] = &#34;Blue&#34;; 6})(Color || (Color = {})); 7var c = Color.Green; 总结： preserveConstEnums: true 保留 const enum 的定义在输出的 JavaScript 代码中，而不是将其内联成常量值。 preserveConstEnums: false（默认）则会将 const enum 的成员内联为常量值，生成的 JavaScript 代码会更简洁。 `,url:"https://hugo-dead-simple.netlify.com/typescript/preverseconstenums/"},"https://hugo-dead-simple.netlify.com/typescript/src/readme/":{title:"typescript",tags:["typescript"],content:`安装 1yarn global add typescript ts-node 数据类型 string boolean number void 用在没有返回值的函数,其它可以用,但不能赋值 1function alerme():void { 2 alert(&#39;my name is tom&#39;); 3} null,undefined,是所有类型的子类型,可以赋值给其它类型,而 void 类型的变量不能赋值给 number 类型的变量： 1let num:number = null 对象类型 1const xiaoJieJie : { 2 name:string, 3 age:number 4} = { 5 name:&#39;hel&#39;, 6 age:19 7} //1 普通 8 9const xiaoJjiejieS :string [] = [&#39;1&#39;,&#39;dajiao&#39;,&#39;liuyaing&#39;]; // 2 .数组 10 11class Person{} 12const dajiao: Person = new Person() //3 类类型 13 14const jianXiaoJjieJie: () =&gt; string = () =&gt; {return &#34;dajiao&#34;}; //函数对象类型 类型注解 与 类型推断 type annotation type inference 工作使用的原则
如果TS能够自动分析变量类型,我们就什么也不需要做了 如果TS无法分析变量类型的话,我们就需要使用类型注解了 05 函数参数和返回类型的注解 1&lt;%- include(&#34;demo/demo5.ts&#34;) %&gt; 06数组类型的定义 类型别名 1&lt;%- include(&#34;demo/demo6.ts&#34;) %&gt; 07 元组的使用 1&lt;%- include(&#34;demo/demo7.ts&#34;) %&gt; 元组现在用的少了,因为可以用对象的形式来代替
08 09 interface 接口 1&lt;%- include(&#34;demo/demo8.ts&#34;) %&gt; 1&lt;%- include(&#34;demo/demo9.ts&#34;) %&gt; [propname:string] : any; 内部约束了一个函数say():string; 接口约束一个类class xiaojiejie implements Gril 接口的拓展interface Teacher extends Girl{} 相当于继承 符合子接口的对象也符合父接口 10 类的概念和使用 定义 继承 重写 super 调用父类中的方法 1&lt;%- include(&#34;demo/demo10.ts&#34;) %&gt; 类的访问类型 private 内部用,外部不能用 protected 内部用,外部不能用,继承可以用 public 默认是public 都可以用 类的内部与外部
1&lt;%- include(&#34;demo/demo11.ts&#34;) %&gt; 12 类的构造函数 1&lt;%- include(&#34;demo/demo12.ts&#34;) %&gt; 13 类的getter setter static 只读 1&lt;%- include(&#34;demo/demo13.ts&#34;) %&gt; 14 抽象类 含有抽象方法的类叫做抽象类 继承抽象类的类必须实现抽象方法 1&lt;%- include(&#34;demo/demo14.ts&#34;) %&gt; 15 16 17 tsconfig.json 配置文件 tsc -init 生成 tsc 不加名字,会调用tsconfig.json &ldquo;include&rdquo;:[&ldquo;demo.ts&rdquo;], 可以是目录及文件,可以正则,可以glob &ldquo;exclude&rdquo;:[&ldquo;demo.ts&rdquo;], 可以排除include 里文件 &ldquo;files&rdquo;:[&ldquo;demo.ts&rdquo;], 和include一样,但只能是文件,不会被exclude排除 compileOptions
strict 严格ts noImplicitAny 充许你的注解类型any不用特意标明 strictNullChecks 不充许有null值出现 ts-node 也会用tsconfig.json rootdir 源代码根目录 outDir 编译输出的文件 sourceMap 生成.map文件 debug用 noUnsedLocal 不能出现没有使用的本地变量 18 类型保护与联合类型 不单一的类型 number | boolean 只有在联合类型的时候需要 类型保护 类型断言 person as Waiter skill in person typeof person ==='string' first instanceof NumberOBJ instanceof 只能用在类上 1&lt;%- include(&#34;demo/demo18.cpp&#34;) %&gt; 19 enum 类型 typescript 独有 1&lt;%- include(&#34;demo/demo19.cpp&#34;) %&gt; enum 可以反查 log(Status[1]) 20 泛型 1&lt;%- include(&#34;demo/demo20.cpp&#34;) %&gt; 21 类中使用泛型 1 2 - 泛型在类中的使用 \`class C&lt;T&gt;\` 3 4为了约束传入的参数 5 6 - 泛型继承 7 - 泛型约束 8 9&lt;%- include(&#34;demo/demo21.cpp&#34;) %&gt; 10 11## 22 23 命名空间 12 13在浏览器中运行与看效果 14 15 - vscode -&gt; file -&gt; openFloder 16 - vscode-&gt;terminal \`npm init\` 17 - \`tsc -init\` 18 - \`mkdir src &amp;&amp; mkdir build &amp;&amp; touch index.html\` 19 20 - 命名空间可以嵌套 namespace fater { namespace child { } }
1 2tsconfig.json 3 - outFile -&gt;生成一个单独的文件 4 - moduble coomjs -&gt;&#39;amd&#39; 5 6## 24 import 7 8需要引用 require.js 来使用 amd 的模块 require([&ldquo;page&rdquo;],function(){ })
1 2## 25 parcel yarn add &ndash;dev parcel
1 2## 26 ts 使用jquery yarn add @types/jquery
1 2or declare var $:any;
1 2## 资料 3 4 - [ruan一峰 es6]() 5 - [TypeScript 入门教程](https://ts.xcatliu.com/) 6 - [TypeScript Handbook（中文版）](https://zhongsp.gitbooks.io/typescript-handbook/content/) 7 - [技术胖-TypeScript 从入门到精通图文视频教程-免费教程](http://jspang.com/detailed?id=63) `,url:"https://hugo-dead-simple.netlify.com/typescript/src/readme/"},"https://hugo-dead-simple.netlify.com/tags/typescript/":{title:"Typescript",tags:[],content:"",url:"https://hugo-dead-simple.netlify.com/tags/typescript/"},"https://hugo-dead-simple.netlify.com/typescript/object_object/":{title:"TypeScript 中的 object 和 Object 的区别",tags:["typescript"],content:"在 TypeScript 中，object 和 Object 虽然看起来相似，但它们有着不同的含义和用途。\n1. object（小写） object 是一个 类型，表示任何非原始类型的值。原始类型包括：number、string、boolean、symbol、null 和 undefined。换句话说，object 类型是指 除原始类型之外的所有类型。\n特点： object 类型表示的值必须是一个对象（即非原始值），但不限定对象的结构（属性和方法）。 它并不等同于 Object 构造函数的类型。 不能直接访问对象的属性或方法，除非将其类型进一步细化。 示例： 1let obj: object; 2 3obj = { name: &#34;Alice&#34; }; // 合法 4obj = [1, 2, 3]; // 合法 5obj = () =&gt; {}; // 合法 6 7obj = 42; // 错误：类型 &#39;number&#39; 不能赋值给类型 &#39;object&#39; 8obj = &#34;hello&#34;; // 错误：类型 &#39;string&#39; 不能赋值给类型 &#39;object&#39; object 类型限制了只能是“非原始类型”的值，但是它并不关心具体是什么类型（例如是数组、函数还是普通对象）。因此，你不能直接访问对象的属性，除非你进一步指定对象的结构或类型。\n2. Object（大写） Object 是 JavaScript 中的内置构造函数，用来创建对象实例。在 TypeScript 中，Object 表示所有非 null 的类型，也就是说，它是所有类型的超集，除了 null 和 undefined。\n特点： Object 类型表示 所有对象类型，包括原始类型（string、number 等）以外的所有类型。 它是 JavaScript 中所有对象的父类，甚至可以用于表示原始类型（不过通常不这么做）。 示例： 1let obj: Object; 2 3obj = { name: &#34;Alice&#34; }; // 合法 4obj = [1, 2, 3]; // 合法 5obj = &#34;hello&#34;; // 合法（尽管通常不这么做） 6obj = 42; // 合法（`number` 也是 `Object` 类型的一部分） 7 8obj = null; // 错误：`null` 不能赋值给 `Object` Object 类型实际上包含了 所有类型，除 null 和 undefined 之外。\n3. 区别总结 特性 object Object 表示的内容 任何非原始类型（不包括 number, string, boolean, symbol, null, undefined） 所有类型（包括 number, string, boolean, symbol, 除 null 和 undefined） 是否允许原始类型 不允许原始类型（只能是对象） 允许原始类型（包括 number, string, boolean, symbol 等） 访问属性 不能直接访问属性，需要进一步细化类型 允许访问属性，实际上是 Object 类型的超集 常见用途 用于限定某个值是对象类型（而不是原始值） 表示所有类型（但不包括 null 和 undefined） 4. 进一步的示例： object 示例： 1let obj: object; 2 3obj = { name: &#34;Alice&#34; }; // 合法 4obj = [1, 2, 3]; // 合法 5obj = () =&gt; {}; // 合法 6 7// 下面的类型会报错，因为 `object` 类型不允许原始类型 8obj = 42; // 错误 9obj = &#34;hello&#34;; // 错误 10obj = true; // 错误 Object 示例： 1let obj: Object; 2 3obj = { name: &#34;Alice&#34; }; // 合法 4obj = [1, 2, 3]; // 合法 5obj = &#34;hello&#34;; // 合法 6obj = 42; // 合法 7 8// `null` 不能赋值给 `Object` 类型 9obj = null; // 错误 5. 总结 object 是一个类型，表示非原始类型（即排除 number, string, boolean, symbol, null 和 undefined）。它不能直接用于访问对象的属性。 Object 是 JavaScript 中的构造函数，它是所有类型的超集，除了 null 和 undefined，它允许表示任何类型，包括原始类型（如 string、number 等）。 在 TypeScript 中，建议尽量使用 object 来表示对象类型，避免使用 Object，除非你确实需要一个更宽泛的类型（表示所有非 null/undefined 的值）。\n",url:"https://hugo-dead-simple.netlify.com/typescript/object_object/"},"https://hugo-dead-simple.netlify.com/typescript/":{title:"typescript 学习笔记",tags:["typescript"],content:" 首页 如何调试 笔记:ts编程 对象字面量的使用 TypeScript 中的 object 和 Object 的区别 preserveConstEnums编译器选项 装饰器 ",url:"https://hugo-dead-simple.netlify.com/typescript/"},"https://hugo-dead-simple.netlify.com/typescript/readme/":{title:"typescript 学习笔记",tags:["typescript"],content:`资料 TypeScript Tutorial 阮一峰 es6 阮一峰 TypeScript 教程 TypeScript Handbook - The TypeScript Handbook TypeScript 入门教程 TypeScript Handbook（中文版） 现代TypeScript高级教程- - linwu-hi - 博客园 安装 1yarn global add typescript ts-node 数据类型 string boolean number void 用在没有返回值的函数,其它可以用,但不能赋值 1function alerme():void { 2 alert(&#39;my name is tom&#39;); 3} null,undefined,是所有类型的子类型,可以赋值给其它类型,而 void 类型的变量不能赋值给 number 类型的变量： 1 let num:number = null 对象类型 1const xiaoJieJie : { 2 name:string, 3 age:number 4} = { 5 name:&#39;hel&#39;, 6 age:19 7} //1 普通 8 9const xiaoJjiejieS :string [] = [&#39;1&#39;,&#39;dajiao&#39;,&#39;liuyaing&#39;]; // 2 .数组 10 11class Person{} 12const dajiao: Person = new Person() //3 类类型 13 14const jianXiaoJjieJie: () =&gt; string = () =&gt; {return &#34;dajiao&#34;}; //函数对象类型 脚手架 换了一个脚手架 GitHub - xddqnodejs-typescript-modern-starter Minimal and modern starter template to develop a Node.js project leveraging Typescript
类型注解 与 类型推断 type annotation type inference 工作使用的原则
如果TS能够自动分析变量类型,我们就什么也不需要做了 如果TS无法分析变量类型的话,我们就需要使用类型注解了 05 函数参数和返回类型的注解 demo5
06数组类型的定义 类型别名 demo/demo6.ts
07 元组的使用 demo/demo7.ts
元组现在用的少了,因为可以用对象的形式来代替
08 09 interface 接口 demo/demo8.ts
demo/demo9.ts
[propname:string] : any; 内部约束了一个函数say():string; 接口约束一个类class xiaojiejie implements Gril 接口的拓展interface Teacher extends Girl{} 相当于继承 符合子接口的对象也符合父接口 10 类的概念和使用 定义 继承 重写 super 调用父类中的方法 demo/demo10.ts
类的访问类型 private 内部用,外部不能用 protected 内部用,外部不能用,继承可以用 public 默认是public 都可以用 类的内部与外部
demo/demo11.ts
12 类的构造函数 demo/demo12.ts
13 类的getter setter static 只读 demo/demo13.ts
14 抽象类 含有抽象方法的类叫做抽象类 继承抽象类的类必须实现抽象方法 demo/demo14.ts
15 16 17 tsconfig.json 配置文件 tsc -init 生成 tsc 不加名字,会调用tsconfig.json &ldquo;include&rdquo;:[&ldquo;demo.ts&rdquo;], 可以是目录及文件,可以正则,可以glob &ldquo;exclude&rdquo;:[&ldquo;demo.ts&rdquo;], 可以排除include 里文件 &ldquo;files&rdquo;:[&ldquo;demo.ts&rdquo;], 和include一样,但只能是文件,不会被exclude排除 compileOptions
strict 严格ts noImplicitAny 充许你的注解类型any不用特意标明 strictNullChecks 不充许有null值出现 ts-node 也会用tsconfig.json rootdir 源代码根目录 outDir 编译输出的文件 sourceMap 生成.map文件 debug用 noUnsedLocal 不能出现没有使用的本地变量 18 类型保护与联合类型 不单一的类型 number | boolean 只有在联合类型的时候需要 类型保护 类型断言 person as Waiter skill in person typeof person ==='string' first instanceof NumberOBJ instanceof 只能用在类上 demo/demo18.ts
19 enum 类型 typescript 独有 demo/demo19.ts
enum 可以反查 log(Status[1]) 20 泛型 demo/demo20.ts
21 类中使用泛型 泛型在类中的使用 class C&lt;T&gt; 为了约束传入的参数
泛型继承 泛型约束 demo/demo21.ts
22 23 命名空间 在浏览器中运行与看效果
vscode -&gt; file -&gt; openFloder
vscode-&gt;terminal npm init
tsc -init
mkdir src &amp;&amp; mkdir build &amp;&amp; touch index.html
命名空间可以嵌套
1namespace fater { 2 namespace child { 3 } 4} tsconfig.json
outFile -&gt;生成一个单独的文件 moduble coomjs -&gt;&lsquo;amd&rsquo; 24 import 需要引用 require.js 来使用 amd 的模块
1require([&#34;page&#34;],function(){ 2}) 25 parcel 1yarn add --dev parcel 26 ts 使用jquery 1yarn add @types/jquery or
1declare var $:any; `,url:"https://hugo-dead-simple.netlify.com/typescript/readme/"},"https://hugo-dead-simple.netlify.com/mongodb/readme/":{title:"",tags:[],content:"",url:"https://hugo-dead-simple.netlify.com/mongodb/readme/"},"https://hugo-dead-simple.netlify.com/categories/":{title:"Categories",tags:[],content:"",url:"https://hugo-dead-simple.netlify.com/categories/"},"https://hugo-dead-simple.netlify.com/search/":{title:"Search Results",tags:[],content:"",url:"https://hugo-dead-simple.netlify.com/search/"}}</script><script defer src=/js/lunr.js></script><script defer src=/js/search.js></script><br><footer><script defer>document.addEventListener("keydown",function(e){if(document.activeElement.isContentEditable)return!1;if(document.activeElement.tagName=="INPUT")return!1;if(e.altKey||e.ctrlKey||e.shiftKey)return!1;var t=e.key;if(t==="h")e.preventDefault(),e.stopPropagation(),window.location.href="/";else if(t==="t")e.preventDefault(),e.stopPropagation(),window.location.href=`https://${location.hostname}/tags`;else if(t==="i"){e.preventDefault(),e.stopPropagation();const t=document.querySelectorAll("input");for(let e=0;e<t.length;e++)if(t[e].offsetParent!==null){t[e].selectionStart=t[e].selectionEnd=t[e].value.length,t[e].focus();break}}return!1})</script><script defer>function throttle(e,t){var n=Date.now();return function(){var s=Date.now();n+t-s<0&&(e(),n=s)}}function scrollHandler(){const e=Array.from(document.querySelectorAll("body h2, body h3"));function t(){for(var n,s,o,i=window.pageYOffset||document.documentElement.scrollTop,t=0;t<e.length;t++)s=e[t].getAttribute("id"),n=document.querySelector('nav ul li a[href="#'+s+'"]'),n&&n.classList.remove("active-toc");for(t=e.length-1;t>=0;t--)if(o=e[t].offsetTop,i>o-75&&(s=e[t].getAttribute("id"),n=document.querySelector('nav ul li a[href="#'+s+'"]'),n)){n.classList.add("active-toc");break}}window.addEventListener("scroll",throttle(t,200))}setTimeout(scrollHandler,100)</script><script defer>function addCopyButtonToCodeBlocks(){const e=document.querySelectorAll('code[class^="language-"]:not(.output):not([class*="language-console"])');e.forEach(e=>{const t=document.createElement("button");t.classList.add("copy-code-button"),t.innerHTML="copy",t.addEventListener("click",()=>{const s=e.querySelectorAll(".cl");let n="";s.forEach(e=>{n+=e.innerText}),navigator.clipboard.writeText(n),t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},1500)}),e.parentNode.before(t)})}setTimeout(function(){addCopyButtonToCodeBlocks()},100)</script><script defer src=/js/theme-switcher.js></script></footer></body></html>