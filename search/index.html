<!doctype html><html lang=en-us><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta http-equiv=cache-control content="max-age=0"><meta http-equiv=cache-control content="no-cache"><meta http-equiv=expires content="0"><meta http-equiv=expires content="Tue, 01 Jan 1980 1:00:00 GMT"><meta http-equiv=pragma content="no-cache"><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png }><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=manifest href=/site.webmanifest><meta name=theme-color media="(prefers-color-scheme: light)" content="#ffffff"><meta name=theme-color media="(prefers-color-scheme: dark)" content="#1b1b1b"><meta name=description content="Search Results"><title>Search Results | Rainboy's Blog</title><style>:root{--background:#ffffff}@media(prefers-color-scheme:dark){:root{--background:#1b1b1b}}html{background-color:var(--background)}body{background-color:var(--background)}</style><link rel=stylesheet type=text/css href=/style.min.00c1b0a7844f75fdb75caa7372b923be3231f839380ff0c3498e07b18e44f228.css media=all><link rel=stylesheet href=/grid.css></head><body><nav><ul class=menu><li><a tabindex=-1 class=menu-link href=/><u>H</u>ome</a></li><li><a tabindex=-1 class=menu-link href=/tags><u>T</u>ags</a></li></ul></nav><main id=main class=post><header><h1 id=search-title>Search Results</h1></header><form id=search-form action=/search method=get><label hidden for=search-input>Search site</label>
<input tabindex=-1 type=text id=search-input name=query placeholder="search [i] ..."></form><ul id=search-results></ul></main><script>window.store={"https://hugo-dead-simple.netlify.com/tags/aggregation/":{title:"Aggregation",tags:[],content:"",url:"https://hugo-dead-simple.netlify.com/tags/aggregation/"},"https://hugo-dead-simple.netlify.com/tags/exercises/":{title:"Exercises",tags:[],content:"",url:"https://hugo-dead-simple.netlify.com/tags/exercises/"},"https://hugo-dead-simple.netlify.com/tags/mongodb/":{title:"MongoDB",tags:[],content:"",url:"https://hugo-dead-simple.netlify.com/tags/mongodb/"},"https://hugo-dead-simple.netlify.com/mongodb/lookup/":{title:"MongoDB - Lookup 操作详解",tags:["MongoDB","Aggregation"],content:`FAQ 如果实现类似的sql的 join 功能呢?
查看官方文档
$lookup（聚合）— MongoDB 手册 v8.0 ask ask : 我在写在mongodb的相关内容, 有一个user collection ,还有一个comment collection,commment通过 userid 与user 进行了关联,,我在查询comment ,如何得到每个comment 里的user 的相关属性? Answser 在 MongoDB 中，如果 comment 集合中的每个文档通过 userId 字段与 user 集合中的用户进行关联，并且你希望在查询 comment 时获取每个评论对应的 user 的相关属性，你可以使用 $lookup 聚合操作来实现联表查询。
示例数据结构 user 集合:
{ &#34;_id&#34;: ObjectId(&#34;user1&#34;), &#34;name&#34;: &#34;Alice&#34;, &#34;email&#34;: &#34;alice@example.com&#34;, &#34;age&#34;: 30 } comment 集合:
{ &#34;_id&#34;: ObjectId(&#34;comment1&#34;), &#34;content&#34;: &#34;This is a comment&#34;, &#34;userId&#34;: ObjectId(&#34;user1&#34;), &#34;timestamp&#34;: ISODate(&#34;2024-12-09T10:00:00Z&#34;) } 使用 $lookup 进行联表查询 你可以使用聚合框架（aggregate()）结合 $lookup 来连接 comment 和 user 集合，并将每个评论对应的用户信息合并到评论数据中。
聚合查询示例 db.comment.aggregate([ { $lookup: { from: &#34;user&#34;, // 关联的集合是 &#34;user&#34; localField: &#34;userId&#34;, // 当前集合中关联字段是 &#34;userId&#34; foreignField: &#34;_id&#34;, // 关联到 &#34;user&#34; 集合中的 &#34;_id&#34; 字段 as: &#34;userDetails&#34; // 结果会放入 &#34;userDetails&#34; 数组字段 } }, { $unwind: &#34;$userDetails&#34; // 将 &#34;userDetails&#34; 数组展开成单个对象（如果每个评论只能有一个用户的话） } ]) 查询结果 假设 comment 集合有一个文档，如下所示：
{ &#34;_id&#34;: ObjectId(&#34;comment1&#34;), &#34;content&#34;: &#34;This is a comment&#34;, &#34;userId&#34;: ObjectId(&#34;user1&#34;), &#34;timestamp&#34;: ISODate(&#34;2024-12-09T10:00:00Z&#34;), &#34;userDetails&#34;: { &#34;_id&#34;: ObjectId(&#34;user1&#34;), &#34;name&#34;: &#34;Alice&#34;, &#34;email&#34;: &#34;alice@example.com&#34;, &#34;age&#34;: 30 } } 解析说明 $lookup: 在 comment 集合中的 userId 字段和 user 集合中的 _id 字段之间建立连接，将匹配到的用户信息加入到每个评论中，并存储在 userDetails 字段中。
$unwind: 如果你确定每个评论只有一个对应的用户（即 userId 字段指向的是唯一用户），使用 $unwind 将 userDetails 数组拆解成单个对象。这样，你就可以直接在每个评论文档中获取到用户的属性。
如果一个评论可能有多个用户（例如评论可能有多个作者），你可以跳过 $unwind，这样每个评论的 userDetails 会是一个数组，包含匹配的所有用户。
其他改进 如果你只关心某些特定的用户字段，可以通过 $project 对返回的字段进行过滤，减少数据传输量。例如：
db.comment.aggregate([ { $lookup: { from: &#34;user&#34;, localField: &#34;userId&#34;, foreignField: &#34;_id&#34;, as: &#34;userDetails&#34; } }, { $unwind: &#34;$userDetails&#34; }, { $project: { content: 1, // 只保留评论的内容 &#34;userDetails.name&#34;: 1, // 只返回用户的名字 &#34;userDetails.email&#34;: 1 // 只返回用户的邮箱 } } ]) 这样，结果将只包含评论内容以及用户的名字和邮箱。
总结 使用 aggregate() 方法结合 $lookup 可以轻松地在查询评论时获取每个评论对应用户的详细信息。如果你只关心部分用户字段，可以使用 $project 来限制返回的字段，优化查询效率。
`,url:"https://hugo-dead-simple.netlify.com/mongodb/lookup/"},"https://hugo-dead-simple.netlify.com/mongodb/find_on_array/":{title:"MongoDB - 在数组上查询",tags:["MongoDB","Querying"],content:`查询数组 - MongoDB 手册 v8.0
$ne操作在数组的查询与我想的不一样
如果你希望能够匹配数组中有部分元素与 &ldquo;red&rdquo; 不匹配的文档，可以使用 $elemMatch 来精确匹配数组中的单个元素：
db.newdb.find({ tags: { $elemMatch: { $ne: &#34;red&#34; } } }) 查询数组元素
多个条件
const cursor = db.collection(&#39;inventory&#39;).find({ dim_cm: { $gt: 15, $lt: 20 } }); 数学描述
∃x∈A(x&gt;=15)∧∃x∈A(x&lt;=20) \\exists x \\in A( x&gt;=15) \\land \\exists x \\in A (x &lt;=20) ∃x∈A(x&gt;=15)∧∃x∈A(x&lt;=20)const cursor = db.collection(&#39;inventory&#39;).find({ dim_cm: { $elemMatch: { $gt: 22, $lt: 30 } } }); ∃x∈A(x&gt;=15∧x&lt;=20) \\exists x \\in A( x&gt;=15 \\land x &lt;=20) ∃x∈A(x&gt;=15∧x&lt;=20)const cursor = db.collection(&#39;inventory&#39;).find({ dim_cm: {$eq:20} }); ∃x∈A(x=20) \\exists x \\in A( x=20) ∃x∈A(x=20)const cursor = db.collection(&#39;inventory&#39;).find({ dim_cm: {$ne:20} }); !!!注意这个查询是上面的查询的反面
¬∃x∈A(x=20)∀¬(x=20)∀(x!=20) \\begin{matrix} \\neg \\exists x \\in A(x = 20) \\\\ \\forall \\neg (x = 20) \\\\ \\forall (x != 20) \\end{matrix} ¬∃x∈A(x=20)∀¬(x=20)∀(x!=20)​`,url:"https://hugo-dead-simple.netlify.com/mongodb/find_on_array/"},"https://hugo-dead-simple.netlify.com/mongodb/":{title:"MongoDB 学习笔记",tags:[],content:`这里是我学习 MongoDB 过程中记录的所有笔记和练习。
MongoDB - Lookup 操作详解 MongoDB 练习 1 MongoDB 练习 2 MongoDB 练习 3 MongoDB 练习 4 MongoDB - 在数组上查询 `,url:"https://hugo-dead-simple.netlify.com/mongodb/"},"https://hugo-dead-simple.netlify.com/mongodb/mongodb/":{title:"MongoDB 学习笔记",tags:[],content:`安装 docker 安装,根据文档来: https://www.mongodb.com/zh-cn/docs/manual/tutorial/install-mongodb-community-with-docker/
安装完后,我根据 https://www.w3resource.com/mongodb-exercises/ 做练习
这里的客户端选择了mongodb compass: https://www.mongodb.com/try/download/compass
最重要的就是mongodb的官方文档: https://www.mongodb.com/zh-cn/docs/manual/
一些概念 数据 --&gt; 集合-&gt; 文档 学习路线 我认为学习的路线为
增删改查 注意数组上查询的反直觉行为 注意$ne在数组的查询问题 聚合 索引 `,url:"https://hugo-dead-simple.netlify.com/mongodb/mongodb/"},"https://hugo-dead-simple.netlify.com/mongodb/exercise/":{title:"MongoDB 练习 1",tags:["MongoDB","Exercises"],content:`5 Write a MongoDB query to display all the restaurant which is in the borough Bronx. 这个简单,本质是查询固定的值
db[&#34;restaurants&#34;].find({&#39;borough&#39;:&#39;Bronx&#39;}) 8 Write a MongoDB query to find the restaurants who achieved a score more than 90. 让我们查询一个数组,数组里面有一个Object的值&gt;=0
db[&#34;restaurants&#34;].find({&#39;grades.score&#39;: {$gt : 90}}).count() db[&#34;restaurants&#34;].find({ &#39;grades&#39; : {$elemMatch : { &#34;score&#34; :{$gt : 90} } } }) 这两个的结果是等价的,只不过第二个用到了数组匹配操作符$elemMatch
9 Write a MongoDB query to find the restaurants that achieved a score, more than 80 but less than 100. 这个题目的意思是: grades里存在一个分数,这个分数在80与90之间
db[&#34;restaurants&#34;].find({ &#39;grades&#39; : {$elemMatch : { &#34;score&#34; :{$gt : 80,$lt:100} } } }) 10 Write a MongoDB query to find the restaurants which locate in latitude value less than -95.754168. 这里考察我们如何查询数组里某个下标的值
db.restaurants.find({&#34;address.coord.0&#34;:{$lte : -95.754168} }) 11 Write a MongoDB query to find the restaurants that do not prepare any cuisine of &lsquo;American&rsquo; and their grade score more than 70 and latitude less than -65.754168. db[&#34;restaurants&#34;].count({cuisine:{$not: {$regex: /.*American.*/ } },grades:{$elemMatch : { &#34;score&#34;:{$gte:70} }} }) 这里考查我们有多个条件,同时成立的查询
发现一个问题:
我查询了文档
mongodb在数组上的查询 https://www.mongodb.com/zh-cn/docs/manual/tutorial/query-arrays/#specify-multiple-conditions-for-array-elements mongodb - mongo $ne query with an array not working as expected - Stack Overflow $ne操作在数组的查询与我想的不一样
如果你希望能够匹配数组中有部分元素与 &ldquo;red&rdquo; 不匹配的文档，可以使用 $elemMatch 来精确匹配数组中的单个元素：
db.newdb.find({ tags: { $elemMatch: { $ne: &#34;red&#34; } } }) 这里官方给出的答案
db.restaurants.find( {$and: [ {&#34;cuisine&#34; : {$ne :&#34;American &#34;}}, {&#34;grades.score&#34; : {$gt : 70}}, {&#34;address.coord&#34; : {$lt : -65.754168}} ] }); 12 Write a MongoDB query to find the restaurants which do not prepare any cuisine of &lsquo;American&rsquo; and achieved a score more than 70 and located in the longitude less than -65.754168. Note : Do this query without using $and operator. 和上一个问题的问题一样,只是不让我们使用$and$符号
db.restaurants.find( { &#34;cuisine&#34; : {$ne : &#34;American &#34;}, &#34;grades.score&#34; :{$gt: 70}, &#34;address.coord&#34; : {$lt : -65.754168} } ); 13 Write a MongoDB query to find the restaurants which do not prepare any cuisine of &lsquo;American&rsquo; and achieved a grade point &lsquo;A&rsquo; not belongs to the borough Brooklyn. The document must be displayed according to the cuisine in descending order. 前面的条件还好,这里只是多了一个排序的要求
db.restaurants.find( { &#34;cuisine&#34; : {$ne : &#34;American&#34;}, &#34;grades.grade&#34; :&#34;A&#34;, &#34;borough&#34;: {$ne : &#34;Brooklyn&#34;} } ).sort({&#34;cuisine&#34;:-1}); 14 Write a MongoDB query to find the restaurant Id, name, borough and cuisine for those restaurants which contain &lsquo;Wil&rsquo; as first three letters for its name. 查询的条件是name的首个三个字母是3个Wil字符.
我这里的写法与官方不一样,因为我不理解官方的第二个参数,为什么这样写,因为我查询的nodejs api 不是这样的.
https://mongodb.github.io/node-mongodb-native/6.11/interfaces/FindOptions.html#projection
db[&#34;restaurants&#34;].find ({name:/AWil/}).projection({name:1,restaurant_id:1,borough:1,cuisine:1}}) 为什么会这样? ,AI 告诉我这是一个差异!!!
你提出的问题涉及到 MongoDB Node.js Driver 的 find 方法的第二个参数，它实际上是一个 选项对象（options），而 投影（projection） 是该选项对象中的一个字段。这是 MongoDB Node.js Driver 和 MongoDB Shell（mongosh）之间的一个差异。
MongoDB Node.js Driver 的 find 方法 根据你提供的链接，在 MongoDB 的 Node.js Driver 版本 3.6 中，find 方法的第二个参数 必须是一个选项对象，该对象中可以包含多个选项，例如 projection, sort, limit 等。
find 方法的签名（Node.js Driver） find(filter, options) filter: 查询条件。 options: 选项对象，其中包括多个可选的字段，例如 projection, sort, limit 等。 投影（Projection）在选项对象中 在 MongoDB Node.js Driver 中，投影（projection） 是通过选项对象中的 projection 字段来指定的。因此，第二个参数的形式通常是一个包含 projection 字段的对象，而 投影（projection） 本身是一个文档，定义了需要包含或排除的字段。
示例代码： const { MongoClient } = require(&#39;mongodb&#39;); async function queryRestaurants() { const client = new MongoClient(&#39;mongodb://localhost:27017&#39;); await client.connect(); const db = client.db(&#39;test&#39;); // 假设你的数据库名是 &#39;test&#39; const collection = db.collection(&#39;restaurants&#39;); // 使用 find 查询并投影 const cursor = collection.find( { name: /^Wil/ }, { projection: { &#34;restaurant_id&#34;: 1, &#34;name&#34;: 1, &#34;borough&#34;: 1, &#34;cuisine&#34;: 1 } } ); // 获取查询结果并打印 const results = await cursor.toArray(); console.log(results); await client.close(); } queryRestaurants().catch(console.error); 为什么必须使用 projection 字段？ 在 Node.js MongoDB Driver 的 find 方法中，第二个参数是一个 选项对象（options），因此你需要明确指定 projection 字段来设置查询返回的字段。这是与 MongoDB Shell（mongosh） 的差异，后者可以直接将投影文档作为第二个参数。
Node.js Driver 的选项对象结构 在 Node.js 中，你可以传递一个包含多个选项字段的对象，例如：
{ projection: { &#34;restaurant_id&#34;: 1, &#34;name&#34;: 1, &#34;borough&#34;: 1, &#34;cuisine&#34;: 1 }, sort: { name: 1 }, limit: 10 } projection: 指定返回的字段。 sort: 指定排序规则。 limit: 限制返回的文档数量。 总结 在 MongoDB Node.js Driver 中，第二个参数是一个 选项对象（options），其中包含 projection 字段来指定投影。而在 MongoDB Shell（mongosh） 中，第二个参数直接是一个投影文档，可以省略 projection 字段名。
Node.js Driver 使用 projection： db.restaurants.find( { name: /^Wil/ }, { projection: { &#34;restaurant_id&#34;: 1, &#34;name&#34;: 1, &#34;borough&#34;: 1, &#34;cuisine&#34;: 1 } } ); MongoDB Shell 中直接传递投影文档： db.restaurants.find( { name: /^Wil/ }, { &#34;restaurant_id&#34;: 1, &#34;name&#34;: 1, &#34;borough&#34;: 1, &#34;cuisine&#34;: 1 } ); 好吧,经过我的查询,这真的是一个差异:
https://stackoverflow.com/questions/67090307/mongodb-projection-syntax https://www.mongodb.com/zh-cn/docs/manual/reference/method/db.collection.findOne/ 两者确实不一样.
15 Write a MongoDB query to find the restaurant Id, name, borough and cuisine for those restaurants which contain &lsquo;ces&rsquo; as last three letters for its name. 和上一个问题一样,但是要查询的值是最后三个字符,还是使用regex
db.restaurants.find( {name: /ces$/}, { &#34;restaurant_id&#34; : 1, &#34;name&#34;:1,&#34;borough&#34;:1, &#34;cuisine&#34; :1 } ); db[&#34;restaurants&#34;].find ({name:/ces$/}).projection({name:1, restaurant_id:1,borough:1,cuisine:1}) 16 包含Reg+投影 Write a MongoDB query to find the restaurant Id, name, borough and cuisine for those restaurants which contain &lsquo;Reg&rsquo; as three letters somewhere in its name. 改变一下reg就可以了.
db[&#34;restaurants&#34;].find({name:/Reg/},{name:1}).count() db[&#34;restaurants&#34;].find({name:/Reg/},{name:1}).count() db.restaurants.find( {&#34;name&#34;: /.*Reg.*/}, { &#34;restaurant_id&#34; : 1, &#34;name&#34;:1,&#34;borough&#34;:1, &#34;cuisine&#34; :1 } ); 17 Write a MongoDB query to find the restaurants which belong to the borough Bronx and prepared either American or Chinese dish. db[&#34;restaurants&#34;].find({&#34;cuisine&#34;: {$in :[&#39;Chinese&#39;, &#39;American &#39;]} , &#34;borough&#34;: &#34;Bronx&#34; },{&#34;cuisine&#34;:1}).count() db.restaurants.find( { &#34;borough&#34;: &#34;Bronx&#34; , $or : [ { &#34;cuisine&#34; : &#34;American &#34; }, { &#34;cuisine&#34; : &#34;Chinese&#34; } ] } ); 18 Write a MongoDB query to find the restaurant Id, name, borough and cuisine for those restaurants which belong to the borough Staten Island or Queens or Bronxor Brooklyn.
和我的上一个执行$in的语法一样
db.restaurants.find( {&#34;borough&#34; :{$in :[&#34;Staten Island&#34;,&#34;Queens&#34;,&#34;Bronx&#34;,&#34;Brooklyn&#34;]}}, { &#34;restaurant_id&#34; : 1, &#34;name&#34;:1,&#34;borough&#34;:1, &#34;cuisine&#34; :1 } ); 19 Write a MongoDB query to find the restaurant Id, name, borough and cuisine for those restaurants which are not belonging to the borough Staten Island or Queens or Bronxor Brooklyn.
从数理逻辑的角度来看,a∉{borough Staten Island , Queens , Bronxor Brooklyn}a \\notin \\{\\text{borough Staten Island , Queens , Bronxor Brooklyn} \\}a∈/{borough Staten Island , Queens , Bronxor Brooklyn} 当这个条件为true的时候,这里使用$nin操作
db.restaurants.find( {&#34;borough&#34; :{$nin :[&#34;Staten Island&#34;,&#34;Queens&#34;,&#34;Bronx&#34;,&#34;Brooklyn&#34;]}}, { &#34;restaurant_id&#34; : 1, &#34;name&#34;:1,&#34;borough&#34;:1, &#34;cuisine&#34; :1 } ); 20 Write a MongoDB query to find the restaurant Id, name, borough and cuisine for those restaurants which achieved a score which is not more than 10.
这里的核心就在于 not more than 10 ,数学写法
¬(grades.score&gt;10)⇔grades.score&lt;=10 \\neg (grades.score &gt; 10) \\Leftrightarrow grades.score &lt;= 10 ¬(grades.score&gt;10)⇔grades.score&lt;=10db[&#34;restaurants&#34;].find({&#34;grades.score&#34;: {$lte: 10}}).count() db.restaurants.find( {&#34;grades.score&#34; : { $not: {$gt : 10} } }).count() 恩&hellip;&hellip;&hellip;.., 两者竟然是不一样的.
题目应该问的是: 所有的分都不超过10.
$lte:10 应该是只要有一个(存在)&lt;=10 就成立
遇到这种事件,应该首先查文档: https://www.mongodb.com/zh-cn/docs/manual/reference/operator/query/not/,但文档上没有说.
find({ &quot;grades.score&quot;: {$gt : 10} }) 表示的意思其实是: ∃(x&gt;10)\\exists (x &gt; 10)∃(x&gt;10)
find({ &quot;grades.score&quot;: {$not :{ $gt : 10} }}) 表示的意思其实是: ¬∃(x&gt;10)→∀(x&lt;=10)\\neg \\exists (x &gt; 10) \\to \\forall (x&lt;=10)¬∃(x&gt;10)→∀(x&lt;=10),这样就能理解了
`,url:"https://hugo-dead-simple.netlify.com/mongodb/exercise/"},"https://hugo-dead-simple.netlify.com/mongodb/exercise2/":{title:"MongoDB 练习 2",tags:["MongoDB","Exercises"],content:`21 Write a MongoDB query to find the restaurant Id, name, borough and cuisine for those restaurants which prepared dish except &lsquo;American&rsquo; and &lsquo;Chinees&rsquo; or restaurant&rsquo;s name begins with letter &lsquo;Wil&rsquo;.
db.restaurants.find({ $or : [ {&#34;name&#34;: /^Wil/}, {&#34;cuisine&#34; : { $nin :[&#34;American &#34;,&#34;Chinees&#34;] }} ] }) 这两个写法是一样的
db.restaurants.find( {$or: [ {name: /^Wil/}, {&#34;$and&#34;: [ {&#34;cuisine&#34; : {$ne :&#34;American &#34;}}, {&#34;cuisine&#34; : {$ne :&#34;Chinees&#34;}} ]} ]} ,{&#34;restaurant_id&#34; : 1,&#34;name&#34;:1,&#34;borough&#34;:1,&#34;cuisine&#34; :1} ); 22 Write a MongoDB query to find the restaurant Id, name, and grades for those restaurants which achieved a grade of &ldquo;A&rdquo; and scored 11 on an ISODate &ldquo;2014-08-11T00:00:00Z&rdquo; among many of survey dates. 达到了 grade A 且 scored 11. 首先,我们要理解这里的意思到底是什么意思?
有三个条件:
时间: ISODate &ldquo;2014-08-11T00:00:00Z 分值: 11 grade: A 这里的关键在于,数组grades其中的一条满足这3个条件.那么里这里要用到的$elemMatch
db.restaurants.find({ grades:{ $elemMatch : { grade:&#39;A&#39;,date:ISODate(&#34;2014-08-11T00:00:00Z&#34;), scored: 11}} }) 但是给出的答案是,理解我写在注释里
db.restaurants.find( { // 这里是and &#34;grades.date&#34;: ISODate(&#34;2014-08-11T00:00:00Z&#34;), // 这里只要有一个数组的元素成立 &#34;grades.grade&#34;:&#34;A&#34; , // 这里只要有一个数组的元素成立 &#34;grades.score&#34; : 11// 这里只要有一个数组的元素成立 }, {&#34;restaurant_id&#34; : 1,&#34;name&#34;:1,&#34;grades&#34;:1} ); 这里怎么用数学描述: 设集合A为A = [{},{},{},{}], 满足条件a∈A∧b∈A∧c∈Aa \\in A \\land b \\in A \\land c \\in Aa∈A∧b∈A∧c∈A
23 Write a MongoDB query to find the restaurant Id, name and grades for those restaurants where the 2nd element of grades array contains a grade of &ldquo;A&rdquo; and score 9 on an ISODate &ldquo;2014-08-11T00:00:00Z&rdquo;.
arrayElemAt（如果你需要明确选择数组中的特定元素）
如果你明确只想要查询数组的第二个元素，elemMatch 不能直接做这件事。不过，你可以结合 $arrayElemAt 来选择数组中的第二个元素进行条件匹配：
db.collection.find({ &#34;$expr&#34;: { &#34;$eq&#34;: [ { &#34;$arrayElemAt&#34;: [&#34;$grades&#34;, 1] }, // 获取第二个元素 { &#34;grade&#34;: &#34;A&#34;, &#34;score&#34;: 9, &#34;date&#34;: ISODate(&#34;2014-08-11T00:00:00Z&#34;) } // 条件 ] } }) 那么还是官方给的答案比较简单:
db.restaurants.find( { &#34;grades.1.date&#34;: ISODate(&#34;2014-08-11T00:00:00Z&#34;), &#34;grades.1.grade&#34;:&#34;A&#34; , &#34;grades.1.score&#34; : 9 }, {&#34;restaurant_id&#34; : 1,&#34;name&#34;:1,&#34;grades&#34;:1} ); 24 Write a MongoDB query to find the restaurant Id, name, address and geographical location for those restaurants where 2nd element of coord array contains a value which is more than 42 and upto 52.
没有争议
db.restaurants.find( { &#34;address.coord.1&#34;: {$gt : 42, $lte : 52} }, {&#34;restaurant_id&#34; : 1,&#34;name&#34;:1,&#34;address&#34;:1,&#34;coord&#34;:1} ); 25,26 Write a MongoDB query to arrange the name of the restaurants in ascending order along with all the columns. Write a MongoDB query to arrange the name of the restaurants in descending along with all the columns. 就是排序而已
db.restaurants.find().sort({&#34;name&#34;:1}); db.restaurants.find().sort( {&#34;name&#34;:-1}); 27 Write a MongoDB query to arranged the name of the cuisine in ascending order and for that same cuisine borough should be in descending order.
还是排序,不过同时要排序两个元素
db.restaurants.find().sort( {&#34;cuisine&#34;:1,&#34;borough&#34; : -1,} ); 28 Write a MongoDB query to know whether all the addresses contains the street or not.
查询元素的存在性
db.restaurants.find( {&#34;address.street&#34; : { $exists : true } } ); 29 Write a MongoDB query which will select all documents in the restaurants collection where the coord field value is Double.
查询元素的类型
对于 field 为数组的文档，$type 返回的文档中至少有一个数组元素与传递给 $type 的类型匹配。
对 $type: &ldquo;array&rdquo; 的查询会返回字段本身为数组的文档。
$type — MongoDB 手册 v8.0
db.restaurants.find( {&#34;address.coord&#34; : {$type : 1} }); 30 Write a MongoDB query which will select the restaurant Id, name and grades for those restaurants which returns 0 as a remainder after dividing the score by 7.
这里用到了 $mod - MongoDB 手册 v8.0
db.restaurants.find( {&#34;grades.score&#34; : {$mod : [7,0]} }, {&#34;restaurant_id&#34; : 1,&#34;name&#34;:1,&#34;grades&#34;:1} ); 31 Write a MongoDB query to find the restaurant name, borough, longitude and attitude and cuisine for those restaurants which contains &lsquo;mon&rsquo; as three letters somewhere in its name.
正则查询
db.restaurants.find( { name : { $regex : &#34;mon.*&#34;, $options: &#34;i&#34; } }, { &#34;name&#34;:1, &#34;borough&#34;:1, &#34;address.coord&#34;:1, &#34;cuisine&#34; :1 } ); 32 Write a MongoDB query to find the restaurant name, borough, longitude and latitude and cuisine for those restaurants which contain &lsquo;Mad&rsquo; as first three letters of its name.
正则查询
db.restaurants.find( { name : { $regex : /^Mad/i, } }, { &#34;name&#34;:1, &#34;borough&#34;:1, &#34;address.coord&#34;:1, &#34;cuisine&#34; :1 } ); 33 Write a MongoDB query to find the restaurants that have at least one grade with a score of less than 5.
数组查询
db.restaurants.find({ &#34;grades.score&#34;: { $lt: 5 } }) 34 Write a MongoDB query to find the restaurants that have at least one grade with a score of less than 5 and that are located in the borough of Manhattan.
怎么变简单了?
db.restaurants.find({ &#34;grades.score&#34;: { $lt: 5 }, &#34;borough&#34;: &#34;Manhattan&#34; }) 35 Write a MongoDB query to find the restaurants that have at least one grade with a score of less than 5 and that are located in the borough of Manhattan or Brooklyn.
还是简单
db.restaurants.find({ $and: [ { $or: [ // 可以用$in {borough: &#34;Manhattan&#34;}, {borough: &#34;Brooklyn&#34;} ] }, { &#34;grades.score&#34;: { $lt: 5 } } ] }) 36 Write a MongoDB query to find the restaurants that have at least one grade with a score of less than 5 and that are located in the borough of Manhattan or Brooklyn, and their cuisine is not American.
官方给的这个答案,可以不用最外层的$and
db.restaurants.find({ $and: [ { $or: [{ borough: &#34;Manhattan&#34; }, { borough: &#34;Brooklyn&#34; }] }, { &#34;grades.score&#34;: { $lt: 5 } }, { cuisine: { $ne: &#34;American&#34; } } ] }) 37 Write a MongoDB query to find the restaurants that have at least one grade with a score of less than 5 and that are located in the borough of Manhattan or Brooklyn, and their cuisine is not American or Chinese.
这里用到了不是...,也不是....这个也语法
$nor - MongoDB 手册 v8.0
选择数组中所有查询谓词均未通过的文档
$nor :[ expr1 ,expr2...] 那么查询的文档满足的条件是：
expr1(doc1) == false and expr2(doc2) == false 38 Write a MongoDB query to find the restaurants that have a grade with a score of 2 and a grade with a score of 6.
grades 含有2，和6
我写的
db.restaurants.find({ &#34;grades.score&#34;: 2, &#34;grades.score&#34;: 6, }) 效果一样的官方答案。
db.restaurants.find({ $and: [ {&#34;grades.score&#34;: 2}, {&#34;grades.score&#34;: 6} ] }) 39 Write a MongoDB query to find the restaurants that have a grade with a score of 2 and a grade with a score of 6 and are located in the borough of Manhattan.
没有什么难度
db.restaurants.find({ $and: [ {&#34;grades.score&#34;: 2}, {&#34;grades.score&#34;: 6}, {&#34;borough&#34;: &#34;Manhattan&#34;} ] }) 40 Write a MongoDB query to find the restaurants that have a grade with a score of 2 and a grade with a score of 6 and are located in the borough of Manhattan or Brooklyn.
db.restaurants.find({ $and: [ {&#34;grades.score&#34;: 2}, {&#34;grades.score&#34;: 6}, {&#34;borough&#34;: {&#34;$in&#34;: [&#34;Manhattan&#34;, &#34;Brooklyn&#34;]}} ] }) `,url:"https://hugo-dead-simple.netlify.com/mongodb/exercise2/"},"https://hugo-dead-simple.netlify.com/mongodb/exercise3/":{title:"MongoDB 练习 3",tags:["MongoDB","Exercises"],content:`41 Write a MongoDB query to find the restaurants that have a grade with a score of 2 and a grade with a score of 6 and are located in the borough of Manhattan or Brooklyn, and their cuisine is not American.
没有什么难度
db.restaurants.find({ $and: [ {borough: {$in: [&#34;Manhattan&#34;, &#34;Brooklyn&#34;]}}, {&#34;grades.score&#34;: {$all: [2, 6]}}, {cuisine: {$ne: &#34;American&#34;}} ] }) 这里用到了$all运算符, 表示后面的值[2,6]都要单独同时匹配
42 Write a MongoDB query to find the restaurants that have a grade with a score of 2 and a grade with a score of 6 and are located in the borough of Manhattan or Brooklyn, and their cuisine is not American or Chinese.
db.restaurants.find({ $and: [ { borough: { $in: [&#34;Manhattan&#34;, &#34;Brooklyn&#34;] } }, { cuisine: { $nin: [&#34;American&#34;, &#34;Chinese&#34;] } }, { grades: { $elemMatch: { score: 2 } } }, { grades: { $elemMatch: { score: 6 } } } ] }) 43 Write a MongoDB query to find the restaurants that have a grade with a score of 2 or a grade with a score of 6.
db.restaurants.find({ $or: [ { &#34;grades.score&#34;: 2 }, { &#34;grades.score&#34;: 6 } ] }) 44 Write a MongoDB query to find the restaurants that have a grade with a score of 2 or a grade with a score of 6 and are located in the borough of Manhattan.
没有什么难度
db.restaurants.find({ $and: [ { $or: [ { &#34;grades.score&#34;: 2 }, { &#34;grades.score&#34;: 6 } ] }, { &#34;borough&#34;: &#34;Manhattan&#34; } ] }) 45 Write a MongoDB query to find the restaurants that have a grade with a score of 2 or a grade with a score of 6 and are located in the borough of Manhattan or Brooklyn.
db.restaurants.find({ $and: [ { $or: [ { borough: &#34;Manhattan&#34; }, { borough: &#34;Brooklyn&#34; } ] }, { $or: [ { &#34;grades.score&#34;: 2 }, { &#34;grades.score&#34;: 6 } ] } ] }) 48 Write a MongoDB query to find the restaurants that have all grades with a score greater than 5.
这个是比较有意思的查询: 所有grade.score都要大于5
正确的查询数组里的值,都是存在,现在要转成\\forall
db.restaurants.find({ &#34;grades&#34;: { &#34;$not&#34;: { &#34;$elemMatch&#34;: { &#34;score&#34;: { &#34;$lte&#34;: 5 } } } } }) 49 Write a MongoDB query to find the restaurants that have all grades with a score greater than 5 and are located in the borough of Manhattan.
多个条件,关键就在于这个条件:所有的
50 Write a MongoDB query to find the restaurants that have all grades with a score greater than 5 and are located in the borough of Manhattan or Brooklyn.
不难,这里有一个条件,或者
db.restaurants.find({ &#34;borough&#34;: { &#34;$in&#34;: [&#34;Manhattan&#34;, &#34;Brooklyn&#34;] }, &#34;grades&#34;: { &#34;$not&#34;: { &#34;$elemMatch&#34;: { &#34;score&#34;: { &#34;$lte&#34;: 5 } } } } }) `,url:"https://hugo-dead-simple.netlify.com/mongodb/exercise3/"},"https://hugo-dead-simple.netlify.com/mongodb/exercise4/":{title:"MongoDB 练习 4",tags:["MongoDB","Exercises"],content:`51 Write a MongoDB query to find the average score for each restaurant.
一个数组的平均值
这里我遇到的第一个 aggregate
db.restaurants.aggregate([{ $unwind: &#34;$grades&#34; }, { $group: { _id: &#34;$name&#34;, avgScore: { $avg: &#34;$grades.score&#34; } } } ]) 这里gpt给出的多种求平均值的方法
在 MongoDB 中，要求数组的平均值可以使用 聚合框架 来处理。MongoDB 的聚合框架提供了强大的数据操作功能，包括计算数组中元素的平均值。可以通过以下几种方式来实现：
假设我们有以下文档集合： { &#34;_id&#34;: 1, &#34;scores&#34;: [90, 80, 70, 85] }, { &#34;_id&#34;: 2, &#34;scores&#34;: [60, 75, 85, 90] } 方法 1：使用 $avg 操作符 MongoDB 的聚合框架允许在管道中使用 $avg 操作符来计算某个数组的平均值。为了计算数组 scores 的平均值，我们需要先将数组元素展开（使用 $unwind），然后计算平均值。
聚合管道示例： db.collection.aggregate([ { $project: { averageScore: { $avg: &#34;$scores&#34; } } } ]) 解释： $project：用于指定输出的字段，在这里我们指定了一个新字段 averageScore。 $avg：用于计算指定字段的平均值。在这里，我们应用 $avg 操作符来计算 scores 数组的平均值。 方法 2：使用 $unwind 与 $group 来求平均值 如果你想更细粒度地处理数组中的元素，可以使用 $unwind 来展平数组，然后使用 $group 来求数组的平均值。
聚合管道示例： db.collection.aggregate([ { $unwind: &#34;$scores&#34; }, { $group: { _id: null, averageScore: { $avg: &#34;$scores&#34; } } } ]) 解释： $unwind：将 scores 数组中的每个元素展平为单独的文档。每个文档将包含一个数组元素。 $group：将所有展平后的文档组合在一起，并使用 $avg 来计算这些文档中 scores 字段的平均值。 这个方法适用于当你希望对数组中的所有元素进行处理并计算平均值的情况。
方法 3：直接计算字段的平均值 如果数组字段本身已经包含了所有的数值，且你只想计算这个数组字段的平均值，而不是数组中的每个元素，可以直接在 aggregate 阶段中计算平均值：
示例： db.collection.aggregate([ { $project: { averageScore: { $avg: &#34;$scores&#34; } } } ]) 总结： $avg 用于计算一个数值字段的平均值，可以直接在聚合管道中对数组字段进行操作。 $unwind + $group 适用于需要将数组元素分开处理，并求所有元素的平均值。 根据需求选择适合的方法，通常情况下，直接使用 $avg 对数组字段求平均值最为简单和高效。
52 Write a MongoDB query to find the highest score for each restaurant.
这里用到了 $group阶段的$max操作
db.restaurants.aggregate([{ $unwind: &#34;$grades&#34; }, { $group: { _id: &#34;$name&#34;, highest_score: { $max: &#34;$grades.score&#34; } } } ]) 53 Write a MongoDB query to find the lowest score for each restaurant.
和上一个题目一样，用$min
db.restaurants.aggregate([{ $unwind: &#34;$grades&#34; }, { $group: { _id: &#34;$name&#34;, lowest_score: { $min: &#34;$grades.score&#34; } } } ]) 54 Write a MongoDB query to find the count of restaurants in each borough.
用到了count
db.restaurants.aggregate([{ $group: { _id: &#34;$borough&#34;, count: { $sum: 1 } } }]) 55 Write a MongoDB query to find the count of restaurants for each cuisine.
只是用到了$sum
db.restaurants.aggregate([{ $group: { _id: &#34;$cuisine&#34;, count: { $sum: 1 } } }]) 56 如何按两个值进行分组 db.restaurants.aggregate([{ $group: { _id: { cuisine: &#34;$cuisine&#34;, borough: &#34;$borough&#34; }, count: { $sum: 1 } } }]) 57 多阶段配合 Write a MongoDB query to find the count of restaurants that received a grade of &lsquo;A&rsquo; for each cuisine.
多阶段
unwind match group db.restaurants.aggregate([ { $unwind: &#34;$grades&#34; }, { $match: { &#34;grades.grade&#34;: &#34;A&#34; } }, { $group: { _id: &#34;$cuisine&#34;, count: { $sum: 1 } } } ]) 58 同上 Write a MongoDB query to find the count of restaurants that received a grade of &lsquo;A&rsquo; for each borough.
db.restaurants.aggregate([ { $unwind: &#34;$grades&#34; }, { $match: { &#34;grades.grade&#34;: &#34;A&#34; } }, { $group: { _id: &#34;$borough&#34;, count: { $sum: 1 } } } ]) 59 Write a MongoDB query to find the count of restaurants that received a grade of &lsquo;A&rsquo; for each cuisine and borough.
聚合确实能达到
这里没有unwind
db.restaurants.aggregate([ { $match: { &#34;grades.grade&#34;: &#34;A&#34; } }, { $group: { _id: { cuisine: &#34;$cuisine&#34;, borough: &#34;$borough&#34; }, count: { $sum: 1 } } }, { $sort: { count: -1 } } ]); 60 Write a MongoDB query to find the number of restaurants that have been graded in each month of the year.
问一年中，每个月分评级的restaurants分别有多少个,那显然要$group
db.restaurants.aggregate([ { $unwind: &#34;$grades&#34; }, { $project: { month: { $month: { $toDate: &#34;$grades.date&#34; } }, year: { $year: { $toDate: &#34;$grades.date&#34; } } } }, { $group: { _id: { month: &#34;$month&#34;, year: &#34;$year&#34; }, count: { $sum: 1 } } }, { $sort: { &#34;_id.year&#34;: 1, &#34;_id.month&#34;: 1 } } ]); 61-66 平均分,最高低分 上面求过了
67 Write a MongoDB query to find the name and address of the restaurants that received a grade of &lsquo;A&rsquo; on a specific date
查询一个array里满足特定条件的。
db.restaurants.find( { &#34;grades&#34;: { &#34;$elemMatch&#34;: { &#34;date&#34;: { &#34;$eq&#34;: ISODate(&#34;2013-07-22T00:00:00Z&#34;) }, &#34;grade&#34;: { &#34;$eq&#34;: &#34;A&#34; } } } }, { &#34;name&#34;: 1, &#34;address&#34;: 1, &#34;_id&#34;: 0 } ) 68 Write a MongoDB query to find the name and address of the restaurants that received a grade of &lsquo;B&rsquo; or &lsquo;C&rsquo; on a specific date.
db.restaurants.find( { &#34;grades&#34;: { $elemMatch: { &#34;date&#34;: ISODate(&#34;2013-04-05&#34;), &#34;grade&#34;: { $in: [ &#34;B&#34;, &#34;C&#34; ] } } } }, { &#34;name&#34;: 1, &#34;address&#34;: 1 } ) 69 Write a MongoDB query to find the name and address of the restaurants that have at least one &lsquo;A&rsquo; grade and one &lsquo;B&rsquo; grade.
啊！ 查询数组里： 至少含有一个A，且至少含有一个B ,\\exits A in arr \\and \\exits B in arr
70 Write a MongoDB query to find the name and address of the restaurants that have at least one &lsquo;A&rsquo; grade and no &lsquo;B&rsquo; grades.
one A no B.两个条件同时成立
no b -&gt; not exits b in Arr -&gt; {$not : { &quot;grades.score&quot; : 'A'}
和我想的差不多
db.restaurants.find({ $and: [ { &#34;grades.grade&#34;: &#34;A&#34; }, { &#34;grades.grade&#34;: { $not: { $eq: &#34;B&#34; } } } ] }, { name: 1, address: 1, _id: 0 }) 71 Write a MongoDB query to find the name ,address and grades of the restaurants that have at least one &lsquo;A&rsquo; grade and no &lsquo;C&rsquo; grades.
同上
db.restaurants.find({ $and: [ { &#34;grades.grade&#34;: &#34;A&#34; }, { &#34;grades.grade&#34;: { $not: { $eq: &#34;C&#34; } } } ] }, { name: 1, address: 1, &#34;grades.grade&#34;:1, _id: 0 }) 72 Write a MongoDB query to find the name, address, and grades of the restaurants that have at least one &lsquo;A&rsquo; grade, no &lsquo;B&rsquo; grades, and no &lsquo;C&rsquo; grades.
同上
db.restaurants.find({ $and: [ { &#34;grades.grade&#34;: &#34;A&#34; }, { &#34;grades.grade&#34;: { $not: { $eq: &#34;B&#34; } } }, { &#34;grades.grade&#34;: { $not: { $eq: &#34;C&#34; } } } ] }, { name: 1, address: 1, &#34;grades.grade&#34;:1, _id: 0 }) 73 Write a MongoDB query to find the name and address of the restaurants that have the word &lsquo;coffee&rsquo; in their name
正则
db.restaurants.find({ name: { $regex: /coffee/i } }, { name: 1, address: 1 }) 74 Write a MongoDB query to find the name and address of the restaurants that have a zipcode that starts with &lsquo;10&rsquo;.
这里我觉得官方给的答案不对。
75 Write a MongoDB query to find the name and address of the restaurants that have a cuisine that starts with the letter &lsquo;B&rsquo;.
db.restaurants.find( { &#34;cuisine&#34;: { $regex: /^B/ } }, { &#34;name&#34;: 1, &#34;address&#34;: 1, &#34;cuisine&#34; : 1, &#34;_id&#34;: 0 } ) 76 77 正则 没有什么好写的
78 找最大值，那就需要排序
db.restaurants.aggregate([ {$unwind: &#34;$grades&#34;}, {$group: { _id: &#34;$restaurant_id&#34;, avgScore: {$avg: &#34;$grades.score&#34;} }}, {$sort: {avgScore: -1}}, {$limit: 1}, {$project: {_id: 1, avgScore: 1}} ]) 79 找最大的值A的那些restaurants的id，用到聚合
db.restaurants.aggregate([ {$unwind: &#34;$grades&#34;}, {$match: {&#34;grades.grade&#34;: &#34;A&#34;}}, {$group: { _id: &#34;$restaurant_id&#34;, count: {$sum: 1} }}, {$sort: {count: -1}}, {$group: { _id: &#34;$count&#34;, restaurants: {$push: &#34;$_id&#34;} }}, {$sort: {_id: -1}}, {$limit: 1}, {$project: {restaurants: 1}} ]) 80 Write a MongoDB query to find the cuisine type that is most likely to receive a &lsquo;C&rsquo; grade.
哪个区域的C最多,用到了聚合
db.restaurants.aggregate([ {$unwind: &#34;$grades&#34;}, {$match: {&#34;grades.grade&#34;: &#34;C&#34;}}, {$group: {_id: &#34;$cuisine&#34;, count: {$sum: 1}}}, {$sort: {count: -1}} ]) 81 Write a MongoDB query to find the restaurant that has the highest average score for thecuisine &ldquo;Turkish&rdquo;.
聚合。
82 Write a MongoDB query to find the restaurants that achieved the highest total score.
连续的聚合,聚合就是一种管道。
db.restaurants.aggregate([ { $unwind: &#34;$grades&#34; }, { $group: { _id: &#34;$name&#34;, totalScore: { $sum: &#34;$grades.score&#34; } }}, { $sort: { totalScore: -1 } }, { $group: { _id: &#34;$totalScore&#34;, restaurants: { $push: &#34;$_id&#34; } }}, { $sort: { _id: -1 } }, { $limit: 1 }, { $unwind: &#34;$restaurants&#34; }, { $group: { _id: &#34;$_id&#34;, restaurants: { $push: &#34;$restaurants&#34; } }} ]) 83 `,url:"https://hugo-dead-simple.netlify.com/mongodb/exercise4/"},"https://hugo-dead-simple.netlify.com/tags/querying/":{title:"Querying",tags:[],content:"",url:"https://hugo-dead-simple.netlify.com/tags/querying/"},"https://hugo-dead-simple.netlify.com/tags/":{title:"Tags",tags:[],content:"",url:"https://hugo-dead-simple.netlify.com/tags/"},"https://hugo-dead-simple.netlify.com/":{title:"首页",tags:[],content:` 这里是rainboy写的文章,所在的GitHub仓库
`,url:"https://hugo-dead-simple.netlify.com/"},"https://hugo-dead-simple.netlify.com/blog/":{title:"Blogs",tags:[],content:"",url:"https://hugo-dead-simple.netlify.com/blog/"},"https://hugo-dead-simple.netlify.com/blog/newnew/":{title:"Newnew",tags:[],content:`test git action webhook
`,url:"https://hugo-dead-simple.netlify.com/blog/newnew/"},"https://hugo-dead-simple.netlify.com/blog/hugo%E8%87%AA%E5%8A%A8%E5%8F%91%E5%B8%83/":{title:"Hugo自动发布",tags:[],content:`自动deploy blog 到github 参考
https://letere-gzj.github.io/hugo-stack/p/hugo/custom-blog/#3-github%E9%83%A8%E7%BD%B2 对应的视频教程: https://www.bilibili.com/video/BV1bovfeaEtQ 另一个 可以 发布blog到vps服务器 下面是新另外一个blog
本文由 简悦 SimpRead 转码， 原文地址 blog.wjhwjhn.com
背景 我一直计划迁移我的博客，一方面是认为之前主题的代码展示能力不强，文章的信息密度低，不适宜于技术内容的展示；另一方面，我曾认为极为安全的 Typecho，在 2023 年 6 月爆出了 XSS 漏洞，这加剧了我迁移的紧迫性。
注意
本文最后更新于 2024-02-13，文中内容可能已过时。
背景 我一直计划迁移我的博客，一方面是认为之前主题的代码展示能力不强，文章的信息密度低，不适宜于技术内容的展示；另一方面，我曾认为极为安全的 Typecho，在 2023 年 6 月爆出了 XSS 漏洞，这加剧了我迁移的紧迫性。鉴于此，我早就转向一款既美观又实用的静态博客平台——我选择了 Hugo，并选用了 FixIt 主题。恰逢过年，我拥有了许多碎片化的时间，这成为了我迁移博客的绝佳时机。
问题和解决方案 在迁移博客的过程中，我遇到了一系列问题。为了帮助同样面对这些挑战的读者，我在下面详细记录了我所面临的问题以及我采取的解决措施，希望这些经验能为您提供实际的帮助和指引。
警告
在迁移之前，请务必备份原有博客的文件和数据库数据，以防意外发生。
文章迁移 文章内容：文章内容储存在 typecho_contents 表的 text 字段中，提取比较容易，只需要去除 &lt;!--markdown--&gt; 标记即可，原先编写文章时就使用的是 markdown，所以直接创建文件即可，不过在这个过程中也遇到了不少问题 在我刚建立这个博客时，因为对 markdown 语法的不熟悉，导致以前的很多文章使用了 markdown 的方言。这些文章，在 Typecho 中显示正常，但是在 Hugo 中就出现了排版错误，好在有问题的文章不是很多，这里手动编辑了一下； 在 Hugo 中，文章的元信息（文章创建时间、文章类别、文章标题等…）都内嵌文章开头的 yaml 元信息中，这些信息需要从 Typecho 的数据库中提取并生成，例如 typecho_contents 表的 created 、modified 、title 字段； 原先的 Typecho 的 typecho_contents 表的 status 字段，如果是非 public 的文章，则设置 hiddenFromHomePage: true、hiddenFromSearch: true、hiddenFromRss: true、hiddenFromRelated: true 以及 password: {password} 密码字段，由主题进行加密处理。 原博客链接跳转 问题：原博客的链接是使用 /archives/{cid}/ 这种形式的，而新博客的链接是使用 /posts/{name} 这种形式的； 解决方案：利用文章元信息中的 aliases 字段来生成一个额外的别名链接。 评论和阅读量迁移 使用了 Twikoo 的评论系统，并解决了链接转换问题
Twikoo 的评论系统运行在 docker 设备中，并且映射到 8099 端口。为了安全性，我使用 ufw 将此端口设置为 deny，但发现无效，在 xianyu 的帮助下 (Orz)，使用了 ufw-docker，并成功解决； 因为 Twikoo 原生只支持使用 http，而我的博客使用的是 https，导致 twikoo 被 block。这里使用了反向代理来解决，设置了 https://blog.wjhwjhn.com/twikoo 代理到 http://localhost:8099 ； 阅读量是我在数据库中新增的 viewsNum 字段，我进行了导出生成，并转化为 Twikoo 的数据格式； 在评论和阅读量中需要提供文章的地址和标题，而在数据库中的都是先前的地址和标题。这里编写了 Python 脚本，逻辑如下 在新版博客中，去访问原来的路径下访问 html 文件（通过 aliases 字段生成的跳转文件），并使用正则（meta http-equiv=&quot;refresh&quot; content=&quot;0; url=http://[^/]+(/[^&quot;]+)&quot;）取出更新后的地址。 前往新版博客的地址下使用正则（&lt;title&gt;([^&lt;]+)&lt;/title&gt;）取出标题。 图片链接修复 让 ChatGPT 编写正则，提取出图片链接，从原来的图片链接中下载到本地，并替换原有链接
发现以前有部分旧文章的图片使用的是 http，导致图片无法访问，编写了 SQL 语句进行了替换 UPDATE typecho_contents SET text = REPLACE(text, 'http://blog.wjhwjhn', 'https://blog.wjhwjhn');。 发现以前有部分图片无法访问到：之前有过一段时间的博客文章编写是在石墨上的，而石墨的导出 markdown 功能也经过两次的转变 我最早接触的时候，石墨的导出功能是可以直接导出文章内的图片的，并且使用了石墨的图片储存服务链接； 估计后来石墨发现盗链的人过多，于是对访问来源做了检测，导致了我当时有大量的博客图片无法访问。我编写了一个插件，在导入时对文章内外链图片进行检测，如果存在外链图片，则下载到本地并替换链接，具体内容查看 博客外链图片已恢复 这篇文章； 再后面文章内图片使用 base64 进行编码嵌入在 markdown 文件中，但如果图片过大，markdown 文件过大，甚至无法在 Typecho 中储存。因此我也就不用石墨写文章了，通常会在本地 (使用本地图床) 写好文章，然后通过插件自动下载图床图片并修正到本地链接； 插件的鲁棒性不佳，存在下载失败的情况，不过好在下载失败的情况不多，我手动补了几张图片就解决了。 markdown 内图片链接提取，一般分为两种形式，都是使用正则来匹配 直接嵌入的图片![{text}]({url})，匹配正则：!\\[.*?\\]\\((.*?)\\)； 在文章底部使用 [{id}]:{url} 定义了一个脚注或引用链接，在使用时使用 ![{text}][{id}] 来引用，匹配正则：\\[\\d+\\]:\\s*(.*?)\\s*(?=&quot;#|$)。 GitHub Action 警告
为确保与您的服务器配置、仓库路径和特定需求相匹配，请适当修改以下代码段。避免直接复制粘贴，以预防潜在的兼容性问题或配置错误。
在过去的博客中，发布文章仅需在后台编辑后直接发送，便可立即在页面上看到效果。然而，自从转换到静态博客平台后，原本简洁的发布流程变得复杂。经过参考众多文章与资料，我目前采用了 GitHub Action 来简化这一流程。
新增文章流程 在本地操作 Hugo 新增文章，并使用 git 进行管理，并 push 到 GitHub 上； GitHub Action 检测到 push 并自动执行编译，编译后的页面结果存放在 gh-pages 分支中； 编译完毕后，GitHub Action 使用 Webhook 通知博客服务器来 GitHub 上拉取 gh-pages 的博客数据。 因为我的 GitHub 仓库是私有的，所以还需要把博客服务器的 SSH keys 添加到 GitHub，才能够拉取私有仓库。
GitHub Action 代码流程 配置解读
当 master 分支被 push 时自动执行； 运行在 Ubuntu-22.04 的环境上； 使用 Hugo 最新扩展版对博客源文件进行编译； 将编译后的 public 文件夹部署到 gh-pages 分支上； 通过 Webhook 来通知博客服务器来同步最新的静态页面数据。 name: GitHub Pages on: push: branches: - master # Set a branch to deploy pull_request: jobs: deploy: runs-on: ubuntu-22.04 concurrency: group: \${{ github.workflow }}-\${{ github.ref }} steps: - uses: actions/checkout@v4 with: submodules: true # Fetch Hugo themes (true OR recursive) fetch-depth: 0 # Fetch all history for .GitInfo and .Lastmod - name: Setup Hugo uses: peaceiris/actions-hugo@v2 with: hugo-version: &#39;latest&#39; extended: true - name: Build run: hugo --minify - name: Deploy uses: peaceiris/actions-gh-pages@v3 if: github.ref == &#39;refs/heads/master&#39; with: github_token: \${{ secrets.GH_TOKEN }} publish_dir: ./public - name: Update Blog Server uses: distributhor/workflow-webhook@v1 env: webhook_url: \${{ secrets.WEBHOOK_URL }} webhook_secret: \${{ secrets.WEBHOOK_SECRET }} 实际效果展示
Webhook 执行脚本 #!/bin/bash # Start of the script echo &#34;$(date &#34;+%Y-%m-%d %H:%M:%S&#34;) Run&#34; # Define variables gitPath=&#34;/www/wwwroot/newblog&#34; gitSSH=&#34;git@github.com:wjhwjhn/blog.git&#34; echo &#34;Web site path: $gitPath&#34; # Check if the directory exists if [ -d &#34;$gitPath&#34; ]; then # Attempt to enter the directory cd &#34;$gitPath&#34; || { echo &#34;Failed to enter directory $gitPath&#34;; exit 1; } echo &#34;------&#34; # Check if .git needs to be cloned if [ ! -d &#34;.git&#34; ]; then echo &#34;Cloning git into this directory&#34; if git clone -b gh-pages &#34;$gitSSH&#34; gittemp &amp;&amp; mv gittemp/.git . &amp;&amp; rm -rf gittemp; then echo &#34;Clone successful&#34; else echo &#34;Clone failed&#34; exit 1 fi fi # Update the git repository if git reset --hard gh-pages &amp;&amp; git pull; then echo &#34;Update successful&#34; else echo &#34;Update failed&#34; exit 1 fi # Change ownership chown -R www:www &#34;$gitPath&#34; echo &#34;Finish&#34; else echo &#34;The project path does not exist&#34; echo &#34;Finish&#34; fi Typora 图片设置 Typora 支持便捷地在本地保存文件。但是如果设置不当，它可能无法兼容 Hugo 的图片存储方式，这里对 Typora 的配置做了以下调整
格式 -&gt; 图像 -&gt; 设置图片根目录，设置目录为 Hugo 源文件下的 static 文件夹
偏好设置 -&gt; 图像 -&gt; 插入图片处设置路径为 Hugo 源文件下的 static\\images\\ 文件夹
设置完毕后，在 Typora 中 Ctrl + V 粘贴图片就会自动以 /images/xxx.png 的链接呈现，并把图片保存在 static\\images\\ 文件夹，这个图片链接形式在 Typora 中和 Hugo 博客中都可以正常浏览。
总结 此次迁移历时三天，过程中虽然遇到了不少挑战，但也收获颇丰。通过提出问题、构思解决方案，以及运用编程技术解决实际问题的过程，为我带来了极大的满足感。
四年前，我建立了这个博客，那时对 Linux 的操作感到极度畏惧，我的理解也仅限于书本知识。在过去的四年中，我对 Linux（尤其是 Ubuntu）的了解和熟悉程度有了显著提高，逐渐体会到了类 Unix 系统的独特魅力。与此同时，我的云服务器也从最初以 Windows 系统为主、Linux 系统为辅，转变为全面采用 Linux 系统。
现在，回顾起我当初配置的服务器，我意识到了许多安全上的疏漏，同样，重新审视我早期的文章时，我也意识到了当时的视野局限和思维的稚嫩。我相信，四年后的自己再回看今日所做，可能会对某些决定感到可笑或有所遗憾。然而，我认为这正体现了人生的一环——持续学习，回望过往，对曾经的自己会心一笑。
`,url:"https://hugo-dead-simple.netlify.com/blog/hugo%E8%87%AA%E5%8A%A8%E5%8F%91%E5%B8%83/"},"https://hugo-dead-simple.netlify.com/posts/my-first-post/":{title:"My First Post",tags:[],content:`hdsdf
`,url:"https://hugo-dead-simple.netlify.com/posts/my-first-post/"},"https://hugo-dead-simple.netlify.com/posts/":{title:"Posts",tags:[],content:"",url:"https://hugo-dead-simple.netlify.com/posts/"},"https://hugo-dead-simple.netlify.com/blog/helloworld/":{title:"Helloworld",tags:[],content:`hello world write by Rainboy
`,url:"https://hugo-dead-simple.netlify.com/blog/helloworld/"},"https://hugo-dead-simple.netlify.com/group_theory/1%E7%AD%89%E4%BB%B7%E5%85%B3%E7%B3%BB%E4%B8%8E%E9%9B%86%E5%90%88%E7%9A%84%E5%88%86%E7%B1%BB/":{title:"1等价关系与集合的分类",tags:[],content:`对应视频的p1-p6
定义二元关系RRR 等价关系 反身性：∀a→aRa\\forall a \\to aRa∀a→aRa 对称性：aRb⇒bRaaRb \\Rightarrow bRaaRb⇒bRa 传递性：aRb∧bRc⇒aRcaRb \\land bRc \\Rightarrow aRcaRb∧bRc⇒aRc 等价类 定义：[a][a][a]表示所有与aaa等价的元素的集合 等价类是满足以下条件的集合：任意两个元素aaa和bbb都属于同一个等价类当且仅当aRbaRbaRb 公式定义: [a]={x∈S∣xRa}[a]= \\{ x \\in S | xRa \\}[a]={x∈S∣xRa} 类在这里的意思为:&ldquo;物以群分&rdquo;,分类的意思,等价类就是把满足等价关系的元素归为一类. 商集: SSS的全体等价类构成的集合,集合SSS在等价关系下的商集记作S/∽S / \\backsimS/∽ 集合的分类 定义：SSS是一个集合，如果存在一个等价关系RRR使得SSS的所有元素都可以划分为等价类，则称SSS为RRR的分类 如果非空集合SSS是它的某些两两不相交的非空子集的并,则称这些子集为集合SSS的一种分类(partition),其中每个子集称为集合SSS的一个类(class) 若集合SSS的子集族{Si∣i∈I}\\{S_i | i \\in I\\}{Si​∣i∈I}构成了S的一种分类当且仅当
S=⋃i∈ISiS = \\bigcup_{i \\in I} S_iS=⋃i∈I​Si​ Si∩Sj=∅S_i \\cap S_j = \\varnothingSi​∩Sj​=∅ (i.e., SiS_iSi​ and SjS_jSj​ are pairwise disjoint) 集合SSS的任何一种等价关系都确定了SSS的一种分类。
例题 例5 aRb⇔m∣a−b,∀a,b∈Z(1) aRb \\Leftrightarrow m \\mid a - b , \\forall a,b \\in \\mathbb{Z} \\tag 1 aRb⇔m∣a−b,∀a,b∈Z(1)证明1式是等价关系.也就是证明m∣a−bm | a -b m∣a−b是等价关系.
公式的含义解释: m是a与b差的因子,则说明a,b对于m同余.这两者是等价的.
下面证明这两者是等价关系.
设 A:a≡b(mod m)a \\equiv b (\\mod m)a≡b(modm), B: m∣a−bm \\mid a-bm∣a−b.
A→BA \\to BA→B,把a,b写成带余数除法的形式.
a=k1×m+rb=k2×m+ra−b=m(k1−k2)→m∣a−b a = k_1 \\times m + r \\\\ b = k_2 \\times m + r \\\\ a - b = m(k_1 - k_2) \\to m \\mid a - b a=k1​×m+rb=k2​×m+ra−b=m(k1​−k2​)→m∣a−b必要性证明完毕,证明充分性.
m∣a−b→a−b=k×m→a=b+k×m→amod m=(b+k×m)mod m→amod m=bmod m m \\mid a - b \\\\ \\to a -b = k \\times m \\\\ \\to a = b + k \\times m \\\\ \\to a \\mod m = (b+k \\times m) \\mod m \\\\ \\to a \\mod m = b \\mod m m∣a−b→a−b=k×m→a=b+k×m→amodm=(b+k×m)modm→amodm=bmodmqed;
证明自反性:
aRa⇔m∣a−a aRa \\Leftrightarrow m \\mid a - a aRa⇔m∣a−a显然成立.
证明对称性:
根据 m∣x→m∣−x m \\mid x \\to m \\mid -x m∣x→m∣−x那么
m∣a−b→m∣−(a−b)→m∣b−a m \\mid a - b \\to m \\mid -(a - b) \\to m \\mid b - a m∣a−b→m∣−(a−b)→m∣b−a证明传递性:
m∣a−b∧m∣b−c→m∣a−cm | a - b \\land m| b - c \\to m | a - cm∣a−b∧m∣b−c→m∣a−c
a=k1×m+rb=k2×m+rc=k3×m+r→a−c=k1×m+r−k3×m−r→m∣a−c a = k_1 \\times m + r \\\\ b = k_2 \\times m + r \\\\ c = k_3 \\times m + r \\\\ \\to a - c = k_1 \\times m + r - k_3 \\times m - r\\\\ \\to m \\mid a - c a=k1​×m+rb=k2​×m+rc=k3​×m+r→a−c=k1​×m+r−k3​×m−r→m∣a−c证明完毕
说明同余是一种等价关系.
书上又定义了什么叫做同余剩余类.
例9 这个见书.
课后题目 习题1. 试分别举出满足下列条件的关系： (1)有对称性，传递性，但无反身性； (2)有反身性，传递性，但无对称性； (3)有反身性，对称性，但无传递性. 解:设集合S={a,b,c}S = \\{a,b,c\\}S={a,b,c}
(1) ,R={(a,b),(b,a),(a,a),b,b}R = \\{(a,b),(b,a),(a,a),{b,b}\\}R={(a,b),(b,a),(a,a),b,b},因为没有(c,c)(c,c)(c,c)所以不满足反身性. (2) ,R={(a,a),(b,b),(c,c),(a,b)}R = \\{(a,a),(b,b),(c,c),(a,b)\\}R={(a,a),(b,b),(c,c),(a,b)},因为没有(b,a)(b,a)(b,a)所以不满足对称性. (3) ,R={(a,a),(b,b),(c,c),(a,b),(b,a),(c,a),(c,b)}R = \\{(a,a),(b,b),(c,c),(a,b),(b,a),(c,a),(c,b)\\}R={(a,a),(b,b),(c,c),(a,b),(b,a),(c,a),(c,b)},因为没有(a,c)(a,c)(a,c)所以不满足传递性. 习题2.找出下面证明中的错误： 有人断言，若S的关系R有对称性和传递性，则必有反身性.这晨因 为，对任意的a∈S,由对称性，如果aRb,则bRa.再由传递性，得aRa,所 以R有反身性.
关键在于a∈Sa \\in Sa∈S，但如果aaa就没有自己的关系呢?例如习题1的(1),就没有c的关系,所以不能说R有反身性. 因为不一定有cRbcRbcRb这个关系.
`,url:"https://hugo-dead-simple.netlify.com/group_theory/1%E7%AD%89%E4%BB%B7%E5%85%B3%E7%B3%BB%E4%B8%8E%E9%9B%86%E5%90%88%E7%9A%84%E5%88%86%E7%B1%BB/"},"https://hugo-dead-simple.netlify.com/group_theory/":{title:"Group_theories",tags:[],content:"",url:"https://hugo-dead-simple.netlify.com/group_theory/"},"https://hugo-dead-simple.netlify.com/categories/":{title:"Categories",tags:[],content:"",url:"https://hugo-dead-simple.netlify.com/categories/"},"https://hugo-dead-simple.netlify.com/search/":{title:"Search Results",tags:[],content:"",url:"https://hugo-dead-simple.netlify.com/search/"}}</script><script defer src=/js/lunr.js></script><script defer src=/js/search.js></script><br><footer><script defer>document.addEventListener("keydown",function(e){if(document.activeElement.isContentEditable)return!1;if(document.activeElement.tagName=="INPUT")return!1;if(e.altKey||e.ctrlKey||e.shiftKey)return!1;var t=e.key;if(t==="h")e.preventDefault(),e.stopPropagation(),window.location.href="/";else if(t==="t")e.preventDefault(),e.stopPropagation(),window.location.href=`https://${location.hostname}/tags`;else if(t==="i"){e.preventDefault(),e.stopPropagation();const t=document.querySelectorAll("input");for(let e=0;e<t.length;e++)if(t[e].offsetParent!==null){t[e].selectionStart=t[e].selectionEnd=t[e].value.length,t[e].focus();break}}return!1})</script><script defer>function throttle(e,t){var n=Date.now();return function(){var s=Date.now();n+t-s<0&&(e(),n=s)}}function scrollHandler(){const e=Array.from(document.querySelectorAll("body h2, body h3"));function t(){for(var n,s,o,i=window.pageYOffset||document.documentElement.scrollTop,t=0;t<e.length;t++)s=e[t].getAttribute("id"),n=document.querySelector('nav ul li a[href="#'+s+'"]'),n&&n.classList.remove("active-toc");for(t=e.length-1;t>=0;t--)if(o=e[t].offsetTop,i>o-75&&(s=e[t].getAttribute("id"),n=document.querySelector('nav ul li a[href="#'+s+'"]'),n)){n.classList.add("active-toc");break}}window.addEventListener("scroll",throttle(t,200))}setTimeout(scrollHandler,100)</script><script defer>function addCopyButtonToCodeBlocks(){const e=document.querySelectorAll('code[class^="language-"]:not(.output):not([class*="language-console"])');e.forEach(e=>{const t=document.createElement("button");t.classList.add("copy-code-button"),t.innerHTML="copy",t.addEventListener("click",()=>{const s=e.querySelectorAll(".cl");let n="";s.forEach(e=>{n+=e.innerText}),navigator.clipboard.writeText(n),t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},1500)}),e.parentNode.before(t)})}setTimeout(function(){addCopyButtonToCodeBlocks()},100)</script></footer></body></html>