<!doctype html><html lang=zh-cn><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta http-equiv=cache-control content="max-age=0"><meta http-equiv=cache-control content="no-cache"><meta http-equiv=expires content="0"><meta http-equiv=expires content="Tue, 01 Jan 1980 1:00:00 GMT"><meta http-equiv=pragma content="no-cache"><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png }><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=manifest href=/site.webmanifest><meta name=theme-color media="(prefers-color-scheme: light)" content="#ffffff"><meta name=theme-color media="(prefers-color-scheme: dark)" content="#1b1b1b"><meta name=description content="Search Results"><script>(function(){const e=localStorage.getItem("theme")||(window.matchMedia("(prefers-color-scheme: dark)").matches?"dark":"light");document.documentElement.setAttribute("data-theme",e)})()</script><title>Search Results | Rainboy's Blog</title><style>:root{--background:#ffffff}@media(prefers-color-scheme:dark){:root{--background:#1b1b1b}}html{background-color:var(--background)}body{background-color:var(--background)}</style><link rel=stylesheet type=text/css href=/style.min.9e52618e081d7542403ff6356f894d993b93e26eb37d3f072c70cd92f0c439ab.css media=all><link rel=stylesheet href=/grid.css><link href="https://fonts.font.im/css?family=Roboto+Mono" rel=stylesheet><style>body,.heti,.heti--sans{font-family:roboto mono,monospace,times new roman,times,heti song,serif,apple color emoji,segoe ui emoji,segoe ui symbol}</style></head><body><nav><ul class=menu><li><a tabindex=-1 class=menu-link href=/><u>H</u>ome</a></li><li><a tabindex=-1 class=menu-link href=/tags><u>T</u>ags</a></li><li><span style=cursor:pointer id=theme-switcher class=menu-link type=button><svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-moon h-4 w-4"><path d="M12 3a6 6 0 009 9 9 9 0 11-9-9z"/></svg></span></li></ul></nav><main id=main class=post><header><h1 id=search-title>Search Results</h1></header><form id=search-form action=/search method=get><label hidden for=search-input>Search site</label>
<input tabindex=-1 type=text id=search-input name=query placeholder="search [i] ..."></form><ul id=search-results></ul></main><script>window.store={"https://hugo-dead-simple.netlify.com/blog/":{title:"Blogs",tags:[],content:"",url:"https://hugo-dead-simple.netlify.com/blog/"},"https://hugo-dead-simple.netlify.com/blog/github%E6%97%A0%E6%B3%95%E6%8E%A8%E9%80%81/":{title:"Github无法推送",tags:[],content:`2025-09-09,我发现我的电脑 git 无法推送,
1ssh -vvv -T git@github.com 卡死
神奇的是,并不是因为https无法推送,而是ssh无法推送,这是我第一次遇到这种情况.
1╭─rainboy@y9000x ~ 2╰─$ nslookup github.com 119.119.119.119 3Server: 119.119.119.119 4Address: 119.119.119.119#53 5 6Non-authoritative answer: 7Name: github.com 8Address: 20.205.243.166 1ssh -T git@20.205.243.166 卡死
使用在线 dns check : https://dnschecker.org/#A/github.com
得到ip : 140.82.114.3
1ssh -T git@140.82.114.3 2 3 4The authenticity of host &#39;140.82.114.3 (140.82.114.3)&#39; can&#39;t be established. 5ED25519 key fingerprint is SHA256:+DiY3wvvV6TuJJhbpZisF/zLDA0zPMSvHdkr4UvCOqU. 6This host key is known by the following other names/addresses: 7 ~/.ssh/known_hosts:59: github.com 8 ~/.ssh/known_hosts:98: [ssh.github.com]:443 9 ~/.ssh/known_hosts:99: 140.82.114.4 10Are you sure you want to continue connecting (yes/no/[fingerprint])? yes 11Warning: Permanently added &#39;140.82.114.3&#39; (ED25519) to the list of known hosts. 12Hi Rainboylvx! You&#39;ve successfully authenticated, but GitHub does not provide shell access. 成功了 !?
1ssh -T -p 443 git@ssh.github.com 也能成功! 真是神奇
不得已,我修改了~/.ssh/config 文件
1Host github.com 2 Hostname ssh.github.com 3 Port 443 4 User git 暂时先使用443端口来访问 github
`,url:"https://hugo-dead-simple.netlify.com/blog/github%E6%97%A0%E6%B3%95%E6%8E%A8%E9%80%81/"},"https://hugo-dead-simple.netlify.com/books/":{title:"Books",tags:[],content:"",url:"https://hugo-dead-simple.netlify.com/books/"},"https://hugo-dead-simple.netlify.com/books/learn_you_haskell/chapter_1/":{title:"chapter 1 Introduction",tags:[],content:`这篇文章是《Learn You a Haskell for Great Good!》教程的引言，主要内容可以总结为以下几点：
教程目标：本教程主要面向有命令式编程（如 C++, Java, Python）经验，但初次接触函数式编程的开发者。作者建议通过阅读多种资料来学习Haskell，因为它起初可能感觉很奇怪，但一旦“开窍”就会变得容易。
Haskell的核心特性：
纯函数式 (Purely Functional)：你不是告诉计算机“如何做”，而是定义“是什么”。变量一旦赋值就不可改变，函数没有副作用，这保证了同样的输入总能得到同样的输出。 惰性求值 (Lazy)：代码只在真正需要结果时才被执行，这使得程序更高效，并能轻松处理无限大的数据结构。 静态类型 (Statically Typed)：编译器在编译阶段就能捕捉大量类型错误。同时，其强大的类型推导系统意味着你无需为每个变量都显式声明类型。 优雅简洁 (Elegant and Concise)：代码通常比等效的命令式代码更短，更易于维护。 如何开始学习：
你需要一个文本编辑器和Haskell编译器（GHC）。 推荐使用 GHCup 这个工具来安装所需环境。 学习时，可以使用 ghci 这个交互式环境来加载 .hs 文件并实时测试函数，这样边学边练效率更高。 `,url:"https://hugo-dead-simple.netlify.com/books/learn_you_haskell/chapter_1/"},"https://hugo-dead-simple.netlify.com/books/learn_you_haskell/chapter_2/":{title:"chapter 2 Starting Out",tags:[],content:"",url:"https://hugo-dead-simple.netlify.com/books/learn_you_haskell/chapter_2/"},"https://hugo-dead-simple.netlify.com/books/learn_you_haskell/":{title:"learn you haskell for great good",tags:[],content:`资源 中文版 https://learnyouahaskell.mno2.org/zh-cn 英文版 https://learnyouahaskell.com/chapters archlinux 参考 这里 下安装与编译
1sudo pacman -S ghc 2cat &gt; 1.hs &lt;&lt; EOF 3main = putStrLn &#34;Hello, world!&#34; 4EOF 5ghc -dynamic 1.hs 6./1 最简单的方法可以是用 在线haskell: https://play.haskell.org/
目录 Introduction Starting Out `,url:"https://hugo-dead-simple.netlify.com/books/learn_you_haskell/"},"https://hugo-dead-simple.netlify.com/blog/latex%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F%E6%89%8B%E5%86%8C/":{title:"Latex数学公式手册",tags:[],content:`前言 准备整理一下我所使用的Latex数学公式(其实我大部分时间都在使用katex )
下面列举一些有用的资源
katex document https://katex.org/docs/api LaTeX公式手册(全网最全) - 樱花赞 - 博客园 这个显示有问题，有时间的话，我会 fork 一下修改 https://1024th.github.io/MathJax_Tutorial_CN/#/quickstart 在线latex公式编辑器 https://www.latexlive.com/ Latex 公式手册 转载自: https://blog.csdn.net/Yushan_Ji/article/details/134322574
基本符号 小写希腊字母 注：部分希腊字母在数学公式中常以变量形式出现，例如 ϵ\\epsilonϵ 在数学中一般写法为 ε\\varepsilonε，ϕ\\phiϕ 在数学中通常写作 φ\\varphiφ
符号 语法 符号 语法 符号 语法 α\\alphaα \\alpha β\\betaβ \\beta γ\\gammaγ \\gamma θ\\thetaθ \\theta ε\\varepsilonε \\varepsilon δ\\deltaδ \\delta μ\\muμ \\mu ν\\nuν \\nu η\\etaη \\eta ζ\\zetaζ \\zeta λ\\lambdaλ \\lambda ψ\\psiψ \\psi σ\\sigmaσ \\sigma ξ\\xiξ \\xi τ\\tauτ \\tau ϕ\\phiϕ \\phi φ\\varphiφ \\varphi ρ\\rhoρ \\rho χ\\chiχ \\chi ω\\omegaω \\omega π\\piπ \\pi 大写希腊字母 大写希腊字母通常是小写希腊字母的 LATEX 语法第一个字母改为大写，见下表
符号 语法 符号 语法 符号 语法 Σ\\SigmaΣ \\Sigma Π\\PiΠ \\Pi Δ\\DeltaΔ \\Delta Γ\\GammaΓ \\Gamma Ψ\\PsiΨ \\Psi Θ\\ThetaΘ \\Theta Λ\\LambdaΛ \\Lambda Ω\\OmegaΩ \\Omega Φ\\PhiΦ \\Phi Ξ\\XiΞ \\Xi 常用字体 默认的字体为 ABCdefABCdefABCdef，也就是 \\mathnormal{ABCdef}（当然，打公式的时候不需要加上这个 \\mathnormal，直接打字母就是这个效果）
字体 语法 字体 语法 ABCdef\\mathrm{ABCdef}ABCdef \\mathrm{ABCdef} ABCdef\\mathbf{ABCdef}ABCdef \\mathbf{ABCdef} ABCdef\\mathit{ABCdef}ABCdef \\mathit{ABCdef} ABCdef\\pmb{ABCdef}ABCdef \\pmb{ABCdef} ABCdef\\mathscr{ABCdef}ABCdef \\mathscr{ABCdef} ABCdef\\mathcal{ABCdef}ABCdef \\mathcal{ABCdef} ABCdef\\mathfrak{ABCdef}ABCdef \\mathfrak{ABCdef} ABCdef\\mathbb{ABCdef}ABCdef \\mathbb{ABCdef} 常见运算符 运算符 语法 运算符 语法 运算符 语法 +++ + −-− - ×\\times× \\times ±\\pm± \\pm ⋅\\cdot⋅ \\cdot ∗\\ast∗ \\ast ∪\\cup∪ \\cup ∩\\cap∩ \\cap ∘\\circ∘ \\circ ∨\\lor∨ \\lor 或 \\vee ∧\\land∧ \\land 或 \\wedge ¬\\lnot¬ \\lnot ⊕\\oplus⊕ \\oplus ⊖\\ominus⊖ \\ominus ⊗\\otimes⊗ \\otimes ⊙\\odot⊙ \\odot ⊘\\oslash⊘ \\oslash ∙\\bullet∙ \\bullet x\\sqrt{x}x​ \\sqrt{x} xn\\sqrt[n]{x}nx​ \\sqrt[n]{x} 大尺寸运算符 运算符 语法 运算符 语法 运算符 语法 ∑\\sum∑ \\sum ∏\\prod∏ \\prod ∫\\int∫ \\int ⋃\\bigcup⋃ \\bigcup ⋂\\bigcap⋂ \\bigcap ∮\\oint∮ \\oint ⋁\\bigvee⋁ \\bigvee ⋀\\bigwedge⋀ \\bigwedge ∬\\iint∬ \\iint ∐\\coprod∐ \\coprod ⨆\\bigsqcup⨆ \\bigsqcup ∯\\oiint∬​ \\oiint 常见关系符号 符号 语法 符号 语法 符号 语法 &lt;&lt;&lt; &lt; \\&gt; &gt; === = ≤\\leq≤ \\leq ≥\\geq≥ \\geq ≠\\neq= \\neq ≪\\ll≪ \\ll ≫\\gg≫ \\gg ≡\\equiv≡ \\equiv ⊂\\subset⊂ \\subset ⊃\\supset⊃ \\supset ≈\\approx≈ \\approx ⊆\\subseteq⊆ \\subseteq ⊇\\supseteq⊇ \\supseteq ∼\\sim∼ \\sim ∈\\in∈ \\in ∋\\ni∋ \\ni ∝\\propto∝ \\propto ⊢\\vdash⊢ \\vdash ⊣\\dashv⊣ \\dashv ⊨\\models⊨ \\models ∣\\mid∣ \\mid ∥\\parallel∥ \\parallel ⊥\\perp⊥ \\perp ∉\\notin∈/ \\notin ⋈\\Join⋈ \\Join ≁\\nsim≁ \\nsim ⊊\\subsetneq⊊ \\subsetneq ⊋\\supsetneq⊋ \\supsetneq 数学模式重音符 符号 语法 符号 语法 符号 语法 a^\\hat{a}a^ \\hat{a} aˉ\\bar{a}aˉ \\bar{a} a~\\tilde{a}a~ \\tilde{a} a⃗\\vec{a}a \\vec{a} a˙\\dot{a}a˙ \\dot{a} a¨\\ddot{a}a¨ \\ddot{a} abc^\\widehat{abc}abc \\widehat{abc} abc~\\widetilde{abc}abc \\widetilde{abc} abc‾\\overline{abc}abc \\overline{abc} 箭头 如果需要长箭头，只需要在语法前面加上 \\long，例如 \\longleftarrow 即为 ⟵\\longleftarrow⟵，如果加上 \\Long 则变为双线长箭头，例如 \\Longleftarrow 即为 ⟸\\Longleftarrow⟸
符号 语法 符号 语法 符号 语法 ←\\leftarrow← \\leftarrow →\\rightarrow→ \\rightarrow ↔\\leftrightarrow↔ \\leftrightarrow ⇐\\Leftarrow⇐ \\Leftarrow ⇒\\Rightarrow⇒ \\Rightarrow ⇔\\Leftrightarrow⇔ \\Leftrightarrow ↑\\uparrow↑ \\uparrow ↓\\downarrow↓ \\downarrow ↕\\updownarrow↕ \\updownarrow ⇑\\Uparrow⇑ \\Uparrow ⇓\\Downarrow⇓ \\Downarrow ⇕\\Updownarrow⇕ \\Updownarrow ↼\\leftharpoonup↼ \\leftharpoonup ↽\\leftharpoondown↽ \\leftharpoondown ⇀\\rightharpoonup⇀ \\rightharpoonup ⇁\\rightharpoondown⇁ \\rightharpoondown ⇌\\rightleftharpoons⇌ \\rightleftharpoons ⇋\\leftrightharpoons⇋ \\leftrightharpoons ⟺ \\iff⟺ \\iff ↦\\mapsto↦ \\mapsto 括号 括号 语法 括号 语法 括号 语法 ()()() () [][][] [] {} \\{\\} ⌊⌋\\lfloor\\rfloor⌊⌋ \\lfloor\\rfloor ⌈⌉\\lceil\\rceil⌈⌉ \\lceil\\rceil ⟨⟩\\langle\\rangle⟨⟩ \\langle\\rangle 大尺寸括号 括号 语法 括号 语法 ()\\left(\\right)() \\left(\\right) []\\left[ \\right][] \\left[\\right] x1x2…xn⏞n\\overbrace{x_1 x_2 \\ldots x_n}^{n}x1​x2​…xn​​n​ \\overbrace{x_1 x_2 \\ldots x_n}^{n} x1x2…xn⏟n\\underbrace{x_1 x_2 \\ldots x_n}_{n}nx1​x2​…xn​​​ \\underbrace{x_1 x_2 \\ldots x_n}_{n} 注：大尺寸的 () 和 [] 是可以根据公式的高度自动调节的，例如
1\\arg\\min_{\\theta} 2\\left[ 3 -\\sum_{i=1}^{n} 4 \\left[ 5 \\mathbf{y}^{(i)}\\ln(h_{\\theta}(\\mathbf{x}^{(i)})) + 6 (1-\\mathbf{y}^{(i)})\\ln(1-h_{\\theta}(\\mathbf{x}^{(i)})) 7 \\right] 8\\right] arg⁡min⁡θ[−∑i=1n[y(i)ln⁡(hθ(x(i)))+(1−y(i))ln⁡(1−hθ(x(i)))]] \\arg\\min_{\\theta} \\left[ -\\sum_{i=1}^{n} \\left[ \\mathbf{y}^{(i)}\\ln(h_{\\theta}(\\mathbf{x}^{(i)})) + (1-\\mathbf{y}^{(i)})\\ln(1-h_{\\theta}(\\mathbf{x}^{(i)})) \\right] \\right] argθmin​[−i=1∑n​[y(i)ln(hθ​(x(i)))+(1−y(i))ln(1−hθ​(x(i)))]]可以看出，括号高度可以框住整个公式。因此在这种大型的公式中，使用大尺寸括号视觉效果更美观。
其他常见符号 符号 语法 符号 语法 符号 语法 forall\\\\forallforall \\forall exists\\\\existsexists \\exist angle\\\\angleangle \\angle emptyset\\\\emptysetemptyset \\emptyset partial\\\\partialpartial \\partial infty\\\\inftyinfty \\infty ldots\\\\ldotsldots \\ldots cdots\\\\cdotscdots \\cdots dots\\\\dotsdots \\dots vdots\\\\vdotsvdots \\vdots ddots\\\\ddotsddots \\ddots prime\\\\primeprime \\prime because\\\\becausebecause \\because therefore\\\\thereforetherefore \\therefore Box\\\\BoxBox \\Box triangle\\\\triangletriangle \\triangle S\\\\SS \\S 数学公式写法 上下标 ^：上标 _：下标 例如:
\\sum_{i=1}^{n}X_n 表示 sum_i=1nX_n\\\\sum\\_{i=1}^{n}X\\_nsum_i=1nX_n \\int_{0}^{\\infty}x^2dx 表示 int_0inftyx2dx\\\\int\\_{0}^{\\\\infty}x^2dxint_0inftyx2dx \\prod_{i=1}^{n}X_n 表示 prod_i=1nX_n\\\\prod\\_{i=1}^{n}X\\_nprod_i=1nX_n 分数 使用 \\frac{}{} 即可，例如 \\frac{a}{b} 表示 fracab\\\\frac{a}{b}fracab
插入文字 使用 \\text，例如 \\text{hello,world!} 表示 texthello,world ⁣\\\\text{hello,world\\!}texthello,world
常见函数 函数 语法 函数 语法 函数 语法 log()\\\\log()log() \\log() ln()\\\\ln()ln() \\ln() lg()\\\\lg()lg() \\lg() max\\\\maxmax \\max min\\\\minmin \\min lim_xtoinfty\\\\lim\\_{x \\\\to \\\\infty}lim_xtoinfty \\lim_{x \\to \\infty} argmax_cinC\\\\arg\\\\max\\_{c \\\\in C}argmax_cinC \\arg\\max_{c \\in C} argmin_cinC\\\\arg\\\\min\\_{c \\\\in C}argmin_cinC \\arg\\min_{c \\in C} exp\\\\expexp \\exp 矩阵、行列式 &amp; 表示分隔元素，\\\\ 表示换行
1A= 2\\begin{pmatrix} 3a_{11} &amp; a_{12} \\\\ 4a_{21} &amp; a_{22} 5\\end{pmatrix} A=(a_11a_12a_21a_22)A= \\begin{pmatrix} a\\_{11} &amp; a\\_{12} \\\\ a\\_{21} &amp; a\\_{22} \\end{pmatrix} A=(a_11a_21​a_12a_22​)1A= 2\\begin{bmatrix} 3a_{11} &amp; a_{12} \\\\ 4a_{21} &amp; a_{22} 5\\end{bmatrix} A=[a_11a_12a_21a_22]A= \\begin{bmatrix} a\\_{11} &amp; a\\_{12} \\\\ a\\_{21} &amp; a\\_{22} \\end{bmatrix} A=[a_11a_21​a_12a_22​]1A= 2\\begin{Bmatrix} 3a_{11} &amp; a_{12} \\\\ 4a_{21} &amp; a_{22} 5\\end{Bmatrix} A={a_11a_12a_21a_22}A= \\begin{Bmatrix} a\\_{11} &amp; a\\_{12} \\\\ a\\_{21} &amp; a\\_{22} \\end{Bmatrix} A={a_11a_21​a_12a_22​}1A= 2\\begin{vmatrix} 3a_{11} &amp; a_{12} \\\\ 4a_{21} &amp; a_{22} 5\\end{vmatrix} A=∣a_11a_12a_21a_22∣A= \\begin{vmatrix} a\\_{11} &amp; a\\_{12} \\\\ a\\_{21} &amp; a\\_{22} \\end{vmatrix} A=​a_11a_21​a_12a_22​​1A= 2\\begin{Vmatrix} 3a_{11} &amp; a_{12} \\\\ 4a_{21} &amp; a_{22} 5\\end{Vmatrix} A=∥a_11a_12a_21a_22∥A= \\begin{Vmatrix} a\\_{11} &amp; a\\_{12} \\\\ a\\_{21} &amp; a\\_{22} \\end{Vmatrix} A=​a_11a_21​a_12a_22​​1A= 2\\begin{matrix} 3a_{11} &amp; a_{12} \\\\ 4a_{21} &amp; a_{22} 5\\end{matrix} A=a_11a_12a_21a_22A= \\begin{matrix} a\\_{11} &amp; a\\_{12} \\\\ a\\_{21} &amp; a\\_{22} \\end{matrix} A=a_11a_21​a_12a_22​多行公式对齐 使用 \\begin{split} \\end{split}，在需要对齐的地方添加 &amp; 符号，注意需要用 \\\\ 来换行。
例如：
1\\begin{split} 2L(\\theta) 3&amp;=	\\arg\\max_{\\theta}\\ln(P_{All})\\\\ 4&amp;=	\\arg\\max_{\\theta}\\ln\\prod_{i=1}^{n} 5 \\left[ 6 (h_{\\theta}(\\mathbf{x}^{(i)}))^{\\mathbf{y}^{(i)}}\\cdot 7 (1-h_{\\theta}(\\mathbf{x}^{(i)}))^{1-\\mathbf{y}^{(i)}} 8 \\right]\\\\ 9&amp;=	\\arg\\max_{\\theta}\\sum_{i=1}^{n} 10	\\left[ 11	\\mathbf{y}^{(i)}\\ln(h_{\\theta}(\\mathbf{x}^{(i)})) + 12	(1-\\mathbf{y}^{(i)})\\ln(1-h_{\\theta}(\\mathbf{x}^{(i)})) 13	\\right]\\\\ 14&amp;=	\\arg\\min_{\\theta} 15	\\left[ 16 -\\sum_{i=1}^{n} 17 \\left[ 18 \\mathbf{y}^{(i)}\\ln(h_{\\theta}(\\mathbf{x}^{(i)})) + 19 (1-\\mathbf{y}^{(i)})\\ln(1-h_{\\theta}(\\mathbf{x}^{(i)})) 20 \\right] 21	\\right]\\\\ 22&amp;=	\\arg\\min_{\\theta}\\mathscr{l}(\\theta) 23\\end{split} L(θ)=arg⁡max⁡θln⁡(PAll)=arg⁡max⁡θln⁡∏i=1n[(hθ(x(i)))y(i)⋅(1−hθ(x(i)))1−y(i)]=arg⁡max⁡θ∑i=1n[y(i)ln⁡(hθ(x(i)))+(1−y(i))ln⁡(1−hθ(x(i)))]=arg⁡min⁡θ[−∑i=1n[y(i)ln⁡(hθ(x(i)))+(1−y(i))ln⁡(1−hθ(x(i)))]]=arg⁡min⁡θl(θ) \\begin{split} L(\\theta) &amp;=	\\arg\\max_{\\theta}\\ln(P_{All})\\\\ &amp;=	\\arg\\max_{\\theta}\\ln\\prod_{i=1}^{n} \\left[ (h_{\\theta}(\\mathbf{x}^{(i)}))^{\\mathbf{y}^{(i)}}\\cdot (1-h_{\\theta}(\\mathbf{x}^{(i)}))^{1-\\mathbf{y}^{(i)}} \\right]\\\\ &amp;=	\\arg\\max_{\\theta}\\sum_{i=1}^{n} \\left[ \\mathbf{y}^{(i)}\\ln(h_{\\theta}(\\mathbf{x}^{(i)})) + (1-\\mathbf{y}^{(i)})\\ln(1-h_{\\theta}(\\mathbf{x}^{(i)})) \\right]\\\\ &amp;=	\\arg\\min_{\\theta} \\left[ -\\sum_{i=1}^{n} \\left[ \\mathbf{y}^{(i)}\\ln(h_{\\theta}(\\mathbf{x}^{(i)})) + (1-\\mathbf{y}^{(i)})\\ln(1-h_{\\theta}(\\mathbf{x}^{(i)})) \\right] \\right]\\\\ &amp;=	\\arg\\min_{\\theta}\\mathscr{l}(\\theta) \\end{split} L(θ)​=argθmax​ln(PAll​)=argθmax​lni=1∏n​[(hθ​(x(i)))y(i)⋅(1−hθ​(x(i)))1−y(i)]=argθmax​i=1∑n​[y(i)ln(hθ​(x(i)))+(1−y(i))ln(1−hθ​(x(i)))]=argθmin​[−i=1∑n​[y(i)ln(hθ​(x(i)))+(1−y(i))ln(1−hθ​(x(i)))]]=argθmin​l(θ)​上例中，在 = 前添加了 &amp;，因此实现等号对齐；
\\begin{split} \\end{split} 语法默认为右对齐，也就是说如果不在任何地方添加 &amp; 符号，则公式默认右侧对齐，例如：
1\\begin{split} 2L(\\theta) 3=	\\arg\\max_{\\theta}\\ln(P_{All})\\\\ 4=	\\arg\\max_{\\theta}\\ln\\prod_{i=1}^{n} 5\\left[ 6(h_{\\theta}(\\mathbf{x}^{(i)}))^{\\mathbf{y}^{(i)}}\\cdot 7(1-h_{\\theta}(\\mathbf{x}^{(i)}))^{1-\\mathbf{y}^{(i)}} 8\\right]\\\\ 9=	\\arg\\max_{\\theta}\\sum_{i=1}^{n} 10\\left[ 11\\mathbf{y}^{(i)}\\ln(h_{\\theta}(\\mathbf{x}^{(i)})) + 12(1-\\mathbf{y}^{(i)})\\ln(1-h_{\\theta}(\\mathbf{x}^{(i)})) 13\\right]\\\\ 14=	\\arg\\min_{\\theta} 15\\left[ 16-\\sum_{i=1}^{n} 17\\left[ 18\\mathbf{y}^{(i)}\\ln(h_{\\theta}(\\mathbf{x}^{(i)})) + 19(1-\\mathbf{y}^{(i)})\\ln(1-h_{\\theta}(\\mathbf{x}^{(i)})) 20\\right] 21\\right]\\\\ 22=	\\arg\\min_{\\theta}\\mathscr{l}(\\theta) 23\\end{split} 上述 LATEX 代码没有添加 &amp; 符号，则公式右对齐：
$$ \\begin{split} L(\\theta) =	\\arg\\max_{\\theta}\\ln(P_{All})\\ =	\\arg\\max_{\\theta}\\ln\\prod_{i=1}^{n} \\left[ (h_{\\theta}(\\mathbf{x}^{(i)}))^{\\mathbf{y}^{(i)}}\\cdot (1-h_{\\theta}(\\mathbf{x}^{(i)}))^{1-\\mathbf{y}^{(i)}} \\right]\\ =	\\arg\\max_{\\theta}\\sum_{i=1}^{n} \\left[ \\mathbf{y}^{(i)}\\ln(h_{\\theta}(\\mathbf{x}^{(i)})) + (1-\\mathbf{y}^{(i)})\\ln(1-h_{\\theta}(\\mathbf{x}^{(i)})) \\right]\\ =	\\arg\\min_{\\theta} \\left[ -\\sum_{i=1}^{n} \\left[ \\mathbf{y}^{(i)}\\ln(h_{\\theta}(\\mathbf{x}^{(i)})) + (1-\\mathbf{y}^{(i)})\\ln(1-h_{\\theta}(\\mathbf{x}^{(i)})) \\right] \\right]\\ =	\\arg\\min_{\\theta}\\mathscr{l}(\\theta) \\end{split}
$$
如果希望左对齐，例如
1\\begin{split} 2&amp;\\ln h_{\\theta}(\\mathbf{x}^{(i)}) 3=	\\ln\\frac{1}{1+e^{-\\theta^T \\mathbf{x}^{(i)}}} 4= -\\ln(1+e^{\\theta^T \\mathbf{x}^{(i)}})\\\\ 5&amp;\\ln(1-h_{\\theta}(\\mathbf{x}^{(i)})) 6=	\\ln(1-\\frac{1}{1+e^{-\\theta^T \\mathbf{x}^{(i)}}}) 7= -\\theta^T \\mathbf{x}^{(i)}-\\ln(1+e^{\\theta^T \\mathbf{x}^{(i)}}) 8\\end{split} ln⁡hθ(x(i))=ln⁡11+e−θTx(i)=−ln⁡(1+eθTx(i))ln⁡(1−hθ(x(i)))=ln⁡(1−11+e−θTx(i))=−θTx(i)−ln⁡(1+eθTx(i)) \\begin{split} &amp;\\ln h_{\\theta}(\\mathbf{x}^{(i)}) =	\\ln\\frac{1}{1+e^{-\\theta^T \\mathbf{x}^{(i)}}} = -\\ln(1+e^{\\theta^T \\mathbf{x}^{(i)}})\\\\ &amp;\\ln(1-h_{\\theta}(\\mathbf{x}^{(i)})) =	\\ln(1-\\frac{1}{1+e^{-\\theta^T \\mathbf{x}^{(i)}}}) = -\\theta^T \\mathbf{x}^{(i)}-\\ln(1+e^{\\theta^T \\mathbf{x}^{(i)}}) \\end{split} ​lnhθ​(x(i))=ln1+e−θTx(i)1​=−ln(1+eθTx(i))ln(1−hθ​(x(i)))=ln(1−1+e−θTx(i)1​)=−θTx(i)−ln(1+eθTx(i))​除了 \\begin{split} \\end{split}，也可以用 \\begin{align} \\end{align}，用法与 split 相同，对齐方式也相同；
只有一点不同：采用 align 环境会默认为每一条公式编号（如下例），split 则不会编号。
1\\begin{align} 2&amp;\\ln h_{\\theta}(\\mathbf{x}^{(i)}) 3=	\\ln\\frac{1}{1+e^{-\\theta^T \\mathbf{x}^{(i)}}} 4= -\\ln(1+e^{\\theta^T \\mathbf{x}^{(i)}})\\\\ 5&amp;\\ln(1-h_{\\theta}(\\mathbf{x}^{(i)})) 6=	\\ln(1-\\frac{1}{1+e^{-\\theta^T \\mathbf{x}^{(i)}}}) 7= -\\theta^T \\mathbf{x}^{(i)}-\\ln(1+e^{\\theta^T \\mathbf{x}^{(i)}}) 8\\end{align} ln⁡hθ(x(i))=ln⁡11+e−θTx(i)=−ln⁡(1+eθTx(i))ln⁡(1−hθ(x(i)))=ln⁡(1−11+e−θTx(i))=−θTx(i)−ln⁡(1+eθTx(i)) \\begin{align} &amp;\\ln h_{\\theta}(\\mathbf{x}^{(i)}) =	\\ln\\frac{1}{1+e^{-\\theta^T \\mathbf{x}^{(i)}}} = -\\ln(1+e^{\\theta^T \\mathbf{x}^{(i)}})\\\\ &amp;\\ln(1-h_{\\theta}(\\mathbf{x}^{(i)})) =	\\ln(1-\\frac{1}{1+e^{-\\theta^T \\mathbf{x}^{(i)}}}) = -\\theta^T \\mathbf{x}^{(i)}-\\ln(1+e^{\\theta^T \\mathbf{x}^{(i)}}) \\end{align} ​lnhθ​(x(i))=ln1+e−θTx(i)1​=−ln(1+eθTx(i))ln(1−hθ​(x(i)))=ln(1−1+e−θTx(i)1​)=−θTx(i)−ln(1+eθTx(i))​​但可以在 align 后加一个 * 号，则 align 环境也可以取消公式自动编号，如下： (也就是说 align* 和 split 的用法完全相同)
1\\begin{align*} 2&amp;\\ln h_{\\theta}(\\mathbf{x}^{(i)}) 3=	\\ln\\frac{1}{1+e^{-\\theta^T \\mathbf{x}^{(i)}}} 4	= -\\ln(1+e^{\\theta^T \\mathbf{x}^{(i)}})\\\\ 5&amp;\\ln(1-h_{\\theta}(\\mathbf{x}^{(i)})) 6=	\\ln(1-\\frac{1}{1+e^{-\\theta^T \\mathbf{x}^{(i)}}}) 7	= -\\theta^T \\mathbf{x}^{(i)}-\\ln(1+e^{\\theta^T \\mathbf{x}^{(i)}}) 8\\end{align*} ln⁡hθ(x(i))=ln⁡11+e−θTx(i)=−ln⁡(1+eθTx(i))ln⁡(1−hθ(x(i)))=ln⁡(1−11+e−θTx(i))=−θTx(i)−ln⁡(1+eθTx(i)) \\begin{align*} &amp;\\ln h_{\\theta}(\\mathbf{x}^{(i)}) =	\\ln\\frac{1}{1+e^{-\\theta^T \\mathbf{x}^{(i)}}} = -\\ln(1+e^{\\theta^T \\mathbf{x}^{(i)}})\\\\ &amp;\\ln(1-h_{\\theta}(\\mathbf{x}^{(i)})) =	\\ln(1-\\frac{1}{1+e^{-\\theta^T \\mathbf{x}^{(i)}}}) = -\\theta^T \\mathbf{x}^{(i)}-\\ln(1+e^{\\theta^T \\mathbf{x}^{(i)}}) \\end{align*} ​lnhθ​(x(i))=ln1+e−θTx(i)1​=−ln(1+eθTx(i))ln(1−hθ​(x(i)))=ln(1−1+e−θTx(i)1​)=−θTx(i)−ln(1+eθTx(i))​方程组 使用 \\begin{cases} \\end{cases}
例如：
1\\begin{cases} 2\\begin{split} 3p &amp;= P(y=1|\\mathbf{x})= 4\\frac{1}{1+e^{-\\theta^T\\mathbf{X}}}\\\\ 51-p &amp;= P(y=0|\\mathbf{x})=1-P(y=1|\\mathbf{x})= 6\\frac{1}{1+e^{\\theta^T\\mathbf{X}}} 7\\end{split} 8\\end{cases} {p=P(y=1∣x)=11+e−θTX1−p=P(y=0∣x)=1−P(y=1∣x)=11+eθTX \\begin{cases} \\begin{split} p &amp;= P(y=1|\\mathbf{x})= \\frac{1}{1+e^{-\\theta^T\\mathbf{X}}}\\\\ 1-p &amp;= P(y=0|\\mathbf{x})=1-P(y=1|\\mathbf{x})= \\frac{1}{1+e^{\\theta^T\\mathbf{X}}} \\end{split} \\end{cases} ⎩⎨⎧​p1−p​=P(y=1∣x)=1+e−θTX1​=P(y=0∣x)=1−P(y=1∣x)=1+eθTX1​​​注意 LATEX 语法可以嵌套使用，上例即为 \\begin{cases} \\end{cases} 下嵌套了 \\begin{split} \\end{split}。
也可以将公式和文字结合起来，例如：
1\\text{Decision Boundary}= 2\\begin{cases} 3 1\\quad \\text{if }\\ \\hat{y}&gt;0.5\\\\ 4 0\\quad \\text{otherwise} 5\\end{cases} Decision Boundary={1if y^&gt;0.50otherwise \\text{Decision Boundary}= \\begin{cases} 1\\quad \\text{if }\\ \\hat{y}&gt;0.5\\\\ 0\\quad \\text{otherwise} \\end{cases} Decision Boundary={1if y^​&gt;0.50otherwise​注：\\quad 表示空格。
公式添加编号 在 LaTeX 中，可以通过 \\tag{} 命令为公式自定义编号。以下是如何在 LaTeX 中为公式添加自定义编号的示例：
示例代码 1% 无编号公式 2 3$$ 4 5\\dot{V}(x) \\leq -k_1 V(x)^{\\frac{m}{n}} - k_2 V(x)^{\\frac{r}{s}} 6 7$$ V˙(x)≤−k1V(x)mn−k2V(x)rs \\dot{V}(x) \\leq -k_1 V(x)^{\\frac{m}{n}} - k_2 V(x)^{\\frac{r}{s}} V˙(x)≤−k1​V(x)nm​−k2​V(x)sr​1 2% 自定义编号公式 3 4$$ 5 6\\dot{V}(x) \\leq -k_1 V(x)^{\\frac{m}{n}} - k_2 V(x)^{\\frac{r}{s}} \\tag{1.1} 7 8$$ V˙(x)≤−k1V(x)mn−k2V(x)rs(1.1) \\dot{V}(x) \\leq -k_1 V(x)^{\\frac{m}{n}} - k_2 V(x)^{\\frac{r}{s}} \\tag{1.1} V˙(x)≤−k1​V(x)nm​−k2​V(x)sr​(1.1) 1 2% 多行公式自定义编号 3 4\\begin{align} 5 6\\dot{V}(x) &amp;\\leq -k_1 V(x)^{\\frac{m}{n}} - k_2 V(x)^{\\frac{r}{s}} \\tag{1.2} \\\\ 7 8&amp;\\leq -k_1 V(x)^{\\frac{m}{n}} \\quad \\text{(忽略次线性项)} \\tag{1.3} 9 10\\end{align} 11 12\\end{document} $$ \\begin{align}
\\dot{V}(x) &amp;\\leq -k_1 V(x)^{\\frac{m}{n}} - k_2 V(x)^{\\frac{r}{s}} \\tag{1.2} \\
&amp;\\leq -k_1 V(x)^{\\frac{m}{n}} \\quad \\text{(忽略次线性项)} \\tag{1.3}
\\end{align} $$
说明 无编号公式： 使用 $$ ... $$ 或 [equation*] 环境可以创建无编号公式。 自定义编号公式： 使用 \\tag{} 命令可以为公式添加自定义编号，例如 \\tag{1.1}。 多行公式自定义编号： 在 align 环境中，可以为每一行公式单独添加自定义编号。 注意事项 \\tag{} 命令会覆盖 LaTeX 自动生成的编号。 如果需要在公式中引用自定义编号，可以使用 \\label{} 和 \\[eqref]{} 结合的方式。 通过这种方式，可以灵活地为 LaTeX 公式添加自定义编号，满足特定文档的需求。
`,url:"https://hugo-dead-simple.netlify.com/blog/latex%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F%E6%89%8B%E5%86%8C/"},"https://hugo-dead-simple.netlify.com/books/%E7%AE%97%E6%B3%95%E6%96%B0%E8%A7%A3-%E5%88%98%E6%96%B0%E5%AE%87/":{title:"算法新解-刘新宇 读书笔记",tags:[],content:"目录 前言 第一章 列表 第二章 二叉搜索树 ",url:"https://hugo-dead-simple.netlify.com/books/%E7%AE%97%E6%B3%95%E6%96%B0%E8%A7%A3-%E5%88%98%E6%96%B0%E5%AE%87/"},"https://hugo-dead-simple.netlify.com/tags/aggregation/":{title:"Aggregation",tags:[],content:"",url:"https://hugo-dead-simple.netlify.com/tags/aggregation/"},"https://hugo-dead-simple.netlify.com/tags/css/":{title:"CSS",tags:[],content:"",url:"https://hugo-dead-simple.netlify.com/tags/css/"},"https://hugo-dead-simple.netlify.com/typescript/debug/":{title:"debug",tags:[],content:`来自: https://www.bilibili.com/video/BV1zT411z7y7/
安装typescript 与ts-node 写一个ts的脚本 1let a = 1 2a = a+1 3console.log(a) 点击行下段点 点击vscode上的调试按钮 `,url:"https://hugo-dead-simple.netlify.com/typescript/debug/"},"https://hugo-dead-simple.netlify.com/tags/exercises/":{title:"Exercises",tags:[],content:"",url:"https://hugo-dead-simple.netlify.com/tags/exercises/"},"https://hugo-dead-simple.netlify.com/frontend/":{title:"FrontEnds",tags:[],content:"",url:"https://hugo-dead-simple.netlify.com/frontend/"},"https://hugo-dead-simple.netlify.com/tags/hugo/":{title:"Hugo",tags:[],content:"",url:"https://hugo-dead-simple.netlify.com/tags/hugo/"},"https://hugo-dead-simple.netlify.com/tags/javascript/":{title:"JavaScript",tags:[],content:"",url:"https://hugo-dead-simple.netlify.com/tags/javascript/"},"https://hugo-dead-simple.netlify.com/tags/mongodb/":{title:"MongoDB",tags:[],content:"",url:"https://hugo-dead-simple.netlify.com/tags/mongodb/"},"https://hugo-dead-simple.netlify.com/mongodb/lookup/":{title:"MongoDB - Lookup 操作详解",tags:["MongoDB","Aggregation"],content:`FAQ 如果实现类似的sql的 join 功能呢?
查看官方文档
$lookup（聚合）— MongoDB 手册 v8.0 ask ask : 我在写在mongodb的相关内容, 有一个user collection ,还有一个comment collection,commment通过 userid 与user 进行了关联,,我在查询comment ,如何得到每个comment 里的user 的相关属性? Answser 在 MongoDB 中，如果 comment 集合中的每个文档通过 userId 字段与 user 集合中的用户进行关联，并且你希望在查询 comment 时获取每个评论对应的 user 的相关属性，你可以使用 $lookup 聚合操作来实现联表查询。
示例数据结构 user 集合:
1{ 2 &#34;_id&#34;: ObjectId(&#34;user1&#34;), 3 &#34;name&#34;: &#34;Alice&#34;, 4 &#34;email&#34;: &#34;alice@example.com&#34;, 5 &#34;age&#34;: 30 6} comment 集合:
1{ 2 &#34;_id&#34;: ObjectId(&#34;comment1&#34;), 3 &#34;content&#34;: &#34;This is a comment&#34;, 4 &#34;userId&#34;: ObjectId(&#34;user1&#34;), 5 &#34;timestamp&#34;: ISODate(&#34;2024-12-09T10:00:00Z&#34;) 6} 使用 $lookup 进行联表查询 你可以使用聚合框架（aggregate()）结合 $lookup 来连接 comment 和 user 集合，并将每个评论对应的用户信息合并到评论数据中。
聚合查询示例 1db.comment.aggregate([ 2 { 3 $lookup: { 4 from: &#34;user&#34;, // 关联的集合是 &#34;user&#34; 5 localField: &#34;userId&#34;, // 当前集合中关联字段是 &#34;userId&#34; 6 foreignField: &#34;_id&#34;, // 关联到 &#34;user&#34; 集合中的 &#34;_id&#34; 字段 7 as: &#34;userDetails&#34; // 结果会放入 &#34;userDetails&#34; 数组字段 8 } 9 }, 10 { 11 $unwind: &#34;$userDetails&#34; // 将 &#34;userDetails&#34; 数组展开成单个对象（如果每个评论只能有一个用户的话） 12 } 13]) 查询结果 假设 comment 集合有一个文档，如下所示：
1{ 2 &#34;_id&#34;: ObjectId(&#34;comment1&#34;), 3 &#34;content&#34;: &#34;This is a comment&#34;, 4 &#34;userId&#34;: ObjectId(&#34;user1&#34;), 5 &#34;timestamp&#34;: ISODate(&#34;2024-12-09T10:00:00Z&#34;), 6 &#34;userDetails&#34;: { 7 &#34;_id&#34;: ObjectId(&#34;user1&#34;), 8 &#34;name&#34;: &#34;Alice&#34;, 9 &#34;email&#34;: &#34;alice@example.com&#34;, 10 &#34;age&#34;: 30 11 } 12} 解析说明 $lookup: 在 comment 集合中的 userId 字段和 user 集合中的 _id 字段之间建立连接，将匹配到的用户信息加入到每个评论中，并存储在 userDetails 字段中。
$unwind: 如果你确定每个评论只有一个对应的用户（即 userId 字段指向的是唯一用户），使用 $unwind 将 userDetails 数组拆解成单个对象。这样，你就可以直接在每个评论文档中获取到用户的属性。
如果一个评论可能有多个用户（例如评论可能有多个作者），你可以跳过 $unwind，这样每个评论的 userDetails 会是一个数组，包含匹配的所有用户。
其他改进 如果你只关心某些特定的用户字段，可以通过 $project 对返回的字段进行过滤，减少数据传输量。例如：
1db.comment.aggregate([ 2 { 3 $lookup: { 4 from: &#34;user&#34;, 5 localField: &#34;userId&#34;, 6 foreignField: &#34;_id&#34;, 7 as: &#34;userDetails&#34; 8 } 9 }, 10 { 11 $unwind: &#34;$userDetails&#34; 12 }, 13 { 14 $project: { 15 content: 1, // 只保留评论的内容 16 &#34;userDetails.name&#34;: 1, // 只返回用户的名字 17 &#34;userDetails.email&#34;: 1 // 只返回用户的邮箱 18 } 19 } 20]) 这样，结果将只包含评论内容以及用户的名字和邮箱。
总结 使用 aggregate() 方法结合 $lookup 可以轻松地在查询评论时获取每个评论对应用户的详细信息。如果你只关心部分用户字段，可以使用 $project 来限制返回的字段，优化查询效率。
`,url:"https://hugo-dead-simple.netlify.com/mongodb/lookup/"},"https://hugo-dead-simple.netlify.com/mongodb/find_on_array/":{title:"MongoDB - 在数组上查询",tags:["MongoDB","Querying"],content:`查询数组 - MongoDB 手册 v8.0
$ne操作在数组的查询与我想的不一样
如果你希望能够匹配数组中有部分元素与 &ldquo;red&rdquo; 不匹配的文档，可以使用 $elemMatch 来精确匹配数组中的单个元素：
1db.newdb.find({ 2 tags: { $elemMatch: { $ne: &#34;red&#34; } } 3}) 查询数组元素
多个条件
1const cursor = db.collection(&#39;inventory&#39;).find({ 2 dim_cm: { $gt: 15, $lt: 20 } 3}); 数学描述
∃x∈A(x&gt;=15)∧∃x∈A(x&lt;=20) \\exists x \\in A( x&gt;=15) \\land \\exists x \\in A (x &lt;=20) ∃x∈A(x&gt;=15)∧∃x∈A(x&lt;=20)1const cursor = db.collection(&#39;inventory&#39;).find({ 2 dim_cm: { $elemMatch: { $gt: 22, $lt: 30 } } 3}); ∃x∈A(x&gt;=15∧x&lt;=20) \\exists x \\in A( x&gt;=15 \\land x &lt;=20) ∃x∈A(x&gt;=15∧x&lt;=20)1const cursor = db.collection(&#39;inventory&#39;).find({ 2 dim_cm: {$eq:20} 3}); ∃x∈A(x=20) \\exists x \\in A( x=20) ∃x∈A(x=20)1const cursor = db.collection(&#39;inventory&#39;).find({ 2 dim_cm: {$ne:20} 3}); !!!注意这个查询是上面的查询的反面
¬∃x∈A(x=20)∀¬(x=20)∀(x!=20) \\begin{matrix} \\neg \\exists x \\in A(x = 20) \\\\ \\forall \\neg (x = 20) \\\\ \\forall (x != 20) \\end{matrix} ¬∃x∈A(x=20)∀¬(x=20)∀(x!=20)​`,url:"https://hugo-dead-simple.netlify.com/mongodb/find_on_array/"},"https://hugo-dead-simple.netlify.com/mongodb/mongodb/":{title:"MongoDB 学习笔记",tags:[],content:`安装 docker 安装,根据文档来: https://www.mongodb.com/zh-cn/docs/manual/tutorial/install-mongodb-community-with-docker/
安装完后,我根据 https://www.w3resource.com/mongodb-exercises/ 做练习
这里的客户端选择了mongodb compass: https://www.mongodb.com/try/download/compass
最重要的就是mongodb的官方文档: https://www.mongodb.com/zh-cn/docs/manual/
一些概念 1数据 --&gt; 集合-&gt; 文档 学习路线 我认为学习的路线为
增删改查 注意数组上查询的反直觉行为 注意$ne在数组的查询问题 聚合 索引 `,url:"https://hugo-dead-simple.netlify.com/mongodb/mongodb/"},"https://hugo-dead-simple.netlify.com/mongodb/exercise/":{title:"MongoDB 练习 1",tags:["MongoDB","Exercises"],content:`5 Write a MongoDB query to display all the restaurant which is in the borough Bronx. 这个简单,本质是查询固定的值
1db[&#34;restaurants&#34;].find({&#39;borough&#39;:&#39;Bronx&#39;}) 8 Write a MongoDB query to find the restaurants who achieved a score more than 90. 让我们查询一个数组,数组里面有一个Object的值&gt;=0
1db[&#34;restaurants&#34;].find({&#39;grades.score&#39;: {$gt : 90}}).count() 1db[&#34;restaurants&#34;].find({ &#39;grades&#39; : {$elemMatch : { &#34;score&#34; :{$gt : 90} } } }) 这两个的结果是等价的,只不过第二个用到了数组匹配操作符$elemMatch
9 Write a MongoDB query to find the restaurants that achieved a score, more than 80 but less than 100. 这个题目的意思是: grades里存在一个分数,这个分数在80与90之间
1db[&#34;restaurants&#34;].find({ &#39;grades&#39; : {$elemMatch : { &#34;score&#34; :{$gt : 80,$lt:100} } } }) 10 Write a MongoDB query to find the restaurants which locate in latitude value less than -95.754168. 这里考察我们如何查询数组里某个下标的值
1db.restaurants.find({&#34;address.coord.0&#34;:{$lte : -95.754168} }) 11 Write a MongoDB query to find the restaurants that do not prepare any cuisine of &lsquo;American&rsquo; and their grade score more than 70 and latitude less than -65.754168. 1db[&#34;restaurants&#34;].count({cuisine:{$not: {$regex: /.*American.*/ } },grades:{$elemMatch : { &#34;score&#34;:{$gte:70} }} }) 这里考查我们有多个条件,同时成立的查询
发现一个问题:
我查询了文档
mongodb在数组上的查询 https://www.mongodb.com/zh-cn/docs/manual/tutorial/query-arrays/#specify-multiple-conditions-for-array-elements mongodb - mongo $ne query with an array not working as expected - Stack Overflow $ne操作在数组的查询与我想的不一样
如果你希望能够匹配数组中有部分元素与 &ldquo;red&rdquo; 不匹配的文档，可以使用 $elemMatch 来精确匹配数组中的单个元素：
1db.newdb.find({ 2 tags: { $elemMatch: { $ne: &#34;red&#34; } } 3}) 这里官方给出的答案
1db.restaurants.find( 2 {$and: 3 [ 4 {&#34;cuisine&#34; : {$ne :&#34;American &#34;}}, 5 {&#34;grades.score&#34; : {$gt : 70}}, 6 {&#34;address.coord&#34; : {$lt : -65.754168}} 7 ] 8 }); 12 Write a MongoDB query to find the restaurants which do not prepare any cuisine of &lsquo;American&rsquo; and achieved a score more than 70 and located in the longitude less than -65.754168. Note : Do this query without using $and operator. 和上一个问题的问题一样,只是不让我们使用$and$符号
1db.restaurants.find( 2 { 3 &#34;cuisine&#34; : {$ne : &#34;American &#34;}, 4 &#34;grades.score&#34; :{$gt: 70}, 5 &#34;address.coord&#34; : {$lt : -65.754168} 6 } 7 ); 13 Write a MongoDB query to find the restaurants which do not prepare any cuisine of &lsquo;American&rsquo; and achieved a grade point &lsquo;A&rsquo; not belongs to the borough Brooklyn. The document must be displayed according to the cuisine in descending order. 前面的条件还好,这里只是多了一个排序的要求
1db.restaurants.find( { 2 &#34;cuisine&#34; : {$ne : &#34;American&#34;}, 3 &#34;grades.grade&#34; :&#34;A&#34;, 4 &#34;borough&#34;: {$ne : &#34;Brooklyn&#34;} 5 } 6 ).sort({&#34;cuisine&#34;:-1}); 14 Write a MongoDB query to find the restaurant Id, name, borough and cuisine for those restaurants which contain &lsquo;Wil&rsquo; as first three letters for its name. 查询的条件是name的首个三个字母是3个Wil字符.
我这里的写法与官方不一样,因为我不理解官方的第二个参数,为什么这样写,因为我查询的nodejs api 不是这样的.
https://mongodb.github.io/node-mongodb-native/6.11/interfaces/FindOptions.html#projection
1db[&#34;restaurants&#34;].find ({name:/AWil/}).projection({name:1,restaurant_id:1,borough:1,cuisine:1}}) 为什么会这样? ,AI 告诉我这是一个差异!!!
你提出的问题涉及到 MongoDB Node.js Driver 的 find 方法的第二个参数，它实际上是一个 选项对象（options），而 投影（projection） 是该选项对象中的一个字段。这是 MongoDB Node.js Driver 和 MongoDB Shell（mongosh）之间的一个差异。
MongoDB Node.js Driver 的 find 方法 根据你提供的链接，在 MongoDB 的 Node.js Driver 版本 3.6 中，find 方法的第二个参数 必须是一个选项对象，该对象中可以包含多个选项，例如 projection, sort, limit 等。
find 方法的签名（Node.js Driver） 1find(filter, options) filter: 查询条件。 options: 选项对象，其中包括多个可选的字段，例如 projection, sort, limit 等。 投影（Projection）在选项对象中 在 MongoDB Node.js Driver 中，投影（projection） 是通过选项对象中的 projection 字段来指定的。因此，第二个参数的形式通常是一个包含 projection 字段的对象，而 投影（projection） 本身是一个文档，定义了需要包含或排除的字段。
示例代码： 1const { MongoClient } = require(&#39;mongodb&#39;); 2 3async function queryRestaurants() { 4 const client = new MongoClient(&#39;mongodb://localhost:27017&#39;); 5 await client.connect(); 6 const db = client.db(&#39;test&#39;); // 假设你的数据库名是 &#39;test&#39; 7 const collection = db.collection(&#39;restaurants&#39;); 8 9 // 使用 find 查询并投影 10 const cursor = collection.find( 11 { name: /^Wil/ }, 12 { 13 projection: { 14 &#34;restaurant_id&#34;: 1, 15 &#34;name&#34;: 1, 16 &#34;borough&#34;: 1, 17 &#34;cuisine&#34;: 1 18 } 19 } 20 ); 21 22 // 获取查询结果并打印 23 const results = await cursor.toArray(); 24 console.log(results); 25 26 await client.close(); 27} 28 29queryRestaurants().catch(console.error); 为什么必须使用 projection 字段？ 在 Node.js MongoDB Driver 的 find 方法中，第二个参数是一个 选项对象（options），因此你需要明确指定 projection 字段来设置查询返回的字段。这是与 MongoDB Shell（mongosh） 的差异，后者可以直接将投影文档作为第二个参数。
Node.js Driver 的选项对象结构 在 Node.js 中，你可以传递一个包含多个选项字段的对象，例如：
1{ 2 projection: { &#34;restaurant_id&#34;: 1, &#34;name&#34;: 1, &#34;borough&#34;: 1, &#34;cuisine&#34;: 1 }, 3 sort: { name: 1 }, 4 limit: 10 5} projection: 指定返回的字段。 sort: 指定排序规则。 limit: 限制返回的文档数量。 总结 在 MongoDB Node.js Driver 中，第二个参数是一个 选项对象（options），其中包含 projection 字段来指定投影。而在 MongoDB Shell（mongosh） 中，第二个参数直接是一个投影文档，可以省略 projection 字段名。
Node.js Driver 使用 projection： 1db.restaurants.find( 2 { name: /^Wil/ }, 3 { projection: { &#34;restaurant_id&#34;: 1, &#34;name&#34;: 1, &#34;borough&#34;: 1, &#34;cuisine&#34;: 1 } } 4); MongoDB Shell 中直接传递投影文档： 1db.restaurants.find( 2 { name: /^Wil/ }, 3 { &#34;restaurant_id&#34;: 1, &#34;name&#34;: 1, &#34;borough&#34;: 1, &#34;cuisine&#34;: 1 } 4); 好吧,经过我的查询,这真的是一个差异:
https://stackoverflow.com/questions/67090307/mongodb-projection-syntax https://www.mongodb.com/zh-cn/docs/manual/reference/method/db.collection.findOne/ 两者确实不一样.
15 Write a MongoDB query to find the restaurant Id, name, borough and cuisine for those restaurants which contain &lsquo;ces&rsquo; as last three letters for its name. 和上一个问题一样,但是要查询的值是最后三个字符,还是使用regex
1db.restaurants.find( 2{name: /ces$/}, 3{ 4&#34;restaurant_id&#34; : 1, 5&#34;name&#34;:1,&#34;borough&#34;:1, 6&#34;cuisine&#34; :1 7} 8); 1db[&#34;restaurants&#34;].find ({name:/ces$/}).projection({name:1, 2restaurant_id:1,borough:1,cuisine:1}) 16 包含Reg+投影 Write a MongoDB query to find the restaurant Id, name, borough and cuisine for those restaurants which contain &lsquo;Reg&rsquo; as three letters somewhere in its name. 改变一下reg就可以了.
1db[&#34;restaurants&#34;].find({name:/Reg/},{name:1}).count() 2db[&#34;restaurants&#34;].find({name:/Reg/},{name:1}).count() 3 4db.restaurants.find( 5{&#34;name&#34;: /.*Reg.*/}, 6{ 7&#34;restaurant_id&#34; : 1, 8&#34;name&#34;:1,&#34;borough&#34;:1, 9&#34;cuisine&#34; :1 10} 11); 17 Write a MongoDB query to find the restaurants which belong to the borough Bronx and prepared either American or Chinese dish. 1db[&#34;restaurants&#34;].find({&#34;cuisine&#34;: {$in :[&#39;Chinese&#39;, &#39;American &#39;]} , 2 &#34;borough&#34;: &#34;Bronx&#34; 3},{&#34;cuisine&#34;:1}).count() 1db.restaurants.find( 2{ 3&#34;borough&#34;: &#34;Bronx&#34; , 4$or : [ 5{ &#34;cuisine&#34; : &#34;American &#34; }, 6{ &#34;cuisine&#34; : &#34;Chinese&#34; } 7] 8} 9); 18 Write a MongoDB query to find the restaurant Id, name, borough and cuisine for those restaurants which belong to the borough Staten Island or Queens or Bronxor Brooklyn.
和我的上一个执行$in的语法一样
1db.restaurants.find( 2 {&#34;borough&#34; :{$in :[&#34;Staten Island&#34;,&#34;Queens&#34;,&#34;Bronx&#34;,&#34;Brooklyn&#34;]}}, 3 { 4 &#34;restaurant_id&#34; : 1, 5 &#34;name&#34;:1,&#34;borough&#34;:1, 6 &#34;cuisine&#34; :1 7 } 8 ); 19 Write a MongoDB query to find the restaurant Id, name, borough and cuisine for those restaurants which are not belonging to the borough Staten Island or Queens or Bronxor Brooklyn.
从数理逻辑的角度来看,a∉{borough Staten Island , Queens , Bronxor Brooklyn}a \\notin \\{\\text{borough Staten Island , Queens , Bronxor Brooklyn} \\}a∈/{borough Staten Island , Queens , Bronxor Brooklyn} 当这个条件为true的时候,这里使用$nin操作
1db.restaurants.find( 2{&#34;borough&#34; :{$nin :[&#34;Staten Island&#34;,&#34;Queens&#34;,&#34;Bronx&#34;,&#34;Brooklyn&#34;]}}, 3{ 4&#34;restaurant_id&#34; : 1, 5&#34;name&#34;:1,&#34;borough&#34;:1, 6&#34;cuisine&#34; :1 7} 8); 20 Write a MongoDB query to find the restaurant Id, name, borough and cuisine for those restaurants which achieved a score which is not more than 10.
这里的核心就在于 not more than 10 ,数学写法
¬(grades.score&gt;10)⇔grades.score&lt;=10 \\neg (grades.score &gt; 10) \\Leftrightarrow grades.score &lt;= 10 ¬(grades.score&gt;10)⇔grades.score&lt;=101db[&#34;restaurants&#34;].find({&#34;grades.score&#34;: {$lte: 10}}).count() 2 3db.restaurants.find( {&#34;grades.score&#34; : { $not: {$gt : 10} } }).count() 恩&hellip;&hellip;&hellip;.., 两者竟然是不一样的.
题目应该问的是: 所有的分都不超过10.
$lte:10 应该是只要有一个(存在)&lt;=10 就成立
遇到这种事件,应该首先查文档: https://www.mongodb.com/zh-cn/docs/manual/reference/operator/query/not/,但文档上没有说.
find({ &quot;grades.score&quot;: {$gt : 10} }) 表示的意思其实是: ∃(x&gt;10)\\exists (x &gt; 10)∃(x&gt;10)
find({ &quot;grades.score&quot;: {$not :{ $gt : 10} }}) 表示的意思其实是: ¬∃(x&gt;10)→∀(x&lt;=10)\\neg \\exists (x &gt; 10) \\to \\forall (x&lt;=10)¬∃(x&gt;10)→∀(x&lt;=10),这样就能理解了
`,url:"https://hugo-dead-simple.netlify.com/mongodb/exercise/"},"https://hugo-dead-simple.netlify.com/mongodb/exercise2/":{title:"MongoDB 练习 2",tags:["MongoDB","Exercises"],content:`21 Write a MongoDB query to find the restaurant Id, name, borough and cuisine for those restaurants which prepared dish except &lsquo;American&rsquo; and &lsquo;Chinees&rsquo; or restaurant&rsquo;s name begins with letter &lsquo;Wil&rsquo;.
1db.restaurants.find({ 2 $or : [ 3 {&#34;name&#34;: /^Wil/}, 4 {&#34;cuisine&#34; : { $nin :[&#34;American &#34;,&#34;Chinees&#34;] }} 5 ] 6 }) 这两个写法是一样的
1db.restaurants.find( 2{$or: [ 3 {name: /^Wil/}, 4 {&#34;$and&#34;: [ 5 {&#34;cuisine&#34; : {$ne :&#34;American &#34;}}, 6 {&#34;cuisine&#34; : {$ne :&#34;Chinees&#34;}} 7 ]} 8]} 9,{&#34;restaurant_id&#34; : 1,&#34;name&#34;:1,&#34;borough&#34;:1,&#34;cuisine&#34; :1} 10); 22 Write a MongoDB query to find the restaurant Id, name, and grades for those restaurants which achieved a grade of &ldquo;A&rdquo; and scored 11 on an ISODate &ldquo;2014-08-11T00:00:00Z&rdquo; among many of survey dates. 达到了 grade A 且 scored 11. 首先,我们要理解这里的意思到底是什么意思?
有三个条件:
时间: ISODate &ldquo;2014-08-11T00:00:00Z 分值: 11 grade: A 这里的关键在于,数组grades其中的一条满足这3个条件.那么里这里要用到的$elemMatch
1db.restaurants.find({ 2 grades:{ $elemMatch : { grade:&#39;A&#39;,date:ISODate(&#34;2014-08-11T00:00:00Z&#34;), scored: 11}} 3 }) 但是给出的答案是,理解我写在注释里
1db.restaurants.find( 2 { // 这里是and 3 &#34;grades.date&#34;: ISODate(&#34;2014-08-11T00:00:00Z&#34;), // 这里只要有一个数组的元素成立 4 &#34;grades.grade&#34;:&#34;A&#34; , // 这里只要有一个数组的元素成立 5 &#34;grades.score&#34; : 11// 这里只要有一个数组的元素成立 6 }, 7 {&#34;restaurant_id&#34; : 1,&#34;name&#34;:1,&#34;grades&#34;:1} 8 ); 这里怎么用数学描述: 设集合A为A = [{},{},{},{}], 满足条件a∈A∧b∈A∧c∈Aa \\in A \\land b \\in A \\land c \\in Aa∈A∧b∈A∧c∈A
23 Write a MongoDB query to find the restaurant Id, name and grades for those restaurants where the 2nd element of grades array contains a grade of &ldquo;A&rdquo; and score 9 on an ISODate &ldquo;2014-08-11T00:00:00Z&rdquo;.
arrayElemAt（如果你需要明确选择数组中的特定元素）
如果你明确只想要查询数组的第二个元素，elemMatch 不能直接做这件事。不过，你可以结合 $arrayElemAt 来选择数组中的第二个元素进行条件匹配：
1db.collection.find({ 2 &#34;$expr&#34;: { 3 &#34;$eq&#34;: [ 4 { &#34;$arrayElemAt&#34;: [&#34;$grades&#34;, 1] }, // 获取第二个元素 5 { &#34;grade&#34;: &#34;A&#34;, &#34;score&#34;: 9, &#34;date&#34;: ISODate(&#34;2014-08-11T00:00:00Z&#34;) } // 条件 6 ] 7 } 8}) 那么还是官方给的答案比较简单:
1db.restaurants.find( 2 { &#34;grades.1.date&#34;: ISODate(&#34;2014-08-11T00:00:00Z&#34;), 3 &#34;grades.1.grade&#34;:&#34;A&#34; , 4 &#34;grades.1.score&#34; : 9 5 }, 6 {&#34;restaurant_id&#34; : 1,&#34;name&#34;:1,&#34;grades&#34;:1} 7 ); 24 Write a MongoDB query to find the restaurant Id, name, address and geographical location for those restaurants where 2nd element of coord array contains a value which is more than 42 and upto 52.
没有争议
1db.restaurants.find( 2 { 3 &#34;address.coord.1&#34;: {$gt : 42, $lte : 52} 4 }, 5 {&#34;restaurant_id&#34; : 1,&#34;name&#34;:1,&#34;address&#34;:1,&#34;coord&#34;:1} 6 ); 25,26 Write a MongoDB query to arrange the name of the restaurants in ascending order along with all the columns. Write a MongoDB query to arrange the name of the restaurants in descending along with all the columns. 就是排序而已
1db.restaurants.find().sort({&#34;name&#34;:1}); 2db.restaurants.find().sort( {&#34;name&#34;:-1}); 27 Write a MongoDB query to arranged the name of the cuisine in ascending order and for that same cuisine borough should be in descending order.
还是排序,不过同时要排序两个元素
1db.restaurants.find().sort( 2 {&#34;cuisine&#34;:1,&#34;borough&#34; : -1,} 3 ); 28 Write a MongoDB query to know whether all the addresses contains the street or not.
查询元素的存在性
1db.restaurants.find( {&#34;address.street&#34; : { $exists : true } } ); 29 Write a MongoDB query which will select all documents in the restaurants collection where the coord field value is Double.
查询元素的类型
对于 field 为数组的文档，$type 返回的文档中至少有一个数组元素与传递给 $type 的类型匹配。
对 $type: &ldquo;array&rdquo; 的查询会返回字段本身为数组的文档。
$type — MongoDB 手册 v8.0
1db.restaurants.find( {&#34;address.coord&#34; : {$type : 1} }); 30 Write a MongoDB query which will select the restaurant Id, name and grades for those restaurants which returns 0 as a remainder after dividing the score by 7.
这里用到了 $mod - MongoDB 手册 v8.0
1db.restaurants.find( 2 {&#34;grades.score&#34; : 3 {$mod : [7,0]} 4 }, 5 {&#34;restaurant_id&#34; : 1,&#34;name&#34;:1,&#34;grades&#34;:1} 6 ); 31 Write a MongoDB query to find the restaurant name, borough, longitude and attitude and cuisine for those restaurants which contains &lsquo;mon&rsquo; as three letters somewhere in its name.
正则查询
1db.restaurants.find( 2 { name : 3 { $regex : &#34;mon.*&#34;, $options: &#34;i&#34; } 4 }, 5 { 6 &#34;name&#34;:1, 7 &#34;borough&#34;:1, 8 &#34;address.coord&#34;:1, 9 &#34;cuisine&#34; :1 10 } 11 ); 32 Write a MongoDB query to find the restaurant name, borough, longitude and latitude and cuisine for those restaurants which contain &lsquo;Mad&rsquo; as first three letters of its name.
正则查询
1db.restaurants.find( 2 { name : 3 { $regex : /^Mad/i, } 4 }, 5 { 6 &#34;name&#34;:1, 7 &#34;borough&#34;:1, 8 &#34;address.coord&#34;:1, 9 &#34;cuisine&#34; :1 10 } 11 ); 33 Write a MongoDB query to find the restaurants that have at least one grade with a score of less than 5.
数组查询
1db.restaurants.find({ &#34;grades.score&#34;: { $lt: 5 } }) 34 Write a MongoDB query to find the restaurants that have at least one grade with a score of less than 5 and that are located in the borough of Manhattan.
怎么变简单了?
1db.restaurants.find({ &#34;grades.score&#34;: { $lt: 5 }, &#34;borough&#34;: &#34;Manhattan&#34; }) 35 Write a MongoDB query to find the restaurants that have at least one grade with a score of less than 5 and that are located in the borough of Manhattan or Brooklyn.
还是简单
1db.restaurants.find({ 2 $and: [ 3 { 4 $or: [ // 可以用$in 5 {borough: &#34;Manhattan&#34;}, 6 {borough: &#34;Brooklyn&#34;} 7 ] 8 }, 9 { 10 &#34;grades.score&#34;: { $lt: 5 } 11 } 12 ] 13}) 36 Write a MongoDB query to find the restaurants that have at least one grade with a score of less than 5 and that are located in the borough of Manhattan or Brooklyn, and their cuisine is not American.
官方给的这个答案,可以不用最外层的$and
1db.restaurants.find({ 2 $and: [ 3{ $or: [{ borough: &#34;Manhattan&#34; }, { borough: &#34;Brooklyn&#34; }] }, 4{ &#34;grades.score&#34;: { $lt: 5 } }, 5{ cuisine: { $ne: &#34;American&#34; } } 6 ] 7}) 37 Write a MongoDB query to find the restaurants that have at least one grade with a score of less than 5 and that are located in the borough of Manhattan or Brooklyn, and their cuisine is not American or Chinese.
这里用到了不是...,也不是....这个也语法
$nor - MongoDB 手册 v8.0
选择数组中所有查询谓词均未通过的文档
1$nor :[ expr1 ,expr2...] 那么查询的文档满足的条件是：
1expr1(doc1) == false and expr2(doc2) == false 38 Write a MongoDB query to find the restaurants that have a grade with a score of 2 and a grade with a score of 6.
grades 含有2，和6
我写的
1db.restaurants.find({ 2 &#34;grades.score&#34;: 2, 3 &#34;grades.score&#34;: 6, 4 }) 效果一样的官方答案。
1db.restaurants.find({ 2 $and: [ 3 {&#34;grades.score&#34;: 2}, 4 {&#34;grades.score&#34;: 6} 5 ] 6}) 39 Write a MongoDB query to find the restaurants that have a grade with a score of 2 and a grade with a score of 6 and are located in the borough of Manhattan.
没有什么难度
1db.restaurants.find({ 2 $and: [ 3 {&#34;grades.score&#34;: 2}, 4 {&#34;grades.score&#34;: 6}, 5 {&#34;borough&#34;: &#34;Manhattan&#34;} 6 ] 7}) 40 Write a MongoDB query to find the restaurants that have a grade with a score of 2 and a grade with a score of 6 and are located in the borough of Manhattan or Brooklyn.
1db.restaurants.find({ 2 $and: [ 3 {&#34;grades.score&#34;: 2}, 4 {&#34;grades.score&#34;: 6}, 5 {&#34;borough&#34;: {&#34;$in&#34;: [&#34;Manhattan&#34;, &#34;Brooklyn&#34;]}} 6 ] 7}) `,url:"https://hugo-dead-simple.netlify.com/mongodb/exercise2/"},"https://hugo-dead-simple.netlify.com/mongodb/exercise3/":{title:"MongoDB 练习 3",tags:["MongoDB","Exercises"],content:`41 Write a MongoDB query to find the restaurants that have a grade with a score of 2 and a grade with a score of 6 and are located in the borough of Manhattan or Brooklyn, and their cuisine is not American.
没有什么难度
1db.restaurants.find({ 2 $and: [ 3 {borough: {$in: [&#34;Manhattan&#34;, &#34;Brooklyn&#34;]}}, 4 {&#34;grades.score&#34;: {$all: [2, 6]}}, 5 {cuisine: {$ne: &#34;American&#34;}} 6 ] 7}) 这里用到了$all运算符, 表示后面的值[2,6]都要单独同时匹配
42 Write a MongoDB query to find the restaurants that have a grade with a score of 2 and a grade with a score of 6 and are located in the borough of Manhattan or Brooklyn, and their cuisine is not American or Chinese.
1db.restaurants.find({ 2 $and: [ 3{ borough: { $in: [&#34;Manhattan&#34;, &#34;Brooklyn&#34;] } }, 4{ cuisine: { $nin: [&#34;American&#34;, &#34;Chinese&#34;] } }, 5{ grades: { $elemMatch: { score: 2 } } }, 6{ grades: { $elemMatch: { score: 6 } } } 7 ] 8}) 43 Write a MongoDB query to find the restaurants that have a grade with a score of 2 or a grade with a score of 6.
1db.restaurants.find({ 2 $or: [ 3{ &#34;grades.score&#34;: 2 }, 4{ &#34;grades.score&#34;: 6 } 5 ] 6}) 44 Write a MongoDB query to find the restaurants that have a grade with a score of 2 or a grade with a score of 6 and are located in the borough of Manhattan.
没有什么难度
1db.restaurants.find({ 2 $and: [ 3 { 4 $or: [ 5{ &#34;grades.score&#34;: 2 }, 6{ &#34;grades.score&#34;: 6 } 7 ] 8 }, 9{ &#34;borough&#34;: &#34;Manhattan&#34; } 10 ] 11}) 45 Write a MongoDB query to find the restaurants that have a grade with a score of 2 or a grade with a score of 6 and are located in the borough of Manhattan or Brooklyn.
1db.restaurants.find({ 2 $and: [ 3 { 4 $or: [ 5{ borough: &#34;Manhattan&#34; }, 6{ borough: &#34;Brooklyn&#34; } 7 ] 8 }, 9 { 10 $or: [ 11{ &#34;grades.score&#34;: 2 }, 12{ &#34;grades.score&#34;: 6 } 13 ] 14 } 15 ] 16}) 48 Write a MongoDB query to find the restaurants that have all grades with a score greater than 5.
这个是比较有意思的查询: 所有grade.score都要大于5
正确的查询数组里的值,都是存在,现在要转成\\forall
1db.restaurants.find({ 2 &#34;grades&#34;: { 3 &#34;$not&#34;: { 4 &#34;$elemMatch&#34;: { 5 &#34;score&#34;: { 6 &#34;$lte&#34;: 5 7 } 8 } 9 } 10 } 11}) 49 Write a MongoDB query to find the restaurants that have all grades with a score greater than 5 and are located in the borough of Manhattan.
多个条件,关键就在于这个条件:所有的
50 Write a MongoDB query to find the restaurants that have all grades with a score greater than 5 and are located in the borough of Manhattan or Brooklyn.
不难,这里有一个条件,或者
1db.restaurants.find({ 2 &#34;borough&#34;: { 3 &#34;$in&#34;: [&#34;Manhattan&#34;, &#34;Brooklyn&#34;] 4 }, 5 &#34;grades&#34;: { 6 &#34;$not&#34;: { 7 &#34;$elemMatch&#34;: { 8 &#34;score&#34;: { 9 &#34;$lte&#34;: 5 10 } 11 } 12 } 13 } 14}) `,url:"https://hugo-dead-simple.netlify.com/mongodb/exercise3/"},"https://hugo-dead-simple.netlify.com/mongodb/exercise4/":{title:"MongoDB 练习 4",tags:["MongoDB","Exercises"],content:`51 Write a MongoDB query to find the average score for each restaurant.
一个数组的平均值
这里我遇到的第一个 aggregate
1db.restaurants.aggregate([{ 2 $unwind: &#34;$grades&#34; 3 }, 4 { 5 $group: { 6 _id: &#34;$name&#34;, 7 avgScore: { 8 $avg: &#34;$grades.score&#34; 9 } 10 } 11 } 12]) 这里gpt给出的多种求平均值的方法
在 MongoDB 中，要求数组的平均值可以使用 聚合框架 来处理。MongoDB 的聚合框架提供了强大的数据操作功能，包括计算数组中元素的平均值。可以通过以下几种方式来实现：
假设我们有以下文档集合： 1{ 2 &#34;_id&#34;: 1, 3 &#34;scores&#34;: [90, 80, 70, 85] 4}, 5{ 6 &#34;_id&#34;: 2, 7 &#34;scores&#34;: [60, 75, 85, 90] 8} 方法 1：使用 $avg 操作符 MongoDB 的聚合框架允许在管道中使用 $avg 操作符来计算某个数组的平均值。为了计算数组 scores 的平均值，我们需要先将数组元素展开（使用 $unwind），然后计算平均值。
聚合管道示例： 1db.collection.aggregate([ 2 { 3 $project: { 4 averageScore: { $avg: &#34;$scores&#34; } 5 } 6 } 7]) 解释： $project：用于指定输出的字段，在这里我们指定了一个新字段 averageScore。 $avg：用于计算指定字段的平均值。在这里，我们应用 $avg 操作符来计算 scores 数组的平均值。 方法 2：使用 $unwind 与 $group 来求平均值 如果你想更细粒度地处理数组中的元素，可以使用 $unwind 来展平数组，然后使用 $group 来求数组的平均值。
聚合管道示例： 1db.collection.aggregate([ 2 { $unwind: &#34;$scores&#34; }, 3 { $group: { _id: null, averageScore: { $avg: &#34;$scores&#34; } } } 4]) 解释： $unwind：将 scores 数组中的每个元素展平为单独的文档。每个文档将包含一个数组元素。 $group：将所有展平后的文档组合在一起，并使用 $avg 来计算这些文档中 scores 字段的平均值。 这个方法适用于当你希望对数组中的所有元素进行处理并计算平均值的情况。
方法 3：直接计算字段的平均值 如果数组字段本身已经包含了所有的数值，且你只想计算这个数组字段的平均值，而不是数组中的每个元素，可以直接在 aggregate 阶段中计算平均值：
示例： 1db.collection.aggregate([ 2 { 3 $project: { 4 averageScore: { $avg: &#34;$scores&#34; } 5 } 6 } 7]) 总结： $avg 用于计算一个数值字段的平均值，可以直接在聚合管道中对数组字段进行操作。 $unwind + $group 适用于需要将数组元素分开处理，并求所有元素的平均值。 根据需求选择适合的方法，通常情况下，直接使用 $avg 对数组字段求平均值最为简单和高效。
52 Write a MongoDB query to find the highest score for each restaurant.
这里用到了 $group阶段的$max操作
1db.restaurants.aggregate([{ 2 $unwind: &#34;$grades&#34; 3 }, 4 { 5 $group: { 6 _id: &#34;$name&#34;, 7 highest_score: { 8 $max: &#34;$grades.score&#34; 9 } 10 } 11 } 12]) 53 Write a MongoDB query to find the lowest score for each restaurant.
和上一个题目一样，用$min
1db.restaurants.aggregate([{ 2 $unwind: &#34;$grades&#34; 3 }, 4 { 5 $group: { 6 _id: &#34;$name&#34;, 7 lowest_score: { 8 $min: &#34;$grades.score&#34; 9 } 10 } 11 } 12]) 54 Write a MongoDB query to find the count of restaurants in each borough.
用到了count
1db.restaurants.aggregate([{ 2 $group: { 3 _id: &#34;$borough&#34;, 4 count: { 5 $sum: 1 6 } 7 } 8}]) 55 Write a MongoDB query to find the count of restaurants for each cuisine.
只是用到了$sum
1db.restaurants.aggregate([{ 2 $group: { 3 _id: &#34;$cuisine&#34;, 4 count: { 5 $sum: 1 6 } 7 } 8}]) 56 如何按两个值进行分组 1db.restaurants.aggregate([{ 2 $group: { 3 _id: { 4 cuisine: &#34;$cuisine&#34;, 5 borough: &#34;$borough&#34; 6 }, 7 count: { 8 $sum: 1 9 } 10 } 11}]) 57 多阶段配合 Write a MongoDB query to find the count of restaurants that received a grade of &lsquo;A&rsquo; for each cuisine.
多阶段
unwind match group 1db.restaurants.aggregate([ 2 { 3 $unwind: &#34;$grades&#34; 4 }, 5 { 6 $match: { &#34;grades.grade&#34;: &#34;A&#34; } 7 }, 8 { 9 $group: { 10 _id: &#34;$cuisine&#34;, 11count: { $sum: 1 } 12 } 13 } 14]) 58 同上 Write a MongoDB query to find the count of restaurants that received a grade of &lsquo;A&rsquo; for each borough.
1db.restaurants.aggregate([ 2 { 3 $unwind: &#34;$grades&#34; 4 }, 5 { 6 $match: { &#34;grades.grade&#34;: &#34;A&#34; } 7 }, 8 { 9 $group: { 10 _id: &#34;$borough&#34;, 11count: { $sum: 1 } 12 } 13 } 14]) 59 Write a MongoDB query to find the count of restaurants that received a grade of &lsquo;A&rsquo; for each cuisine and borough.
聚合确实能达到
这里没有unwind
1db.restaurants.aggregate([ 2 { 3 $match: { &#34;grades.grade&#34;: &#34;A&#34; } 4 }, 5 { 6 $group: { 7 _id: { cuisine: &#34;$cuisine&#34;, borough: &#34;$borough&#34; }, 8count: { $sum: 1 } 9 } 10 }, 11 { 12 $sort: { count: -1 } 13 } 14]); 60 Write a MongoDB query to find the number of restaurants that have been graded in each month of the year.
问一年中，每个月分评级的restaurants分别有多少个,那显然要$group
1db.restaurants.aggregate([ 2 { 3 $unwind: &#34;$grades&#34; 4 }, 5 { 6 $project: { 7month: { $month: { $toDate: &#34;$grades.date&#34; } }, 8year: { $year: { $toDate: &#34;$grades.date&#34; } } 9 } 10 }, 11 { 12 $group: { 13 _id: { month: &#34;$month&#34;, year: &#34;$year&#34; }, 14count: { $sum: 1 } 15 } 16 }, 17 { 18 $sort: { 19 &#34;_id.year&#34;: 1, 20 &#34;_id.month&#34;: 1 21 } 22 } 23]); 61-66 平均分,最高低分 上面求过了
67 Write a MongoDB query to find the name and address of the restaurants that received a grade of &lsquo;A&rsquo; on a specific date
查询一个array里满足特定条件的。
1db.restaurants.find( 2 { 3 &#34;grades&#34;: { 4 &#34;$elemMatch&#34;: { 5 &#34;date&#34;: { 6 &#34;$eq&#34;: ISODate(&#34;2013-07-22T00:00:00Z&#34;) 7 }, 8 &#34;grade&#34;: { 9 &#34;$eq&#34;: &#34;A&#34; 10 } 11 } 12 } 13 }, 14 { 15 &#34;name&#34;: 1, 16 &#34;address&#34;: 1, 17 &#34;_id&#34;: 0 18 } 19) 68 Write a MongoDB query to find the name and address of the restaurants that received a grade of &lsquo;B&rsquo; or &lsquo;C&rsquo; on a specific date.
1db.restaurants.find( 2 { 3 &#34;grades&#34;: { 4 $elemMatch: { 5 &#34;date&#34;: ISODate(&#34;2013-04-05&#34;), 6 &#34;grade&#34;: { $in: [ &#34;B&#34;, &#34;C&#34; ] } 7 } 8 } 9 }, 10 { 11 &#34;name&#34;: 1, 12 &#34;address&#34;: 1 13 } 14) 69 Write a MongoDB query to find the name and address of the restaurants that have at least one &lsquo;A&rsquo; grade and one &lsquo;B&rsquo; grade.
啊！ 查询数组里： 至少含有一个A，且至少含有一个B ,\\exits A in arr \\and \\exits B in arr
70 Write a MongoDB query to find the name and address of the restaurants that have at least one &lsquo;A&rsquo; grade and no &lsquo;B&rsquo; grades.
one A no B.两个条件同时成立
no b -&gt; not exits b in Arr -&gt; {$not : { &quot;grades.score&quot; : 'A'}
和我想的差不多
1db.restaurants.find({ 2 $and: [ 3{ &#34;grades.grade&#34;: &#34;A&#34; }, 4{ &#34;grades.grade&#34;: { $not: { $eq: &#34;B&#34; } } } 5 ] 6}, 7{ name: 1, address: 1, _id: 0 }) 71 Write a MongoDB query to find the name ,address and grades of the restaurants that have at least one &lsquo;A&rsquo; grade and no &lsquo;C&rsquo; grades.
同上
1db.restaurants.find({ 2 $and: [ 3{ &#34;grades.grade&#34;: &#34;A&#34; }, 4{ &#34;grades.grade&#34;: { $not: { $eq: &#34;C&#34; } } } 5 ] 6}, 7{ name: 1, address: 1, &#34;grades.grade&#34;:1, _id: 0 }) 72 Write a MongoDB query to find the name, address, and grades of the restaurants that have at least one &lsquo;A&rsquo; grade, no &lsquo;B&rsquo; grades, and no &lsquo;C&rsquo; grades.
同上
1db.restaurants.find({ 2 $and: [ 3{ &#34;grades.grade&#34;: &#34;A&#34; }, 4{ &#34;grades.grade&#34;: { $not: { $eq: &#34;B&#34; } } }, 5{ &#34;grades.grade&#34;: { $not: { $eq: &#34;C&#34; } } } 6 ] 7}, 8{ name: 1, address: 1, &#34;grades.grade&#34;:1, _id: 0 }) 73 Write a MongoDB query to find the name and address of the restaurants that have the word &lsquo;coffee&rsquo; in their name
正则
1db.restaurants.find({ name: { $regex: /coffee/i } }, { name: 1, address: 1 }) 74 Write a MongoDB query to find the name and address of the restaurants that have a zipcode that starts with &lsquo;10&rsquo;.
这里我觉得官方给的答案不对。
75 Write a MongoDB query to find the name and address of the restaurants that have a cuisine that starts with the letter &lsquo;B&rsquo;.
1db.restaurants.find( 2	{ &#34;cuisine&#34;: { $regex: /^B/ } }, 3	{ &#34;name&#34;: 1, 4	&#34;address&#34;: 1, 5	&#34;cuisine&#34; : 1, 6	&#34;_id&#34;: 0 } 7) 76 77 正则 没有什么好写的
78 找最大值，那就需要排序
1db.restaurants.aggregate([ 2 {$unwind: &#34;$grades&#34;}, 3 {$group: { 4 _id: &#34;$restaurant_id&#34;, 5avgScore: {$avg: &#34;$grades.score&#34;} 6 }}, 7 {$sort: {avgScore: -1}}, 8 {$limit: 1}, 9 {$project: {_id: 1, avgScore: 1}} 10]) 79 找最大的值A的那些restaurants的id，用到聚合
1db.restaurants.aggregate([ 2 {$unwind: &#34;$grades&#34;}, 3 {$match: {&#34;grades.grade&#34;: &#34;A&#34;}}, 4 {$group: { 5 _id: &#34;$restaurant_id&#34;, 6count: {$sum: 1} 7 }}, 8 {$sort: {count: -1}}, 9 {$group: { 10 _id: &#34;$count&#34;, 11restaurants: {$push: &#34;$_id&#34;} 12 }}, 13 {$sort: {_id: -1}}, 14 {$limit: 1}, 15 {$project: {restaurants: 1}} 16]) 80 Write a MongoDB query to find the cuisine type that is most likely to receive a &lsquo;C&rsquo; grade.
哪个区域的C最多,用到了聚合
1db.restaurants.aggregate([ 2 {$unwind: &#34;$grades&#34;}, 3 {$match: {&#34;grades.grade&#34;: &#34;C&#34;}}, 4 {$group: {_id: &#34;$cuisine&#34;, count: {$sum: 1}}}, 5 {$sort: {count: -1}} 6]) 81 Write a MongoDB query to find the restaurant that has the highest average score for thecuisine &ldquo;Turkish&rdquo;.
聚合。
82 Write a MongoDB query to find the restaurants that achieved the highest total score.
连续的聚合,聚合就是一种管道。
1db.restaurants.aggregate([ 2{ $unwind: &#34;$grades&#34; }, 3{ $group: { 4 _id: &#34;$name&#34;, 5totalScore: { $sum: &#34;$grades.score&#34; } 6 }}, 7{ $sort: { totalScore: -1 } }, 8{ $group: { 9 _id: &#34;$totalScore&#34;, 10restaurants: { $push: &#34;$_id&#34; } 11 }}, 12{ $sort: { _id: -1 } }, 13{ $limit: 1 }, 14{ $unwind: &#34;$restaurants&#34; }, 15{ $group: { 16 _id: &#34;$_id&#34;, 17restaurants: { $push: &#34;$restaurants&#34; } 18 }} 19]) 83 `,url:"https://hugo-dead-simple.netlify.com/mongodb/exercise4/"},"https://hugo-dead-simple.netlify.com/tags/querying/":{title:"Querying",tags:[],content:"",url:"https://hugo-dead-simple.netlify.com/tags/querying/"},"https://hugo-dead-simple.netlify.com/tags/":{title:"Tags",tags:[],content:"",url:"https://hugo-dead-simple.netlify.com/tags/"},"https://hugo-dead-simple.netlify.com/typescript/typeof%E7%9A%84%E4%BD%BF%E7%94%A8/":{title:"typeof的使用",tags:[],content:`在 TypeScript 中，typeof 是一个非常强大的运算符，它有两个主要用途：一种用于 获取值的类型，另一种用于 获取类型的构造函数。下面我们分别解释这两种用途，并给出一些示例。
1. typeof 用于获取值的类型 在 TypeScript 中，typeof 可以用来获取一个值的类型。你可以通过 typeof 来推断或显式地获取变量的类型。
示例：获取值的类型 1let x = &#34;hello&#34;; 2let y: typeof x; // y 的类型会自动推断为 string 3 4y = &#34;world&#34;; // 正确 5// y = 42; // 错误: 类型 &#39;number&#39; 不能赋值给类型 &#39;string&#39; typeof x 会推断出变量 x 的类型。在这个例子中，x 是一个 string，所以 y 的类型也会被推断为 string。 你可以将 typeof 用于变量声明，或者在类型注解中指定类型。 示例：获取对象属性的类型 1const person = { name: &#34;Alice&#34;, age: 30 }; 2let nameType: typeof person.name; // nameType 的类型是 string 3let ageType: typeof person.age; // ageType 的类型是 number 这里，typeof person.name 会得到 person.name 的类型（即 string），typeof person.age 会得到 number。 2. typeof 用于获取类型 typeof 还可以用来获取 类型的构造函数，特别是在你需要引用某个类型或类型的构造函数时。这个用途通常与 keyof 一起使用来限制某个值的类型。
示例：获取类的构造函数类型 1class Person { 2 name: string; 3 constructor(name: string) { 4 this.name = name; 5 } 6} 7 8let PersonConstructor: typeof Person; // PersonConstructor 的类型是 \`typeof Person\`，即构造函数类型 9PersonConstructor = Person; // 正确 10// PersonConstructor = String; // 错误: 类型 &#39;typeof String&#39; 不兼容类型 &#39;typeof Person&#39; 在这个例子中，typeof Person 会获取 Person 类的构造函数类型，即 typeof Person 实际上是 new (name: string) =&gt; Person，表示可以用来创建 Person 实例的构造函数类型。 示例：通过 typeof 引用类型构造函数 1let x: number = 42; 2let y: typeof x; // y 的类型是 number 3y = 123; // 正确 4// y = &#34;hello&#34;; // 错误: 类型 &#39;string&#39; 不能赋值给类型 &#39;number&#39; 这里，typeof x 取得了 x 的类型，x 是 number 类型，因此 y 的类型也是 number。 3. typeof 用于类型推断与类型保护 typeof 还可以用于类型保护，即在类型判断中帮助我们明确变量的类型。这对于某些复杂的类型检查很有用。
示例：typeof 在类型保护中的应用 1function printLength(value: string | string[]) { 2 if (typeof value === &#34;string&#34;) { 3 console.log(value.length); // value 是 string 类型 4 } else { 5 console.log(value.length); // value 是 string[] 类型 6 } 7} 8 9printLength(&#34;Hello&#34;); // 输出: 5 10printLength([&#34;a&#34;, &#34;b&#34;, &#34;c&#34;]); // 输出: 3 typeof value === &quot;string&quot; 用来判断 value 是否是 string 类型，帮助 TypeScript 确定在 if 语句块中的类型。 同理，可以使用 typeof 来判断其他基本类型，如 number、boolean 等。 4. typeof 用于联合类型和字面量类型的推断 typeof 也能用来推断字面量类型（literal types）。
示例：推断字面量类型 1const color = &#34;red&#34;; 2type Color = typeof color; // Color 的类型是 &#34;red&#34; 3 4let myColor: Color = &#34;red&#34;; // 正确 5// let anotherColor: Color = &#34;blue&#34;; // 错误: 类型 &#39;&#34;blue&#34;&#39; 不能赋值给类型 &#39;&#34;red&#34;&#39; 在这个例子中，typeof color 会推断出 color 变量的字面量类型 &quot;red&quot;，因此 Color 类型实际上是 &quot;red&quot;，而不是 string。 总结 typeof 获取值的类型：你可以用 typeof 获取一个变量或对象的类型，通常用于类型推断或动态类型赋值。 typeof 获取构造函数类型：当你使用 typeof 对类进行操作时，它会获取类的构造函数类型，可以用于引用类型的构造函数。 类型保护：typeof 在类型保护中可以帮助你根据值的类型做出判断。 字面量类型推断：typeof 可以用于推断变量的字面量类型，从而实现更精确的类型定义。 通过 typeof，你可以更灵活地在 TypeScript 中进行类型推断、类型保护和类型约束，增强代码的类型安全性和可维护性。
`,url:"https://hugo-dead-simple.netlify.com/typescript/typeof%E7%9A%84%E4%BD%BF%E7%94%A8/"},"https://hugo-dead-simple.netlify.com/typescript/typescript_program/":{title:"typescript_program",tags:[],content:` 本文由 简悦 SimpRead 转码， 原文地址 chengjingchao.com
第 1 章 导言使用 TypeScript 开发的程序更安全，常见的错误都能检查出来，写出的代码还可以作为文档。
发表于 2022-01-01 | 更新于: 2022-01-06
使用 TypeScript 开发的程序更安全，常见的错误都能检查出来，写出的代码还可以作为文档。
更安全是指类型安全
类型安全：借助类型避免程序做无效的事情（无效指的是运行时程序崩溃或未崩溃，但做的事情毫无意义
举个 🌰
数字乘以一个列表
接收数字的函数却传入了字符串
调用对象上不存在的方法
导入已经被移除的模块
13 + [] // &#34;3&#34; 2 3 4let obj = {} 5obj.foo // undefined 6 7 8function a(b) { 9 return b/2 10} 11a(&#39;z&#39;) // NaN 在做无效事情的时候，JavaScript 没有抛出异常，而是尽自己所能，避免抛出异常。
而 JavaScript 这种特性让代码中错误的产生与发现脱节了。导致 bug 往往是由他人转告给你的。 到真正运行时可能才会发现错误。
而 TypeScript 给出错误的时间点：在输入代码的过程中，代码编辑器会给出错误消息，来提醒你。
13 + [] // Error TS2365: Operator &#39;+&#39; cannot be applied to types &#39;3&#39; and &#39;never[]&#39;. 2 3 4let obj = {} 5obj.foo // Error TS2339: Property &#39;foo&#39; does not exist on type &#39;{}&#39; 6 7function (a: number) { 8 return b / 2 9} 10a(&#39;z&#39;) // Error TS2345: Argument of type &#39;&#34;z&#34;&#39; is not assignable to parameter of type &#39;number&#39;. 编译器 TypeScript 编译器（TSC）
通常运行程序的大致流程
把程序解析为 AST AST 编译成字节码 运行时计算字节码 运行程序就是让运行时计算由编译器从源码解析得来的 AST 生成的字节码。
TypeScript 的特殊之处在于，不直接编译成字节码，而是编译成 JavaScript。然后再像往常一样，在浏览器 / NodeJS 中运行。
TypeScript 编译器生成 AST 之后，真正运行代码之前会对代码做类型检查。
类型检查器：检查代码是否符合安全要求的特殊程序
编译和运行 TypeScript (1-3 由 TSC 操作，4-6 由浏览器 / NodeJS 操作)
TypeScript 源码 -&gt; TypeScript AST
类型检查器检查 AST
TypeScript AST -&gt; JavaScript 源码
JavaScript 源码 -&gt; JavaScript AST
AST -&gt; 字节码
运行时计算字节码
类型只在类型检查这一步使用，TSC 把 TS 编译成 JS 时，不会考虑类型。可以确保可以随意改动、更新和改进程序中的类型，而无需担心会破坏应用的功能。
类型系统 类型系统：类型检查器为程序分配类型时使用的一系列规则
一般来说，类型系统有两种，各有利弊
通过显式句法告诉编译器所有值的类型 自动推导值的类型 JavaScript 在运行时推导类型 TypeScript 身兼两种类型系统，可以显式注解类型，也可以自动推导多数类型。
显示声明类型需要使用注解。注解的形式 value: type，就像是告诉类型检查器，“嘿，看到这个 value 了吗？它的类型是 type。”
1// 显示注解 2let a: number = 1 3let b: string = &#39;hello&#39; 4let c: boolean[] = [true, false] 5 6// 自动推导 7let a = 1; 8let b = &#39;hello&#39; 9let c = [true, false] TypeScript VS JavaScript 类型系统特性JavaScriptTypeScript类型是如何绑定的？动态静态是否自动转换类型？是否（多数时候）何时检查类型？运行时编译时何时报告错误？运行时（多数时候）编译时（多数时候） TypeScript 能做的是把纯 JavaScript 代码中那些运行时愈发和类型相关的错误提前到编译时报告。在代码编辑器中显示，输入代码后立即就有反馈。
类型是如何绑定的？ JavaScript 动态绑定类型，必须运行程序才能知道类型。 TypeScript 渐进式类型语言，在编译时知道所有类型
类型：一系列值及对其执行的操作
example
类型包含的值可以执行的操作booleantrue、false||、&&、!number所有数字+、-、*、/、%、&&、? .toFixed()、.toString()string所有字符串+、||、&& .concat()、.toUpperCase() 对 T 类型的值来说，我们不仅知道值的类型是 T，还知道可以 / 不可以对该值做什么操作。 类型检查器通过使用的类型和具体用法判断是否有效。
TypeScript 的类型层次结构 类型术语 类型注解（可以理解为某种界限
1function squareOf(n: number) { 2 return n * n; 3} 4squareOf(2); // 4 类型浅谈 any 在 TypeScript 中，编译时一切都要有类型，如果你和 TypeScript（类型检查器）无法确认类型是什么，默认为 any。这是兜底类型，应该尽量避免使用。
类型的定义（一系列值及可以对其执行的操作）any 包含所有值，而且可以对其做什么操作。any 类型的值就像常规的 JavaScript 一样，类型检查器完全发挥不了作用。
使用 any 需要显示注解。
tsconfig.json noImplicitAny: true;
noImplicitAny 隶属于 TSC 的 strict 标志家族，
unknown unknown 与 any 类似，也表示任何值。但是 TypeScript 会要求你在做检查，细化类型。
类型包含的值可以执行的操作unknown==、===、||、&amp;&amp;、?、!、typeof、instance of 1// example 2let a: unknown = 30; // unknown 3let b = a === 123; // boolean 4let c = a + 10; // Error TS 2571: Object is of type &#39;unknown&#39; 5if (typeof a === &#39;number&#39;) { 6 let d = a + 10; // number 7} unknown 的用法
TypeScript 不会把任何值推导为 unknown 类型，必须显示注解（a） unknown 类型的值可以比较（b） 执行操作时不能假定 unknown 类型的值为某种特定类型（c），必须先向 TypeScript 证明一个值确实是某个类型（d） boolean 类型包含的值可以执行的操作booleantrue、false==、===、||、&amp;&amp;、? 1// example 2let a = true // boolean 3let b = false // boolean 4const c = true // true 5let d: boolean = true // boolean 6let e: true = true // true 7let f: true = false // Error TS2322: Type &#39;false&#39; is not assignable to type &#39;true&#39;. TypeScript 推导出值的类型为 boolean（a 和 b） 使用 const，让 TypeScript 推导出值为某个具体的布尔值（c） 显式注解，声明值的类型为 boolean（d） 显式注解，声明值为某个具体的布尔值（e 和 f）。把类型设定为某个值，就限制了 e 和 f 在所有布尔值中只能取指定的那个值。这种特性被称为类型字面量。 类型字面量——仅表示一个值的类型
变量 e f 是使用类型字面量显示注解了变量，变量 c 则是由 TypeScript 推导出一个字面量类型，因为使用的是 const。 const 声明的基本类型的值，赋值之后无法修改，因此 TypeScript 推导出的是范围最窄的类型，所以 TypeScript 推导出的 c 的类型为 true，而不是 boolean。
number 类型包含的值可以执行的操作number整数、浮点数、正数、负数、Infinity、NaN 等算术运算 比较 1// example 2let a = 1234 // number 3let b = Infinity * 0.1 // number 4const c = 5678 // 5678 5let d = a &lt; b // boolean 6let e: number = 100 // number 7let f: 26.218 = 26.218 // 26.218 8let g: 26.218 = 10 // Error TS2322: Type &#39;10&#39; is not assignable to type &#39;26.218&#39; TypeScript 推导出值的类型为 number（a 和 b） 使用 const，让 TypeScript 推导出值为某个具体的数字（c） 显式注解，声明值的类型为 number（e） 显式注解，声明值为某个具体的数字（f 和 g） tips：处理较长的数字时可以使用数字分隔符。
1let oneMillion = 1_000_ 000 // 等同于 1000000 2let twoMillion: 2_000_000 = 2_000_000 bigint 是 JavaScript 和 TypeScript 新引入的类型，在处理较大的整数时，不用再担心舍入误差。
number 类型表示的整数最大为 253，bigint 可以表示任意大的整数。
类型包含的值可以执行的操作bigint所有 BigInt 数算术运算 比较 1// example 2let a = 1234n // bigint 3const b = 5678n // 5678n 4let c = a + b // bigint 5let d = a &lt; 1235 // boolean 6let e = 88.5n // Error TS1353: A bigint literal must be an integer. 7let f: bigint = 100n // bigint 8let g: 100n = 100n // 100n 9let h: bigint = 100 // Error TS2322: Type &#39;100&#39; is not assignable ty type &#39;bigint&#39;. 与 boolean 和 number 一样，声明 bigint 类型也有四种方式。尽量让 TypeScript 自动推导。
string 类型包含的值可以执行的操作string所有字符串字符串可以进行的操作 例如 +、.slice() 1// example 2let a = &#39;hello&#39; // string 3let b = &#39;billy&#39; // string 4const c = &#39;!&#39; // ! 5let d = a + &#39; &#39; + b + c // string 6let e: string = &#39;zoom&#39; // string 7let f: &#39;john&#39; = &#39;john&#39; // john 8let g: &#39;john&#39; = &#39;zoe&#39; // Error TS2322: Type &#39;zoe&#39; is not assignable to type &#39;john&#39; 同样也是尽量让 TypeScript 自动推导 string 类型。
symbol symbol 经常用于代替对象和映射的字符串健，防止被意外设置。 symbol 的类型就是 symbol，每一个 symbol 都是唯一的，不与其他任何符号相等，即便再使用相同的名称创建一个 symbol 也是如此。
1// example 2let a = Symbol(&#39;a&#39;) // symbol 3let b: symbol = Symbol(&#39;b&#39;) // symbol 4let c = a === b // boolean 5let d = a + &#39;x&#39; // Error TS2469: The &#39;+&#39; operator cannot be applied to type &#39;symbol&#39;. 1// example 2const e = Symbol(&#39;e&#39;) // unique symbol 3const f: unique symbol = Symbol(&#39;f&#39;) // unique symbol 4let g: unique symbol = Symbol(&#39;f&#39;) // Error TS1332: A variable whose type is a &#39;unique symbol&#39; type must be &#39;const&#39;. 5let h = e === e // boolean 6let i = e === f // Error TS2367: This condition will always return &#39;false&#39; since the type &#39;unique symbol&#39; and &#39;unique symbol&#39; have no overlap. 创建 symbol 的方式
使用 const，TypeScript 会推导为 unique symbol 类型。 显式注解 const 变量的类型为 unique symbol unique symbol 类型的值始终与自身相等 TypeScript 在编译时知道一个 unique symbol 绝对不会与另一个 unique symbol 相等 unique symbol 与其他字面量类型其实是一样的。
对象 TypeScript 的对象类型表示对象的结构。
结构化类型–一种编程设计风格，只关心对象有哪些属性，而不管属性使用什么名称（名义化类型）。在某些语言中也叫鸭子类型（即不以貌取人）
1// example 2let b: object = { 3 b: &#39;x&#39; 4} 5a.b // Error TS2339: Property &#39;b&#39; does not exist on type &#39;object&#39;. object 只能表示该值是一个 JavaScript 对象（而且不是 null）
1// 对象字面量 2 3// 自动推导 4let a = { 5 b: &#39;x&#39; 6} 7 8// or 9let a: { b: string } = { 10 b: &#39;x&#39; 11} 对象字面量句法的意思是，“这个东西的结构是这样过的。”
使用 const 声明对象不会导致 TypeScript 把推导的类型缩窄。与上面的基本类型不同。这是因为 JavaScript 对象是可变的，所以在 TypeScript 看来，创建对象之后你可能会更新对象的字段。
1let a: { b: number } 2b = {} // Error TS2741: Property &#39;b&#39; is missing in type &#39;{}&#39; but required in type &#39;{b: number}&#39;. 3 4b = { 5 a: 1, 6 b: 2 7} // Error TS2322: Type &#39;{b: number; c: number}&#39; is not assignable to type &#39;{b: number}&#39;. Object literal may only specify known properties, and &#39;c&#39; does not exist in type &#39;{b: number}&#39;. 默认情况下，TypeScript 对对象的属性要求十分严格。如果声明对象有个类型为 number 的属性 b，TypeScript 将预期对象有且只有这个属性。缺少或者多了，TypeScript 都会报错。
1let a: { 2 b: number 3 c?: string // 可能有个类型为 string 的属性 c。其值可以为 undefined 4 readonly firstName: string // 为字段赋初始值后无法修改。类似于使用 const 声明对象的属性 5 [key: number]: boolean // 可能有任意多个数字属性，其值为布尔值 6} [key: T]: U 句法称为索引签名，通过这种方式告诉 TypeScript，指定的对象可能有更多的 key。这种句法的意思是，“在这个对象中，类型为 T 的健对应的值为 U 类型。”
索引签名 key 的类型 T 必须可赋值给 number 或 string。（JavaScript 对象的健为字符串；数组是特殊的对象，健为数字。） key 的名称可以是任意词，不一定非的用 key 对象字面量表示法有一个特例：空对象类型 {}。除 null 和 undefined 之外的任何类型都可以赋值给空对象类型，应该尽量避免使用。
在 TypeScript 中声明对象类型有四种方式
对象字面量表示法 {a: string}，也称对象结构 空对象字面量表示法 {}。避免使用 object 类型。如果需要个对象，当对这个对象的字段没有要求，使用这种方式。 Object。避免使用 对一个值，在类型允许的情况下，可以对其执行特定的操作。其实在类型自身上也可以执行一些操作。
类型别名
1type Age = number 2 3type Person = { 4 name: string 5 age: Age 6} 7 8let driver: Person = { 9 name: &#39;Jack&#39; 10 age: 18 11} 类型别名采用块级作用域。在同一作用于中不能重复声明相同类型。
并集和交集
1type Cat = { name: string, purrs: boolean } 2type Dog ={ name: string, barks: boolean, wags: boolean } 3 4type CatOrDogOrBoth = Cat | Dog // 并集 5type CatAndDog = Cat &amp; Dog // 交集 6 7// CatOrDogOrBoth 可以是 Cat 类型的值，可以是 Dog 类型的值，还可以二者兼具。 8// Cat 9let a: CatOrDogOrBoth = { 10 name: &#39;Bonkers&#39;, 11 purrs: true 12} 13 14// Dog 15a = { 16 name: &#39;Domino&#39;, 17 barks: true, 18 wags: true 19} 20 21// 二者兼具 22a = { 23 name: &#39;Donkers&#39;, 24 barsk: true, 25 purrs: true, 26 wags: true 27} 28 29// CatAndDot 30let b: CatAndDog = { 31 name: &#39;Domino&#39;, 32 barks: true, 33 purrs: true, 34 wags: true 35} 并集通常更常用
函数返回值可能是一个字符串，也可能是 null。string | null 混合类型的数组 数组
1let a = [1, 2, 3] // number[] 2let b = [&#39;a&#39;, &#39;b&#39;] // string[] 3let c: string[] = [&#39;a&#39;] // string[] 4let d = [1, &#39;a&#39;] // (number | string)[] 5const e = [2, &#39;b&#39;] // (number | string)[] 6let f = [&#39;red&#39;] // string[] 7 8f.push(&#39;blue&#39;) 9f.push(true) // Error TS2345: Argument of type &#39;true&#39; is not assignable to parameter of type &#39;string&#39;. 10 11let g = [] // any[] 12g.push(1) // number[] 13g.push(&#39;red&#39;) // (number | string)[] 14 15let h: number[] = [] // number[] 16h.push(1) // number[] 17h.push(&#39;red&#39;) // Error TS2345: Argument of type &#39;&#34;red&#34;&#39; is not assignable to parameter of type &#39;number&#39;. TypeScript 支持两种注解数组类型的句法
T[] Array 一般情况下，数组应该保持同质。
元祖
array 的子类型，长度固定，各索引位上的值具有固定的已知类型。
声明元组时必须显式注解类型。
1let a: [number] = 1 2let b: [string, string, number] = [&#39;jack&#39;, &#39;boy&#39;, 1963] 3b = [&#39;tom&#39;, &#39;boy&#39;, &#39;li&#39;, 1926] // Error TS2322: Type &#39;string&#39; is not assignable to type &#39;number&#39;. 元组也支持可选元素
1let trainFares: [number, number?][] = [ 2 [3.75], 3 [8.25, 7.70], 4 [10.60], 5] 6 7// 等价于 8let moreTrainFares: ([number, number] | [number])[] = [ 9 // ... 10] 元组也支持剩余元素，即为元组定义最小长度
1// 字符串列表，至少有一个元素 2let friends: [string, ...string[]] = [&#39;Sara&#39;, &#39;Tali&#39;, &#39;Chloe&#39;, &#39;Claire&#39;] 3 4// 元素类型不同的列表 5let list: [number, boolean, ...string[]] = [1, false, &#39;a&#39;, &#39;b&#39;, &#39;c&#39;] 只读数组和元祖
1let as: readonly number[] = [1, 2, 3] // readonly number[] 2let bs: readonly number[] = as.concat(4) // readonly number[] 3let three = bs[2] // number 4as[4] = 5 // Error TS2542: Index signature in type &#39;readonly number[]&#39; only permits reading. 5as.push(6) // Error TS2339: Property &#39;push&#39; does not exist on type &#39;readonly number[]&#39;. 6 7// Readonly 和 ReadonlyArray 句法 8type A = readonly string[] // readonly string[] 9type B = ReadonlyArray&lt;string&gt; // readonly string[] 10type C = Readonly&lt;string[]&gt; // readonly string[] 11 12type D = readonly [number, string] // readonly [number, string] 13type E = Readonly&lt;[number, string]&gt; // readonly [number, string] null、undefined、void 和 never | 类型 | 含义 | | — | — | | null | 缺少值 | | undefined | 尚未赋值的变量 | | void | 没有 return 语句的函数 | | never | 永不返回的函数 |
1// 返回 never 的函数 2function d() { 3 throw TypeError(&#39;I always error&#39;) 4} 5 6function e() { 7 while (true) { 8 doSomething() 9 } 10} never 是所有类型的子类型，可以赋值给其他任何类型。
枚举
枚举的作用是列举类型中包含的各个值。是一种无序数据结构，把键映射到值上。
枚举可以理解为编译时键固定的对象，访问键时，TypeScript 将检查指定的键是否存在。
枚举分为两种
字符串到字符串之间的映射 字符串到数字之间的映射 1enum Language { 2 English, 3 Spaish, 4 Russian 5} 按约定，枚举名称为大写单数形式。枚举中的键也大写。
TypeScript 可以自动为枚举中的各个成员推导对应的数字，也可以手动设置。
1enum Language { 2 English = 0, 3 Spanish = 1, 4 Russian = 2 5} 枚举中的值访问方式和对象一样
1let myFirstLanguage = Language.Russian 2let mySecondLanguage = Language[&#39;English&#39;] 一个枚举可以分成几次声明，TypeScript 将自动把各部分合并在一起
1enum Language { 2 English = 0, 3 Spanish = 1, 4} 5 6enum Language { 7 Russian = 2 8} meiju
小结 类型子类型booleanBoolean 字面量bigintBigInt 字面量numberNumber 字面量stringString 字面量symbolunique symbolobjectObject 字面量数组元组enumconst enum 声明和调用函数 在 JavaScript 中，函数是一等对象。这意味着，可以向对象那样使用函数
可以赋值给变量 可以作为参数传给其他函数 可以作为函数的返回值 可以赋值给对象和原型 可以赋予属性 可以读取属性 TypeScript 通常会显示注解函数的参数
1function add(a: number, b: number) { 2 return a + b 3} 返回类型能推导出来，不过也可以显示注解
1function add(a: number, b: number): number { 2 return a + b 3} TypeScript 中声明函数
1// 具名函数 2function greet(name: string) { 3 return &#39;hello &#39; + name 4} 5 6// 函数表达式 7let greet2 = function(name: string) { 8 retunr &#39;hello &#39; + name 9} 10 11// 箭头函数表达式 12let greet3 = (name: string) =&gt; { 13 return &#39;hello &#39; + name 14} 15 16// 箭头函数表达式简写 17let greet4 = (name: string) =&gt; &#39;hello &#39; + name 18 19// 函数构造方法 20let greet5 = new Function(&#39;name&#39;, &#39;return &#34;hello &#34; + name&#39;) 除了函数构造方法，其他几种句法在 TypeScript 中都可以放心使用，能够保证类型安全。通常需要注解参数的类型，而返回类型不要求必须注解。 在调用函数时，TypeScript 将检查传入的实参是否于函数形参类型兼容。
可选参数和默认参数 可选参数必须在末尾
1function log(message: string, userId?: string) { 2 let time = new Date().toLocaleTimeString() 3 console.log(time, message, userId || &#39;Not signed in&#39;) 4} 5 6log(&#39;Page loded&#39;) 7log(&#39;User signed in&#39;, &#39;da763be&#39;) 8 9// 默认值参数（类似可选参数功能 10function log(message: string, userId = &#39;Not signed in&#39;) { // userId 会自动推导类型 11 let time = new Date().toLocaleTimeString() 12 console.log(time, message, userId) 13} 14 15// 显式注解默认参数类型 16type Context = { 17 appId?: string 18 userId?: string 19} 20 21function log(message: string, context: Context = {}) { 22 let time = new Date().toLocaleTimeString() 23 console.log(time, message, context.userId) 24} 默认参数更常用，默认参数可以自动类型推导。
多态 上面都是讲的具体类型的用法和用途
boolean string Date[] {a: number} | {b: string} (numbers: number[]) =&gt; number 使用具体类型的前提是类型已知
如果事先不知道需要什么类型 不想限制函数只能接受某个类型
1// example 2function filter(array, f) { 3 let result = [] 4 for (let i = 0; i &lt; array.length; i++) { 5 let item = array[i] 6 if (f(item)) { 7 result.push(item) 8 } 9 } 10 return result 11} 12 13filtre([1, 2, 3, 4], (item) =&gt; item &lt; 3) // [1, 2] 例子中，数组元素的类型可以为 number，不过 filter 函数的作用应该更一般，可以筛选数字数组、字符串数字、对象数组等。 下面通过重载描述下函数签名
1type Filter = { 2 (array: number[], f: (item: number) =&gt; boolean): number[] 3 (array: string[], f: (item: string) =&gt; boolean): string[] 4} 5 6// 加上对象类型 7type Filter = { 8 (array: number[], f: (item: number) =&gt; boolean): number[] 9 (array: object[], f: (item: object) =&gt; boolean): object[] 10} object 无法描述对象的结构，访问数组中元素属性就会报错。 为了解决这种问题，就有了泛形参数
泛型参数——在类型层面施加约束的占位类型，也称多态类型参数，简称泛形
1// example 2type Filter = { 3 &lt;T&gt;(array: T[], f: (item: T): boolean): T[] 4} 这么做的意思是 Filter 使用了一个泛形参数 T，事先不知道具体类型是什么，调用的时候根据传入的参数推导 T 的类型。
知识点
泛形使用尖括号声明，可以把尖括号理解为 type 关键字，只不过声明的是泛形。 尖括号位置限制泛形作用域尖括号中可以声明任意多个以逗号分隔 T 就是一个类型名称（类似变量名称），可以使用任意名称，通常会使用 T U V W 泛形可以理解为一种约束，把泛形 T 所在位置的类型约束为 T 类型 什么时候绑定泛型 声明泛形的位置不仅限定泛形作用域，还决定什么时候为泛形绑定具体的值
1// 1 在调用签名中声明 2type Filter = { 3 &lt;T&gt;(array: T[], f: (item: T): boolean): T[] 4} 5// 调用函数时为 T 绑定具体类型 6let filter: Filter = (array, f) =&gt; { 7 // ... 8} 9 10 11// 2 在类型别名 Filter 中 12type Filter&lt;T&gt; = { 13 (array: T[], f: (item: T): boolean): T[] 14} 15// 使用 Filter 时显式绑定具体类型 16let filter: Filter&lt;number&gt; = (array, f) =&gt; { 17 // ... 18} 可以在什么地方声明泛形 1// 1 2type Filter = { 3 &lt;T&gt;(array: T[], f: (item: T): boolean): T[] 4} 5 6// 2 7type Filter&lt;T&gt; = { 8 (array: T[], f: (item: T): boolean): T[] 9} 10 11// 3 1 的简写 12type Filter = &lt;T&gt;(array: T[], f: (item: T): boolean): T[] 13 14// 4 2 的简写 15type Filter&lt;T&gt;( = array: T[], f: (item: T): boolean): T[] 16 17// 5 具名函数调用签名，每次调用 filter 时绑定举腿类型 18function filter&lt;T&gt;(array: T[], f: (item: T) =&gt; boolean): T[] { 19 // ... 20} 泛形别名 泛形约束 `,url:"https://hugo-dead-simple.netlify.com/typescript/typescript_program/"},"https://hugo-dead-simple.netlify.com/tags/web%E5%BC%80%E5%8F%91/":{title:"Web开发",tags:[],content:"",url:"https://hugo-dead-simple.netlify.com/tags/web%E5%BC%80%E5%8F%91/"},"https://hugo-dead-simple.netlify.com/frontend/switch_light_drak_theme/":{title:"完美实现 Hugo 博客暗黑模式切换：从原理到实践",tags:["Hugo","Web开发","JavaScript","CSS"],content:`在当今的用户体验设计中，提供暗黑模式（Dark Mode）几乎已成为标配。它不仅能减少眼部疲劳，在低光环境下也更加舒适。本文将详细记录如何为一个 Hugo 网站（实际上适用于任何静态网站）添加一个功能完善、体验流畅的主题切换器。
我们将解决一个常见痛点：页面刷新时的“闪烁”问题，并最终实现一个堪称完美的解决方案。
最终效果 一个位于导航栏的按钮，用于在浅色（Light）和深色（Dark）主题间切换。 用户的选择会被浏览器记住，下次访问时自动应用。 如果用户首次访问，则会根据其操作系统的偏好自动选择主题。 最重要的：页面在加载和刷新时绝不会出现恼人的颜色闪烁。 核心实现原理 我们的主题切换功能主要依赖两大现代 Web 技术的结合：
CSS 自定义属性 (CSS Variables) 通过 JavaScript 操作 HTML 标签的 data-* 属性 基本思路是：我们在 CSS 中定义两套颜色变量，一套用于浅色主题，另一套用于深色主题。然后，通过 JavaScript 动态地在 &lt;html&gt; 根元素上切换一个 data-theme 属性（例如，data-theme=&quot;light&quot; 或 data-theme=&quot;dark&quot;）。CSS 会根据这个属性的值，自动应用对应的颜色变量集，从而实现整个网站的颜色切换。
1/* 基础/浅色主题变量 */ 2:root { 3 --background: #ffffff; 4 --text: #000000; 5 --link: #3366cc; 6 /* ... 其他颜色变量 */ 7} 8 9/* 深色主题变量 */ 10[data-theme=&#39;dark&#39;] { 11 --background: #1b1b1b; 12 --text: #d8d8d8; 13 --link: #88a9e9; 14 /* ... 其他颜色变量 */ 15} 16 17/* 在组件中使用变量 */ 18body { 19 background-color: var(--background); 20 color: var(--text); 21} 22 23a { 24 color: var(--link); 25} 这种方法的优势在于，我们无需加载不同的 CSS 文件，只需改变一个属性，就能高效地重绘整个页面的颜色，非常灵活且性能优秀。
恼人的“闪烁”问题及解决方案 很多主题切换方案都存在一个通病：当用户选择深色模式并刷新页面时，页面会先以默认的浅色模式短暂显示，然后“闪烁”一下再变成深色。
闪烁原因：这是因为负责切换主题的 JavaScript 脚本通常放在 &lt;body&gt; 底部加载。浏览器会先按照 CSS 的默认设置（通常是浅色主题）渲染页面，等 JS 加载并执行后，才把主题切换过来，这个过程就造成了闪烁。
解决方案：答案是在浏览器渲染 &lt;body&gt; 之前就确定好主题。我们将一小段关键的 JavaScript 代码作为内联脚本直接放在 &lt;head&gt; 标签中。
这段脚本的任务非常纯粹：
检查 localStorage 中是否有用户之前保存的主题偏好。 如果没有，则检查用户的操作系统是否偏好深色模式。 根据结果，立即在 &lt;html&gt; 标签上设置 data-theme 属性。 因为这段脚本在 &lt;head&gt; 中，它会比页面的任何可见元素（&lt;body&gt; 内的内容）都先执行，从而确保了浏览器在“第一帧”渲染时就使用了正确的主题，彻底消除了闪烁。
分步实现指南 第 1 步：在 header.html 中添加核心脚本和切换按钮 首先，我们需要将实现无闪烁切换的核心脚本和按钮添加到主题的 header.html 中。
1// filepath: layouts/partials/header.html 2 3&lt;head&gt; 4 {{/* ... 其他 head 内容 ... */}} 5 6 {{/* 核心：防止闪烁的内联脚本 */}} 7 &lt;script&gt; 8 // 在页面加载或切换主题时，此脚本应内联在 &lt;head&gt; 中以避免 FOUC (Flash of Unstyled Content) 9 (function() { 10 const theme = localStorage.getItem(&#39;theme&#39;) || (window.matchMedia(&#39;(prefers-color-scheme: dark)&#39;).matches ? &#39;dark&#39; : &#39;light&#39;); 11 document.documentElement.setAttribute(&#39;data-theme&#39;, theme); 12 })(); 13 &lt;/script&gt; 14 15 {{/* ... 其他 head 内容，如 CSS 链接等 ... */}} 16&lt;/head&gt; 17 18&lt;body&gt; 19 &lt;nav&gt; 20 &lt;ul class=&#34;menu&#34;&gt; 21 {{/* ... 其他菜单项 ... */}} 22 &lt;li&gt;&lt;a href=&#34;/posts&#34;&gt;文章&lt;/a&gt;&lt;/li&gt; 23 {{/* 主题切换按钮 */}} 24 &lt;li&gt;&lt;button id=&#34;theme-switcher&#34; class=&#34;menu-link&#34; type=&#34;button&#34;&gt;🌗&lt;/button&gt;&lt;/li&gt; 25 &lt;/ul&gt; 26 &lt;/nav&gt; 27 {{/* ... */}} 第 2 步：创建处理按钮交互的 JavaScript 接下来，我们创建一个单独的 JS 文件来处理按钮的点击事件。这个脚本可以放在 &lt;body&gt; 底部加载，因为它不负责初始主题的设定，只负责响应用户操作。
1// filepath: static/js/theme-switcher.js 2 3(function() { 4 const themeSwitcher = document.getElementById(&#39;theme-switcher&#39;); 5 if (!themeSwitcher) { 6 return; 7 } 8 9 // 页面加载时，根据当前主题设置按钮图标 10 let currentTheme = document.documentElement.getAttribute(&#39;data-theme&#39;); 11 themeSwitcher.textContent = currentTheme === &#39;dark&#39; ? &#39;☀️&#39; : &#39;🌗&#39;; 12 13 // 监听按钮点击事件 14 themeSwitcher.addEventListener(&#39;click&#39;, () =&gt; { 15 // 切换主题 16 currentTheme = document.documentElement.getAttribute(&#39;data-theme&#39;) === &#39;dark&#39; ? &#39;light&#39; : &#39;dark&#39;; 17 document.documentElement.setAttribute(&#39;data-theme&#39;, currentTheme); 18 19 // 将用户的选择存入 localStorage 20 localStorage.setItem(&#39;theme&#39;, currentTheme); 21 22 // 更新按钮图标 23 themeSwitcher.textContent = currentTheme === &#39;dark&#39; ? &#39;☀️&#39; : &#39;🌗&#39;; 24 }); 25})(); 别忘了在 footer_scripts.html 或类似的地方引入这个脚本： &lt;script src=&quot;{{ &quot;js/theme-switcher.js&quot; | relURL }}&quot;&gt;&lt;/script&gt;
第 3 步：配置 CSS 颜色变量 最后，也是最关键的一步，是配置好我们的 CSS 文件，让它能够响应 data-theme 属性的变化。
1/* filepath: assets/css/main.css */ 2 3/* 默认/浅色主题变量 */ 4:root { 5 --background: #ffffff; 6 --text: black; 7 --link: #3366cc; 8 --card-background: #f9f9f9; 9 /* ... 更多颜色 */ 10} 11 12/* 当 data-theme=&#39;light&#39; 时应用的变量（可选，用于明确指定） */ 13[data-theme=&#39;light&#39;] { 14 --background: #ffffff; 15 --text: black; 16 --link: #3366cc; 17 --card-background: #f9f9f9; 18 /* ... */ 19} 20 21/* 当 data-theme=&#39;dark&#39; 时应用的变量 */ 22[data-theme=&#39;dark&#39;] { 23 --background: #1b1b1b; 24 --text: #d8d8d8; 25 --link: #88a9e9; 26 --card-background: #272727; 27 /* ... 更多颜色 */ 28} 29 30/* ... 之后的 CSS 规则全部使用 var() 来引用颜色 ... */ 31body { 32 background-color: var(--background); 33 color: var(--text); 34} 35 36.subcategory-card { 37 background-color: var(--card-background); 38} 总结 通过将主题决策逻辑前置到 &lt;head&gt; 并结合 CSS 变量，我们构建了一个健壮、高效且用户体验极佳的主题切换系统。这个方案不仅解决了恼人的“闪烁”问题，其模块化的结构也使得未来的样式维护和扩展变得异常简单。希望这篇文章能对你有所帮助！
data-theme 自定义属性原理 1:root { 2 --complimentary: #815205; 3 --text: black; 4 --code: black; 5 --accent-color: #00aaff; 6 --accent-color-light: rgba(0, 170, 255, 0.1); 7 --card-background: #cccccc5f; 8 --card-background-hover: #6e6b6bff; 9 --card-text-color: #100101ff; 10 --shadow-color: rgba(0, 0, 0, 0.1); 11 --text-dim: #444; 12 --link: #3366cc; 13 --link-visited: #795cb2; 14 --code-background: #f3f5f7; 15 --code-border: #eaecf0; 16 --code-border: transparent; 17 --code-hl: #e6e6e6; 18 --border-general: #cccfd4; 19 --table-th: #e1e5ea; 20 --table-tr: #edeff2; 21 --toc-background: #f9f9f9; 22 --toc-border: #aaa; 23 --output-background: #d5dbe3; 24 --output-foreground: #805105; 25} 26 27[data-theme=&#39;light&#39;] { 28 --background: #ffffff; 29} 30 31[data-theme=&#39;dark&#39;] { 32 --background: #1b1b1b; 33 --text: #d8d8d8; 34 --code: #cbcbcb; 35 --accent-color: #00aaff; 36 --accent-color-light: rgba(0, 170, 255, 0.2); 37 --card-background: #272727; 38 --card-background-hover: #444; 39 --card-text-color: #d8d8d8; 40 --shadow-color: rgba(0, 0, 0, 0.3); 41 --text-dim: #a7a7a7; 42 --link: #88a9e9; 43 --link-visited: #a390ca; 44 --code-background: #272727; 45 --code-border: transparent; 46 --code-hl: #5a5a5a; 47 --border-general: #495057; 48 --table-th: #414141; 49 --table-tr: #343434; 50 --toc-background: #343434; 51 --toc-border: #495057; 52 --output-background: #020202; 53} 向我解释上面的代码,并向我解释 data-theme的原理
当然，我很乐意为你解释这段代码以及 data-theme 的工作原理。
简单来说，这段 CSS 代码使用 CSS 变量（也叫自定义属性）和 data- 属性来创建一套灵活的主题系统，可以轻松地在浅色模式 (light mode) 和深色模式 (dark mode) 之间切换。
代码解析 这段代码主要分为三个部分：
1. :root — 全局默认变量 1:root { 2 --complimentary: #815205; 3 --text: black; 4 /* ... 其他变量 ... */ 5} :root 选择器：这个选择器指向文档的根元素，在 HTML 中就是 &lt;html&gt; 标签。在这里定义的变量是全局的，可以在整个页面的任何地方使用。 CSS 变量 (Custom Properties)：以 -- 开头的都是 CSS 变量。你可以把它们看作是值的“占位符”。例如，--text: black; 定义了一个名为 text 的变量，它的值是黑色。 作用：这个部分定义了网站的默认主题，或者说是“基础”颜色。当没有指定特定主题时，网站就会使用这些颜色。 2. [data-theme='light'] — 浅色主题 1[data-theme=&#39;light&#39;] { 2 --background: #ffffff; 3} [data-theme='light']：这是一个属性选择器。它的意思是：“选择任何带有 data-theme 属性并且该属性的值为 light 的元素”。 作用：当 &lt;html&gt; 或 &lt;body&gt; 标签被设置为 &lt;html data-theme=&quot;light&quot;&gt; 时，这个规则就会生效。它定义了浅色主题下的特定变量。在这里，它只定义了 --background 为白色 (#ffffff)。其他没有被重新定义的变量（如 --text）会继续使用 :root 中的默认值。 3. [data-theme='dark'] — 深色主题 1[data-theme=&#39;dark&#39;] { 2 --background: #1b1b1b; 3 --text: #d8d8d8; 4 /* ... 其他变量 ... */ 5} [data-theme='dark']：与上面类似，这个属性选择器会匹配 &lt;html data-theme=&quot;dark&quot;&gt; 这样的元素。 作用：当网站切换到深色模式时，这个规则会生效。它会覆盖 :root 中定义的许多变量，将它们替换为适合在深色背景下显示的颜色值（例如，背景变为深灰色，文字变为浅灰色）。 data-theme 的工作原理 data-theme 是一个自定义数据属性 (Custom Data Attribute)。这是 HTML5 的一个很棒的功能，允许你将自定义的数据存储在 HTML 元素上，而不会影响其样式和行为。
它的工作原理就像一个状态开关 🚦，具体步骤如下：
定义样式：就像你上面提供的 CSS 代码一样，我们为不同的 data-theme 值（如 light 和 dark）定义不同的 CSS 变量。
设置初始状态：在 HTML 的根元素（通常是 &lt;html&gt;）上设置一个初始主题。
1&lt;html data-theme=&#34;light&#34;&gt; 2 &lt;/html&gt; 当页面加载时，浏览器看到 data-theme=&quot;light&quot;，于是 [data-theme='light'] 的 CSS 规则被应用，页面显示为浅色主题。
使用变量：在你的其他 CSS 文件中，你不会直接使用颜色代码，而是使用 var() 函数来调用这些变量。
1body { 2 background-color: var(--background); /* 使用 --background 变量 */ 3 color: var(--text); /* 使用 --text 变量 */ 4} 5 6a { 7 color: var(--link); /* 使用 --link 变量 */ 8} 这样做的好处是，你只需要改变变量的值，所有使用该变量的元素的样式都会自动更新。
用 JavaScript 切换主题：当用户点击一个“切换主题”按钮时，你会用 JavaScript 来改变 &lt;html&gt; 标签上 data-theme 属性的值。
1// 获取 &lt;html&gt; 元素 2const htmlElement = document.documentElement; 3 4// 假设当前是 &#39;light&#39;，我们要切换到 &#39;dark&#39; 5htmlElement.setAttribute(&#39;data-theme&#39;, &#39;dark&#39;); 切换瞬间发生了什么？
当 JavaScript 将 data-theme 的值从 'light' 改为 'dark' 时，浏览器会立即重新计算样式：
之前匹配的 CSS 规则 [data-theme='light'] 不再生效。 新的 CSS 规则 [data-theme='dark'] 开始生效。 所有 CSS 变量（--background, --text 等）的值被立刻更新为深色主题的值。 所有使用了 var() 函数的元素（比如 body）的样式都会自动重新渲染，页面瞬间就从浅色模式变成了深色模式，无需刷新页面。 总结 总而言之，这种方法通过 CSS 变量将设计系统的颜色集中管理，然后利用 data-theme 属性作为开关，最后通过 JavaScript 来“拨动”这个开关，从而实现了一种非常现代化、高效且易于维护的网站主题切换方案。
`,url:"https://hugo-dead-simple.netlify.com/frontend/switch_light_drak_theme/"},"https://hugo-dead-simple.netlify.com/typescript/%E5%AF%B9%E8%B1%A1%E5%AD%97%E9%9D%A2%E9%87%8F/":{title:"对象字面量",tags:[],content:`在 TypeScript 中，对象字面量（Object Literal）是通过花括号 {} 来创建一个对象，并可以直接为其添加属性和值。这与 JavaScript 中的对象字面量使用方式类似，但 TypeScript 为对象字面量提供了类型系统，可以通过类型注解来限制对象的结构。
1. 基本的对象字面量 对象字面量用于创建一个新的对象，可以直接指定其属性和值：
1const person = { 2 name: &#34;Alice&#34;, 3 age: 30 4}; 这里 person 是一个对象字面量，包含了两个属性：name 和 age。
2. 使用类型注解指定对象字面量的类型 TypeScript 允许你为对象字面量指定类型，从而限制对象的属性和类型。这使得代码更加安全，能够防止错误的属性赋值。
示例：使用 type 或 interface 定义对象类型 1interface Person { 2 name: string; 3 age: number; 4} 5 6const person: Person = { 7 name: &#34;Alice&#34;, 8 age: 30 9}; 在这个例子中，Person 是一个接口（interface），它定义了 name 和 age 属性的类型。然后我们通过类型注解 const person: Person 来确保 person 对象符合这个类型。
你也可以使用 type 来定义类型：
1type Person = { 2 name: string; 3 age: number; 4}; 5 6const person: Person = { 7 name: &#34;Alice&#34;, 8 age: 30 9}; 3. 在对象字面量中使用可选属性 在对象字面量中，你可以定义可选属性，通过在属性名后添加 ? 来实现。
1interface Person { 2 name: string; 3 age: number; 4 address?: string; // 可选属性 5} 6 7const person: Person = { 8 name: &#34;Alice&#34;, 9 age: 30 10 // address 是可选的，可以不提供 11}; 在这个例子中，address 属性是可选的，因此你可以在创建 person 对象时不提供该属性。
4. 只读属性 TypeScript 还允许你为对象字面量定义只读属性，这意味着这些属性的值在初始化后不能被修改。可以使用 readonly 修饰符来实现。
1interface Person { 2 readonly name: string; 3 readonly age: number; 4} 5 6const person: Person = { 7 name: &#34;Alice&#34;, 8 age: 30 9}; 10 11// person.name = &#34;Bob&#34;; // 这是不允许的，会报错 在这个例子中，name 和 age 是只读的，因此你不能修改它们的值。
5. 对象字面量与函数类型 你还可以将方法作为对象字面量的一部分来使用。函数类型可以在对象字面量中直接定义。
1interface Person { 2 name: string; 3 greet: () =&gt; void; // greet 是一个函数 4} 5 6const person: Person = { 7 name: &#34;Alice&#34;, 8 greet: () =&gt; { 9 console.log(\`Hello, my name is \${person.name}\`); 10 } 11}; 12 13person.greet(); // 输出：Hello, my name is Alice 6. 使用索引签名 索引签名允许对象字面量具有任意数量的属性，并且这些属性的类型是预定义的。通过 index signature，你可以指定对象可以有任意数量的键，并限制键值的类型。
1interface Dictionary { 2 [key: string]: number; // 键是 string 类型，值是 number 类型 3} 4 5const myDictionary: Dictionary = { 6 apple: 10, 7 banana: 20 8}; 9 10console.log(myDictionary.apple); // 输出：10 在这个例子中，Dictionary 接口定义了一个索引签名，允许任何字符串键，且这些键对应的值都必须是 number 类型。
7. 使用类型推断 TypeScript 会自动推断字面量对象的类型。如果你没有显式地为对象指定类型，TypeScript 会根据对象的结构自动推断类型。
1const person = { 2 name: &#34;Alice&#34;, 3 age: 30 4}; // TypeScript 推断 person 的类型为 { name: string; age: number; } 5 6person.name = &#34;Bob&#34;; // 允许修改 7// person.name = 100; // 错误，因为 name 应该是 string 类型 8. 禁止额外的属性 有时，你希望对象字面量只能包含某些特定的属性，禁止添加任何额外的属性。可以使用 exact 类型来实现这一点（通过 as const 来确保字面量类型的精确性）。
1const person = { 2 name: &#34;Alice&#34;, 3 age: 30 4} as const; // 使用 &#39;as const&#39; 来确保属性是只读的并且精确匹配 5 6// person.name = &#34;Bob&#34;; // 错误，因为 &#39;name&#39; 是只读的，不能修改 7// person.address = &#34;NY&#34;; // 错误，因为 \`address\` 属性并不在对象字面量中 总结 对象字面量 是通过 {} 创建的普通 JavaScript 对象，在 TypeScript 中可以通过类型注解来指定其结构。 你可以使用 interface 或 type 来定义对象的结构，确保对象符合某种预期的形状。 TypeScript 还支持可选属性、只读属性、索引签名、方法等功能。 TypeScript 会自动推断对象字面量的类型，如果你不提供类型注解。 通过这些方式，你可以在 TypeScript 中创建灵活、类型安全的对象字面量。
`,url:"https://hugo-dead-simple.netlify.com/typescript/%E5%AF%B9%E8%B1%A1%E5%AD%97%E9%9D%A2%E9%87%8F/"},"https://hugo-dead-simple.netlify.com/typescript/%E7%90%86%E8%A7%A3%E7%B1%BB%E5%A3%B0%E6%98%8E%E5%80%BC%E4%B8%8E%E7%B1%BB%E5%9E%8B/":{title:"理解类声明值与类型",tags:[],content:`这段代码涉及到了 TypeScript 中类的构造函数、实例对象、类型等概念。让我们逐步解析每个部分，特别是 console.log(C.a) 报错的原因。
代码解析 1class C { 2 a = &#34;123&#34;; // 类实例属性 3} 4 5let c: C = new C(); // 创建 C 类的一个实例 6 7console.log(c); // 输出: C { a: &#39;123&#39; } 8console.log(C); // 输出: [Function: C]，C 是构造函数 9// console.log(C.a); // 报错：Property &#39;a&#39; does not exist on type &#39;C&#39;. 10console.log(c.a); // 输出: 123 11console.log(c instanceof C); // 输出: true 1. console.log(C) 输出的是构造函数 1console.log(C); // 输出: [Function: C] C 是一个类，类的本质在 JavaScript 中是一个构造函数。C 本身是一个函数，用来创建 C 类的实例。 当你打印 C 时，输出的是类的构造函数。换句话说，C 是一个 构造函数，而不是一个对象实例或类的 实例类型。 2. console.log(C.a) 报错的原因 1// console.log(C.a); // 报错：Property &#39;a&#39; does not exist on type &#39;C&#39;. 在类定义 class C { a = &quot;123&quot;; } 中，a 是一个 实例属性，而不是 类属性。 也就是说，a 属于类的实例（例如通过 new C() 创建的 c 实例），并且在构造函数中初始化。 因此，C 作为构造函数并不直接包含 a 属性，a 只能通过类的 实例对象 访问。 console.log(C.a) 会导致报错，因为 a 并不是 C 这个类本身的属性，而是实例的属性。 3. console.log(c.a) 正常输出 123 1console.log(c.a); // 输出: 123 c 是 C 类的一个实例对象，c.a 是访问 C 类实例上的属性 a。 由于 a 是实例属性，所以你可以通过 c.a 正常访问到值 &quot;123&quot;。 4. console.log(c instanceof C) 输出 true 1console.log(c instanceof C); // 输出: true instanceof 运算符用于检查对象是否是某个类的实例。 c instanceof C 返回 true，说明 c 确实是 C 类的实例。instanceof 会检查 c 是否是通过 C 构造函数创建的对象，或者是否位于 C 的原型链上。 总结 C 是构造函数：类 C 在 TypeScript 和 JavaScript 中本质上是一个构造函数。通过 new C() 创建的对象才是 C 类的实例。 实例属性 vs. 类属性：a 是类的实例属性，因此只能通过类的实例来访问；而 C 是类本身的构造函数，不包含实例属性 a。 instanceof 运算符：c instanceof C 检查对象 c 是否是 C 类的实例，返回 true 表示 c 是通过 C 构造函数创建的。 所以，错误的根源是将 C 类本身误认为是实例对象，试图直接访问 a。而实际 a 是 C 类实例的属性，必须通过实例对象（如 c.a）来访问。
`,url:"https://hugo-dead-simple.netlify.com/typescript/%E7%90%86%E8%A7%A3%E7%B1%BB%E5%A3%B0%E6%98%8E%E5%80%BC%E4%B8%8E%E7%B1%BB%E5%9E%8B/"},"https://hugo-dead-simple.netlify.com/typescript/src/decorator/":{title:"装饰器",tags:[],content:`装饰器（Decorator）是一种语法结构，用来在定义时修改类（class）的行为。
我的结构
装饰器是一个函数,本质是对类进行修改(Decorator),然后得到一个新的类,使这个类,有新的功能.
index
要使用这个代码,需要配置tsconfig.json
1&#34;experimentalDecorators&#34;: true, /* Enable experimental support for legacy experimental decorators. */ `,url:"https://hugo-dead-simple.netlify.com/typescript/src/decorator/"},"https://hugo-dead-simple.netlify.com/blog/newnew/":{title:"Newnew",tags:[],content:`test git action webhook
`,url:"https://hugo-dead-simple.netlify.com/blog/newnew/"},"https://hugo-dead-simple.netlify.com/blog/hugo%E8%87%AA%E5%8A%A8%E5%8F%91%E5%B8%83/":{title:"Hugo自动发布",tags:[],content:`自动deploy blog 到github 参考
https://letere-gzj.github.io/hugo-stack/p/hugo/custom-blog/#3-github%E9%83%A8%E7%BD%B2 对应的视频教程: https://www.bilibili.com/video/BV1bovfeaEtQ 另一个 可以 发布blog到vps服务器 下面是新另外一个blog
本文由 简悦 SimpRead 转码， 原文地址 blog.wjhwjhn.com
背景 我一直计划迁移我的博客，一方面是认为之前主题的代码展示能力不强，文章的信息密度低，不适宜于技术内容的展示；另一方面，我曾认为极为安全的 Typecho，在 2023 年 6 月爆出了 XSS 漏洞，这加剧了我迁移的紧迫性。
注意
本文最后更新于 2024-02-13，文中内容可能已过时。
背景 我一直计划迁移我的博客，一方面是认为之前主题的代码展示能力不强，文章的信息密度低，不适宜于技术内容的展示；另一方面，我曾认为极为安全的 Typecho，在 2023 年 6 月爆出了 XSS 漏洞，这加剧了我迁移的紧迫性。鉴于此，我早就转向一款既美观又实用的静态博客平台——我选择了 Hugo，并选用了 FixIt 主题。恰逢过年，我拥有了许多碎片化的时间，这成为了我迁移博客的绝佳时机。
问题和解决方案 在迁移博客的过程中，我遇到了一系列问题。为了帮助同样面对这些挑战的读者，我在下面详细记录了我所面临的问题以及我采取的解决措施，希望这些经验能为您提供实际的帮助和指引。
警告
在迁移之前，请务必备份原有博客的文件和数据库数据，以防意外发生。
文章迁移 文章内容：文章内容储存在 typecho_contents 表的 text 字段中，提取比较容易，只需要去除 &lt;!--markdown--&gt; 标记即可，原先编写文章时就使用的是 markdown，所以直接创建文件即可，不过在这个过程中也遇到了不少问题 在我刚建立这个博客时，因为对 markdown 语法的不熟悉，导致以前的很多文章使用了 markdown 的方言。这些文章，在 Typecho 中显示正常，但是在 Hugo 中就出现了排版错误，好在有问题的文章不是很多，这里手动编辑了一下； 在 Hugo 中，文章的元信息（文章创建时间、文章类别、文章标题等…）都内嵌文章开头的 yaml 元信息中，这些信息需要从 Typecho 的数据库中提取并生成，例如 typecho_contents 表的 created 、modified 、title 字段； 原先的 Typecho 的 typecho_contents 表的 status 字段，如果是非 public 的文章，则设置 hiddenFromHomePage: true、hiddenFromSearch: true、hiddenFromRss: true、hiddenFromRelated: true 以及 password: {password} 密码字段，由主题进行加密处理。 原博客链接跳转 问题：原博客的链接是使用 /archives/{cid}/ 这种形式的，而新博客的链接是使用 /posts/{name} 这种形式的； 解决方案：利用文章元信息中的 aliases 字段来生成一个额外的别名链接。 评论和阅读量迁移 使用了 Twikoo 的评论系统，并解决了链接转换问题
Twikoo 的评论系统运行在 docker 设备中，并且映射到 8099 端口。为了安全性，我使用 ufw 将此端口设置为 deny，但发现无效，在 xianyu 的帮助下 (Orz)，使用了 ufw-docker，并成功解决； 因为 Twikoo 原生只支持使用 http，而我的博客使用的是 https，导致 twikoo 被 block。这里使用了反向代理来解决，设置了 https://blog.wjhwjhn.com/twikoo 代理到 http://localhost:8099 ； 阅读量是我在数据库中新增的 viewsNum 字段，我进行了导出生成，并转化为 Twikoo 的数据格式； 在评论和阅读量中需要提供文章的地址和标题，而在数据库中的都是先前的地址和标题。这里编写了 Python 脚本，逻辑如下 在新版博客中，去访问原来的路径下访问 html 文件（通过 aliases 字段生成的跳转文件），并使用正则（meta http-equiv=&quot;refresh&quot; content=&quot;0; url=http://[^/]+(/[^&quot;]+)&quot;）取出更新后的地址。 前往新版博客的地址下使用正则（&lt;title&gt;([^&lt;]+)&lt;/title&gt;）取出标题。 图片链接修复 让 ChatGPT 编写正则，提取出图片链接，从原来的图片链接中下载到本地，并替换原有链接
发现以前有部分旧文章的图片使用的是 http，导致图片无法访问，编写了 SQL 语句进行了替换 UPDATE typecho_contents SET text = REPLACE(text, 'http://blog.wjhwjhn', 'https://blog.wjhwjhn');。 发现以前有部分图片无法访问到：之前有过一段时间的博客文章编写是在石墨上的，而石墨的导出 markdown 功能也经过两次的转变 我最早接触的时候，石墨的导出功能是可以直接导出文章内的图片的，并且使用了石墨的图片储存服务链接； 估计后来石墨发现盗链的人过多，于是对访问来源做了检测，导致了我当时有大量的博客图片无法访问。我编写了一个插件，在导入时对文章内外链图片进行检测，如果存在外链图片，则下载到本地并替换链接，具体内容查看 博客外链图片已恢复 这篇文章； 再后面文章内图片使用 base64 进行编码嵌入在 markdown 文件中，但如果图片过大，markdown 文件过大，甚至无法在 Typecho 中储存。因此我也就不用石墨写文章了，通常会在本地 (使用本地图床) 写好文章，然后通过插件自动下载图床图片并修正到本地链接； 插件的鲁棒性不佳，存在下载失败的情况，不过好在下载失败的情况不多，我手动补了几张图片就解决了。 markdown 内图片链接提取，一般分为两种形式，都是使用正则来匹配 直接嵌入的图片![{text}]({url})，匹配正则：!\\[.*?\\]\\((.*?)\\)； 在文章底部使用 [{id}]:{url} 定义了一个脚注或引用链接，在使用时使用 ![{text}][{id}] 来引用，匹配正则：\\[\\d+\\]:\\s*(.*?)\\s*(?=&quot;#|$)。 GitHub Action 警告
为确保与您的服务器配置、仓库路径和特定需求相匹配，请适当修改以下代码段。避免直接复制粘贴，以预防潜在的兼容性问题或配置错误。
在过去的博客中，发布文章仅需在后台编辑后直接发送，便可立即在页面上看到效果。然而，自从转换到静态博客平台后，原本简洁的发布流程变得复杂。经过参考众多文章与资料，我目前采用了 GitHub Action 来简化这一流程。
新增文章流程 在本地操作 Hugo 新增文章，并使用 git 进行管理，并 push 到 GitHub 上； GitHub Action 检测到 push 并自动执行编译，编译后的页面结果存放在 gh-pages 分支中； 编译完毕后，GitHub Action 使用 Webhook 通知博客服务器来 GitHub 上拉取 gh-pages 的博客数据。 因为我的 GitHub 仓库是私有的，所以还需要把博客服务器的 SSH keys 添加到 GitHub，才能够拉取私有仓库。
GitHub Action 代码流程 配置解读
当 master 分支被 push 时自动执行； 运行在 Ubuntu-22.04 的环境上； 使用 Hugo 最新扩展版对博客源文件进行编译； 将编译后的 public 文件夹部署到 gh-pages 分支上； 通过 Webhook 来通知博客服务器来同步最新的静态页面数据。 1name: GitHub Pages 2 3on: 4 push: 5 branches: 6 - master # Set a branch to deploy 7 pull_request: 8 9jobs: 10 deploy: 11 runs-on: ubuntu-22.04 12 concurrency: 13 group: \${{ github.workflow }}-\${{ github.ref }} 14 steps: 15 - uses: actions/checkout@v4 16 with: 17 submodules: true # Fetch Hugo themes (true OR recursive) 18 fetch-depth: 0 # Fetch all history for .GitInfo and .Lastmod 19 20 - name: Setup Hugo 21 uses: peaceiris/actions-hugo@v2 22 with: 23 hugo-version: &#39;latest&#39; 24 extended: true 25 26 - name: Build 27 run: hugo --minify 28 29 - name: Deploy 30 uses: peaceiris/actions-gh-pages@v3 31 if: github.ref == &#39;refs/heads/master&#39; 32 with: 33 github_token: \${{ secrets.GH_TOKEN }} 34 publish_dir: ./public 35 36 - name: Update Blog Server 37 uses: distributhor/workflow-webhook@v1 38 env: 39 webhook_url: \${{ secrets.WEBHOOK_URL }} 40 webhook_secret: \${{ secrets.WEBHOOK_SECRET }} 实际效果展示
Webhook 执行脚本 1#!/bin/bash 2 3# Start of the script 4echo &#34;$(date &#34;+%Y-%m-%d %H:%M:%S&#34;) Run&#34; 5 6# Define variables 7gitPath=&#34;/www/wwwroot/newblog&#34; 8gitSSH=&#34;git@github.com:wjhwjhn/blog.git&#34; 9 10echo &#34;Web site path: $gitPath&#34; 11 12# Check if the directory exists 13if [ -d &#34;$gitPath&#34; ]; then 14 # Attempt to enter the directory 15 cd &#34;$gitPath&#34; || { echo &#34;Failed to enter directory $gitPath&#34;; exit 1; } 16 17 echo &#34;------&#34; 18 # Check if .git needs to be cloned 19 if [ ! -d &#34;.git&#34; ]; then 20 echo &#34;Cloning git into this directory&#34; 21 if git clone -b gh-pages &#34;$gitSSH&#34; gittemp &amp;&amp; mv gittemp/.git . &amp;&amp; rm -rf gittemp; then 22 echo &#34;Clone successful&#34; 23 else 24 echo &#34;Clone failed&#34; 25 exit 1 26 fi 27 fi 28 29 # Update the git repository 30 if git reset --hard gh-pages &amp;&amp; git pull; then 31 echo &#34;Update successful&#34; 32 else 33 echo &#34;Update failed&#34; 34 exit 1 35 fi 36 37 # Change ownership 38 chown -R www:www &#34;$gitPath&#34; 39 echo &#34;Finish&#34; 40else 41 echo &#34;The project path does not exist&#34; 42 echo &#34;Finish&#34; 43fi Typora 图片设置 Typora 支持便捷地在本地保存文件。但是如果设置不当，它可能无法兼容 Hugo 的图片存储方式，这里对 Typora 的配置做了以下调整
格式 -&gt; 图像 -&gt; 设置图片根目录，设置目录为 Hugo 源文件下的 static 文件夹
偏好设置 -&gt; 图像 -&gt; 插入图片处设置路径为 Hugo 源文件下的 static\\images\\ 文件夹
设置完毕后，在 Typora 中 Ctrl + V 粘贴图片就会自动以 /images/xxx.png 的链接呈现，并把图片保存在 static\\images\\ 文件夹，这个图片链接形式在 Typora 中和 Hugo 博客中都可以正常浏览。
总结 此次迁移历时三天，过程中虽然遇到了不少挑战，但也收获颇丰。通过提出问题、构思解决方案，以及运用编程技术解决实际问题的过程，为我带来了极大的满足感。
四年前，我建立了这个博客，那时对 Linux 的操作感到极度畏惧，我的理解也仅限于书本知识。在过去的四年中，我对 Linux（尤其是 Ubuntu）的了解和熟悉程度有了显著提高，逐渐体会到了类 Unix 系统的独特魅力。与此同时，我的云服务器也从最初以 Windows 系统为主、Linux 系统为辅，转变为全面采用 Linux 系统。
现在，回顾起我当初配置的服务器，我意识到了许多安全上的疏漏，同样，重新审视我早期的文章时，我也意识到了当时的视野局限和思维的稚嫩。我相信，四年后的自己再回看今日所做，可能会对某些决定感到可笑或有所遗憾。然而，我认为这正体现了人生的一环——持续学习，回望过往，对曾经的自己会心一笑。
`,url:"https://hugo-dead-simple.netlify.com/blog/hugo%E8%87%AA%E5%8A%A8%E5%8F%91%E5%B8%83/"},"https://hugo-dead-simple.netlify.com/posts/my-first-post/":{title:"My First Post",tags:[],content:`hdsdf
`,url:"https://hugo-dead-simple.netlify.com/posts/my-first-post/"},"https://hugo-dead-simple.netlify.com/posts/":{title:"Posts",tags:[],content:"",url:"https://hugo-dead-simple.netlify.com/posts/"},"https://hugo-dead-simple.netlify.com/blog/helloworld/":{title:"Helloworld",tags:[],content:`hello world write by Rainboy
`,url:"https://hugo-dead-simple.netlify.com/blog/helloworld/"},"https://hugo-dead-simple.netlify.com/books/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B%E8%BF%9B%E9%98%B6%E6%8C%87%E5%8D%97/chapter_1/":{title:"第一章 0x00 基本算法",tags:[],content:`0x01 位运算 a^b 标准快速幂取余 64位整数乘法 1018×101810^{18} \\times 10^{18}1018×1018 大数相乘，超过范围，是1就加，base增增 最短Hamilton路径: 集合，状压DP 起床困难综合症 通过暴力验证 不符合 交换律 利用位运算的性质: 第kkk位置的的运算不会影响其它位 时间32×2×10532 \\times 2 \\times 10 ^532×2×105 0x02 递推与递归 01序列: 子集枚举
排列,全排列 Strange Towers of Hanoi Sumdiv ? Fractal Streets ? 0x03 前缀和与差分 前缀和与差分一对互逆映射,对应的序列一一对应 任何在原序列上的区间操作都可以转成前缀和序列(subseqsub seqsubseq)的一对单点操作 应用 多个区间，多个点 ,某个区间是否含有点 0x05 二分 二分常用应用 第一个/最后一个元素x出现的位置 某个元素的数量 不在区间中的点： 多个区间，多个点，判断某一个点是否在任一区间里 方法: 二分过滤出li&lt;dotl_i &lt; dotli​&lt;dot的区间,max_right(i)=max⁡1≤j≤i{rj}&gt;dotmax\\_right(i) = \\max_{1 \\le j \\le i} \\{r_j\\} &gt; dot max_right(i)=max1≤j≤i​{rj​}&gt;dot 表明点 dotdotdot在某一个区间内 Best Cow Fences ×1000\\times 1000×1000然后输出,说明保留三位精度,那么答案不是精确算出来的,是逼近的,能逼近的算法: 实数二分 P,Q公共条件( &gt;=L ) 若P: a序列的最大平均数是ave 则Q: b需要 maxsum_subseq = 0 P =&gt; Q P1: a序列的最大平均数是ave,且 x &lt; ave,Q1: b( [bi | bi = ai-x ]). maxsum_subseq &gt; 0: P1⇒Q1P1 \\Rightarrow Q1P1⇒Q1 利用DP单调性(滑动窗口,转移区间只加) : 存在O(n)的算法求出最大(&gt;=L)的最大字段和 总结:二分答案: 最大子段和(b序列)与 最大字段平均数(a序列)直接的关系: maxsubseqb&gt;0⇒max_ave(seqa)&lt;xmax_subseq b &gt; 0 \\Rightarrow max\\_ave(seq a) &lt; xmaxs​ubseqb&gt;0⇒max_ave(seqa)&lt;x ,[bi∣bi=ai−x][b_i | b_i = a_i - x][bi​∣bi​=ai​−x] Innovative Business TODO
0x05 排序 题目Cinema 二维元组大小比较, 需要离散化(O(logn)O(logn)O(logn)),再来扫一遍O(n)O(n)O(n)
题目货仓选址 证明: 创建点x,使得x到数轴上其它的距离和最小
证明: 递归,数学归纳
a---b 两个的点时答案集合为[a,b][a,b][a,b],分类讨论 a--b--c--d,4个点时,最外层的a,b答案(贡献)[a,b][a,b][a,b],当保证最终答案ans∈[a,b]ans \\in [a,b]ans∈[a,b]时,就变成了两个点b--c的子问题,且[b,c]⊂[a,b][b,c] \\subset [a,b][b,c]⊂[a,b](贪心: 决策包容性) 奇数个点,可以把中间的那个点当成:两个重合的点,于是奇数变成偶数. 七夕祭 前提题目:
多个均分纸牌: luogu P1031 T565389 环形 P2125 P2512 证明: 可拆性: 最优答案不可能成环(存在相邻两个人,不传递) 1TODO `,url:"https://hugo-dead-simple.netlify.com/books/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B%E8%BF%9B%E9%98%B6%E6%8C%87%E5%8D%97/chapter_1/"},"https://hugo-dead-simple.netlify.com/group_theory/1%E7%AD%89%E4%BB%B7%E5%85%B3%E7%B3%BB%E4%B8%8E%E9%9B%86%E5%90%88%E7%9A%84%E5%88%86%E7%B1%BB/":{title:"1等价关系与集合的分类",tags:[],content:`对应视频的p1-p6
定义二元关系RRR 等价关系 反身性：∀a→aRa\\forall a \\to aRa∀a→aRa 对称性：aRb⇒bRaaRb \\Rightarrow bRaaRb⇒bRa 传递性：aRb∧bRc⇒aRcaRb \\land bRc \\Rightarrow aRcaRb∧bRc⇒aRc 等价类 定义：[a][a][a]表示所有与aaa等价的元素的集合 等价类是满足以下条件的集合：任意两个元素aaa和bbb都属于同一个等价类当且仅当aRbaRbaRb 公式定义: [a]={x∈S∣xRa}[a]= \\{ x \\in S | xRa \\}[a]={x∈S∣xRa} 类在这里的意思为:&ldquo;物以群分&rdquo;,分类的意思,等价类就是把满足等价关系的元素归为一类. 商集: SSS的全体等价类构成的集合,集合SSS在等价关系下的商集记作S/∽S / \\backsimS/∽ 集合的分类 定义：SSS是一个集合，如果存在一个等价关系RRR使得SSS的所有元素都可以划分为等价类，则称SSS为RRR的分类 如果非空集合SSS是它的某些两两不相交的非空子集的并,则称这些子集为集合SSS的一种分类(partition),其中每个子集称为集合SSS的一个类(class) 若集合SSS的子集族{Si∣i∈I}\\{S_i | i \\in I\\}{Si​∣i∈I}构成了S的一种分类当且仅当
S=⋃i∈ISiS = \\bigcup_{i \\in I} S_iS=⋃i∈I​Si​ Si∩Sj=∅S_i \\cap S_j = \\varnothingSi​∩Sj​=∅ (i.e., SiS_iSi​ and SjS_jSj​ are pairwise disjoint) 集合SSS的任何一种等价关系都确定了SSS的一种分类。
例题 例5 aRb⇔m∣a−b,∀a,b∈Z(1) aRb \\Leftrightarrow m \\mid a - b , \\forall a,b \\in \\mathbb{Z} \\tag 1 aRb⇔m∣a−b,∀a,b∈Z(1)证明1式是等价关系.也就是证明m∣a−bm | a -b m∣a−b是等价关系.
公式的含义解释: m是a与b差的因子,则说明a,b对于m同余.这两者是等价的.
下面证明这两者是等价关系.
设 A:a≡b(mod m)a \\equiv b (\\mod m)a≡b(modm), B: m∣a−bm \\mid a-bm∣a−b.
A→BA \\to BA→B,把a,b写成带余数除法的形式.
a=k1×m+rb=k2×m+ra−b=m(k1−k2)→m∣a−b a = k_1 \\times m + r \\\\ b = k_2 \\times m + r \\\\ a - b = m(k_1 - k_2) \\to m \\mid a - b a=k1​×m+rb=k2​×m+ra−b=m(k1​−k2​)→m∣a−b必要性证明完毕,证明充分性.
m∣a−b→a−b=k×m→a=b+k×m→amod m=(b+k×m)mod m→amod m=bmod m m \\mid a - b \\\\ \\to a -b = k \\times m \\\\ \\to a = b + k \\times m \\\\ \\to a \\mod m = (b+k \\times m) \\mod m \\\\ \\to a \\mod m = b \\mod m m∣a−b→a−b=k×m→a=b+k×m→amodm=(b+k×m)modm→amodm=bmodmqed;
证明自反性:
aRa⇔m∣a−a aRa \\Leftrightarrow m \\mid a - a aRa⇔m∣a−a显然成立.
证明对称性:
根据 m∣x→m∣−x m \\mid x \\to m \\mid -x m∣x→m∣−x那么
m∣a−b→m∣−(a−b)→m∣b−a m \\mid a - b \\to m \\mid -(a - b) \\to m \\mid b - a m∣a−b→m∣−(a−b)→m∣b−a证明传递性:
m∣a−b∧m∣b−c→m∣a−cm | a - b \\land m| b - c \\to m | a - cm∣a−b∧m∣b−c→m∣a−c
a=k1×m+rb=k2×m+rc=k3×m+r→a−c=k1×m+r−k3×m−r→m∣a−c a = k_1 \\times m + r \\\\ b = k_2 \\times m + r \\\\ c = k_3 \\times m + r \\\\ \\to a - c = k_1 \\times m + r - k_3 \\times m - r\\\\ \\to m \\mid a - c a=k1​×m+rb=k2​×m+rc=k3​×m+r→a−c=k1​×m+r−k3​×m−r→m∣a−c证明完毕
说明同余是一种等价关系.
书上又定义了什么叫做同余剩余类.
例9 这个见书.
课后题目 习题1. 试分别举出满足下列条件的关系： (1)有对称性，传递性，但无反身性； (2)有反身性，传递性，但无对称性； (3)有反身性，对称性，但无传递性. 解:设集合S={a,b,c}S = \\{a,b,c\\}S={a,b,c}
(1) ,R={(a,b),(b,a),(a,a),b,b}R = \\{(a,b),(b,a),(a,a),{b,b}\\}R={(a,b),(b,a),(a,a),b,b},因为没有(c,c)(c,c)(c,c)所以不满足反身性. (2) ,R={(a,a),(b,b),(c,c),(a,b)}R = \\{(a,a),(b,b),(c,c),(a,b)\\}R={(a,a),(b,b),(c,c),(a,b)},因为没有(b,a)(b,a)(b,a)所以不满足对称性. (3) ,R={(a,a),(b,b),(c,c),(a,b),(b,a),(c,a),(c,b)}R = \\{(a,a),(b,b),(c,c),(a,b),(b,a),(c,a),(c,b)\\}R={(a,a),(b,b),(c,c),(a,b),(b,a),(c,a),(c,b)},因为没有(a,c)(a,c)(a,c)所以不满足传递性. 习题2.找出下面证明中的错误： 有人断言，若S的关系R有对称性和传递性，则必有反身性.这晨因 为，对任意的a∈S,由对称性，如果aRb,则bRa.再由传递性，得aRa,所 以R有反身性.
关键在于a∈Sa \\in Sa∈S，但如果aaa就没有自己的关系呢?例如习题1的(1),就没有c的关系,所以不能说R有反身性. 因为不一定有cRbcRbcRb这个关系.
`,url:"https://hugo-dead-simple.netlify.com/group_theory/1%E7%AD%89%E4%BB%B7%E5%85%B3%E7%B3%BB%E4%B8%8E%E9%9B%86%E5%90%88%E7%9A%84%E5%88%86%E7%B1%BB/"},"https://hugo-dead-simple.netlify.com/group_theory/":{title:"Group_theories",tags:[],content:"",url:"https://hugo-dead-simple.netlify.com/group_theory/"},"https://hugo-dead-simple.netlify.com/typescript/preverseconstenums/":{title:"preserveConstEnums编译器选项",tags:["typescript"],content:`preserveConstEnums 是 TypeScript 编译器选项之一，作用是控制 TypeScript 编译过程中是否保留 const enum 的常量值。
详细作用： 当你在 TypeScript 中使用 const enum 时，它们会在编译时被内联展开为常量值，而不会生成单独的枚举代码。默认情况下，TypeScript 会将 const enum 编译为常量值，而不会生成任何枚举相关的 JavaScript 代码。
如果你启用 preserveConstEnums，TypeScript 编译器将不会内联 const enum，而是保留这些枚举，并生成相应的 JavaScript 代码。这样，编译后的代码将包含枚举的实际定义，而不是直接替换为常量值。
使用场景： preserveConstEnums: true: 如果你希望 const enum 在编译后依然保留为枚举定义（而不是被内联展开为常量值），可以开启这个选项。 preserveConstEnums: false（默认值）：会直接内联 const enum 的值，生成的 JavaScript 代码中不会包含枚举类型定义。 示例： 1. preserveConstEnums: false (默认) TypeScript 编译器将内联 const enum：
1const enum Color { 2 Red = 1, 3 Green = 2, 4 Blue = 3 5} 6 7let c = Color.Green; // 编译后直接替换成 2 编译后的 JavaScript 代码：
1var c = 2; 2. preserveConstEnums: true 如果启用 preserveConstEnums，编译后的代码会保留枚举定义：
1const enum Color { 2 Red = 1, 3 Green = 2, 4 Blue = 3 5} 6 7let c = Color.Green; 编译后的 JavaScript 代码：
1var Color; 2(function (Color) { 3 Color[Color[&#34;Red&#34;] = 1] = &#34;Red&#34;; 4 Color[Color[&#34;Green&#34;] = 2] = &#34;Green&#34;; 5 Color[Color[&#34;Blue&#34;] = 3] = &#34;Blue&#34;; 6})(Color || (Color = {})); 7var c = Color.Green; 总结： preserveConstEnums: true 保留 const enum 的定义在输出的 JavaScript 代码中，而不是将其内联成常量值。 preserveConstEnums: false（默认）则会将 const enum 的成员内联为常量值，生成的 JavaScript 代码会更简洁。 `,url:"https://hugo-dead-simple.netlify.com/typescript/preverseconstenums/"},"https://hugo-dead-simple.netlify.com/typescript/src/readme/":{title:"typescript",tags:["typescript"],content:`安装 1yarn global add typescript ts-node 数据类型 string boolean number void 用在没有返回值的函数,其它可以用,但不能赋值 1function alerme():void { 2 alert(&#39;my name is tom&#39;); 3} null,undefined,是所有类型的子类型,可以赋值给其它类型,而 void 类型的变量不能赋值给 number 类型的变量： 1let num:number = null 对象类型 1const xiaoJieJie : { 2 name:string, 3 age:number 4} = { 5 name:&#39;hel&#39;, 6 age:19 7} //1 普通 8 9const xiaoJjiejieS :string [] = [&#39;1&#39;,&#39;dajiao&#39;,&#39;liuyaing&#39;]; // 2 .数组 10 11class Person{} 12const dajiao: Person = new Person() //3 类类型 13 14const jianXiaoJjieJie: () =&gt; string = () =&gt; {return &#34;dajiao&#34;}; //函数对象类型 类型注解 与 类型推断 type annotation type inference 工作使用的原则
如果TS能够自动分析变量类型,我们就什么也不需要做了 如果TS无法分析变量类型的话,我们就需要使用类型注解了 05 函数参数和返回类型的注解 1&lt;%- include(&#34;demo/demo5.ts&#34;) %&gt; 06数组类型的定义 类型别名 1&lt;%- include(&#34;demo/demo6.ts&#34;) %&gt; 07 元组的使用 1&lt;%- include(&#34;demo/demo7.ts&#34;) %&gt; 元组现在用的少了,因为可以用对象的形式来代替
08 09 interface 接口 1&lt;%- include(&#34;demo/demo8.ts&#34;) %&gt; 1&lt;%- include(&#34;demo/demo9.ts&#34;) %&gt; [propname:string] : any; 内部约束了一个函数say():string; 接口约束一个类class xiaojiejie implements Gril 接口的拓展interface Teacher extends Girl{} 相当于继承 符合子接口的对象也符合父接口 10 类的概念和使用 定义 继承 重写 super 调用父类中的方法 1&lt;%- include(&#34;demo/demo10.ts&#34;) %&gt; 类的访问类型 private 内部用,外部不能用 protected 内部用,外部不能用,继承可以用 public 默认是public 都可以用 类的内部与外部
1&lt;%- include(&#34;demo/demo11.ts&#34;) %&gt; 12 类的构造函数 1&lt;%- include(&#34;demo/demo12.ts&#34;) %&gt; 13 类的getter setter static 只读 1&lt;%- include(&#34;demo/demo13.ts&#34;) %&gt; 14 抽象类 含有抽象方法的类叫做抽象类 继承抽象类的类必须实现抽象方法 1&lt;%- include(&#34;demo/demo14.ts&#34;) %&gt; 15 16 17 tsconfig.json 配置文件 tsc -init 生成 tsc 不加名字,会调用tsconfig.json &ldquo;include&rdquo;:[&ldquo;demo.ts&rdquo;], 可以是目录及文件,可以正则,可以glob &ldquo;exclude&rdquo;:[&ldquo;demo.ts&rdquo;], 可以排除include 里文件 &ldquo;files&rdquo;:[&ldquo;demo.ts&rdquo;], 和include一样,但只能是文件,不会被exclude排除 compileOptions
strict 严格ts noImplicitAny 充许你的注解类型any不用特意标明 strictNullChecks 不充许有null值出现 ts-node 也会用tsconfig.json rootdir 源代码根目录 outDir 编译输出的文件 sourceMap 生成.map文件 debug用 noUnsedLocal 不能出现没有使用的本地变量 18 类型保护与联合类型 不单一的类型 number | boolean 只有在联合类型的时候需要 类型保护 类型断言 person as Waiter skill in person typeof person ==='string' first instanceof NumberOBJ instanceof 只能用在类上 1&lt;%- include(&#34;demo/demo18.cpp&#34;) %&gt; 19 enum 类型 typescript 独有 1&lt;%- include(&#34;demo/demo19.cpp&#34;) %&gt; enum 可以反查 log(Status[1]) 20 泛型 1&lt;%- include(&#34;demo/demo20.cpp&#34;) %&gt; 21 类中使用泛型 1 2 - 泛型在类中的使用 \`class C&lt;T&gt;\` 3 4为了约束传入的参数 5 6 - 泛型继承 7 - 泛型约束 8 9&lt;%- include(&#34;demo/demo21.cpp&#34;) %&gt; 10 11## 22 23 命名空间 12 13在浏览器中运行与看效果 14 15 - vscode -&gt; file -&gt; openFloder 16 - vscode-&gt;terminal \`npm init\` 17 - \`tsc -init\` 18 - \`mkdir src &amp;&amp; mkdir build &amp;&amp; touch index.html\` 19 20 - 命名空间可以嵌套 namespace fater { namespace child { } }
1 2tsconfig.json 3 - outFile -&gt;生成一个单独的文件 4 - moduble coomjs -&gt;&#39;amd&#39; 5 6## 24 import 7 8需要引用 require.js 来使用 amd 的模块 require([&ldquo;page&rdquo;],function(){ })
1 2## 25 parcel yarn add &ndash;dev parcel
1 2## 26 ts 使用jquery yarn add @types/jquery
1 2or declare var $:any;
1 2## 资料 3 4 - [ruan一峰 es6]() 5 - [TypeScript 入门教程](https://ts.xcatliu.com/) 6 - [TypeScript Handbook（中文版）](https://zhongsp.gitbooks.io/typescript-handbook/content/) 7 - [技术胖-TypeScript 从入门到精通图文视频教程-免费教程](http://jspang.com/detailed?id=63) `,url:"https://hugo-dead-simple.netlify.com/typescript/src/readme/"},"https://hugo-dead-simple.netlify.com/tags/typescript/":{title:"Typescript",tags:[],content:"",url:"https://hugo-dead-simple.netlify.com/tags/typescript/"},"https://hugo-dead-simple.netlify.com/typescript/object_object/":{title:"TypeScript 中的 object 和 Object 的区别",tags:["typescript"],content:"在 TypeScript 中，object 和 Object 虽然看起来相似，但它们有着不同的含义和用途。\n1. object（小写） object 是一个 类型，表示任何非原始类型的值。原始类型包括：number、string、boolean、symbol、null 和 undefined。换句话说，object 类型是指 除原始类型之外的所有类型。\n特点： object 类型表示的值必须是一个对象（即非原始值），但不限定对象的结构（属性和方法）。 它并不等同于 Object 构造函数的类型。 不能直接访问对象的属性或方法，除非将其类型进一步细化。 示例： 1let obj: object; 2 3obj = { name: &#34;Alice&#34; }; // 合法 4obj = [1, 2, 3]; // 合法 5obj = () =&gt; {}; // 合法 6 7obj = 42; // 错误：类型 &#39;number&#39; 不能赋值给类型 &#39;object&#39; 8obj = &#34;hello&#34;; // 错误：类型 &#39;string&#39; 不能赋值给类型 &#39;object&#39; object 类型限制了只能是“非原始类型”的值，但是它并不关心具体是什么类型（例如是数组、函数还是普通对象）。因此，你不能直接访问对象的属性，除非你进一步指定对象的结构或类型。\n2. Object（大写） Object 是 JavaScript 中的内置构造函数，用来创建对象实例。在 TypeScript 中，Object 表示所有非 null 的类型，也就是说，它是所有类型的超集，除了 null 和 undefined。\n特点： Object 类型表示 所有对象类型，包括原始类型（string、number 等）以外的所有类型。 它是 JavaScript 中所有对象的父类，甚至可以用于表示原始类型（不过通常不这么做）。 示例： 1let obj: Object; 2 3obj = { name: &#34;Alice&#34; }; // 合法 4obj = [1, 2, 3]; // 合法 5obj = &#34;hello&#34;; // 合法（尽管通常不这么做） 6obj = 42; // 合法（`number` 也是 `Object` 类型的一部分） 7 8obj = null; // 错误：`null` 不能赋值给 `Object` Object 类型实际上包含了 所有类型，除 null 和 undefined 之外。\n3. 区别总结 特性 object Object 表示的内容 任何非原始类型（不包括 number, string, boolean, symbol, null, undefined） 所有类型（包括 number, string, boolean, symbol, 除 null 和 undefined） 是否允许原始类型 不允许原始类型（只能是对象） 允许原始类型（包括 number, string, boolean, symbol 等） 访问属性 不能直接访问属性，需要进一步细化类型 允许访问属性，实际上是 Object 类型的超集 常见用途 用于限定某个值是对象类型（而不是原始值） 表示所有类型（但不包括 null 和 undefined） 4. 进一步的示例： object 示例： 1let obj: object; 2 3obj = { name: &#34;Alice&#34; }; // 合法 4obj = [1, 2, 3]; // 合法 5obj = () =&gt; {}; // 合法 6 7// 下面的类型会报错，因为 `object` 类型不允许原始类型 8obj = 42; // 错误 9obj = &#34;hello&#34;; // 错误 10obj = true; // 错误 Object 示例： 1let obj: Object; 2 3obj = { name: &#34;Alice&#34; }; // 合法 4obj = [1, 2, 3]; // 合法 5obj = &#34;hello&#34;; // 合法 6obj = 42; // 合法 7 8// `null` 不能赋值给 `Object` 类型 9obj = null; // 错误 5. 总结 object 是一个类型，表示非原始类型（即排除 number, string, boolean, symbol, null 和 undefined）。它不能直接用于访问对象的属性。 Object 是 JavaScript 中的构造函数，它是所有类型的超集，除了 null 和 undefined，它允许表示任何类型，包括原始类型（如 string、number 等）。 在 TypeScript 中，建议尽量使用 object 来表示对象类型，避免使用 Object，除非你确实需要一个更宽泛的类型（表示所有非 null/undefined 的值）。\n",url:"https://hugo-dead-simple.netlify.com/typescript/object_object/"},"https://hugo-dead-simple.netlify.com/typescript/":{title:"typescript 学习笔记",tags:["typescript"],content:" 首页 如何调试 笔记:ts编程 对象字面量的使用 TypeScript 中的 object 和 Object 的区别 preserveConstEnums编译器选项 装饰器 ",url:"https://hugo-dead-simple.netlify.com/typescript/"},"https://hugo-dead-simple.netlify.com/typescript/readme/":{title:"typescript 学习笔记",tags:["typescript"],content:`资料 TypeScript Tutorial 阮一峰 es6 阮一峰 TypeScript 教程 TypeScript Handbook - The TypeScript Handbook TypeScript 入门教程 TypeScript Handbook（中文版） 现代TypeScript高级教程- - linwu-hi - 博客园 安装 1yarn global add typescript ts-node 数据类型 string boolean number void 用在没有返回值的函数,其它可以用,但不能赋值 1function alerme():void { 2 alert(&#39;my name is tom&#39;); 3} null,undefined,是所有类型的子类型,可以赋值给其它类型,而 void 类型的变量不能赋值给 number 类型的变量： 1 let num:number = null 对象类型 1const xiaoJieJie : { 2 name:string, 3 age:number 4} = { 5 name:&#39;hel&#39;, 6 age:19 7} //1 普通 8 9const xiaoJjiejieS :string [] = [&#39;1&#39;,&#39;dajiao&#39;,&#39;liuyaing&#39;]; // 2 .数组 10 11class Person{} 12const dajiao: Person = new Person() //3 类类型 13 14const jianXiaoJjieJie: () =&gt; string = () =&gt; {return &#34;dajiao&#34;}; //函数对象类型 脚手架 换了一个脚手架 GitHub - xddqnodejs-typescript-modern-starter Minimal and modern starter template to develop a Node.js project leveraging Typescript
类型注解 与 类型推断 type annotation type inference 工作使用的原则
如果TS能够自动分析变量类型,我们就什么也不需要做了 如果TS无法分析变量类型的话,我们就需要使用类型注解了 05 函数参数和返回类型的注解 demo5
06数组类型的定义 类型别名 demo/demo6.ts
07 元组的使用 demo/demo7.ts
元组现在用的少了,因为可以用对象的形式来代替
08 09 interface 接口 demo/demo8.ts
demo/demo9.ts
[propname:string] : any; 内部约束了一个函数say():string; 接口约束一个类class xiaojiejie implements Gril 接口的拓展interface Teacher extends Girl{} 相当于继承 符合子接口的对象也符合父接口 10 类的概念和使用 定义 继承 重写 super 调用父类中的方法 demo/demo10.ts
类的访问类型 private 内部用,外部不能用 protected 内部用,外部不能用,继承可以用 public 默认是public 都可以用 类的内部与外部
demo/demo11.ts
12 类的构造函数 demo/demo12.ts
13 类的getter setter static 只读 demo/demo13.ts
14 抽象类 含有抽象方法的类叫做抽象类 继承抽象类的类必须实现抽象方法 demo/demo14.ts
15 16 17 tsconfig.json 配置文件 tsc -init 生成 tsc 不加名字,会调用tsconfig.json &ldquo;include&rdquo;:[&ldquo;demo.ts&rdquo;], 可以是目录及文件,可以正则,可以glob &ldquo;exclude&rdquo;:[&ldquo;demo.ts&rdquo;], 可以排除include 里文件 &ldquo;files&rdquo;:[&ldquo;demo.ts&rdquo;], 和include一样,但只能是文件,不会被exclude排除 compileOptions
strict 严格ts noImplicitAny 充许你的注解类型any不用特意标明 strictNullChecks 不充许有null值出现 ts-node 也会用tsconfig.json rootdir 源代码根目录 outDir 编译输出的文件 sourceMap 生成.map文件 debug用 noUnsedLocal 不能出现没有使用的本地变量 18 类型保护与联合类型 不单一的类型 number | boolean 只有在联合类型的时候需要 类型保护 类型断言 person as Waiter skill in person typeof person ==='string' first instanceof NumberOBJ instanceof 只能用在类上 demo/demo18.ts
19 enum 类型 typescript 独有 demo/demo19.ts
enum 可以反查 log(Status[1]) 20 泛型 demo/demo20.ts
21 类中使用泛型 泛型在类中的使用 class C&lt;T&gt; 为了约束传入的参数
泛型继承 泛型约束 demo/demo21.ts
22 23 命名空间 在浏览器中运行与看效果
vscode -&gt; file -&gt; openFloder
vscode-&gt;terminal npm init
tsc -init
mkdir src &amp;&amp; mkdir build &amp;&amp; touch index.html
命名空间可以嵌套
1namespace fater { 2 namespace child { 3 } 4} tsconfig.json
outFile -&gt;生成一个单独的文件 moduble coomjs -&gt;&lsquo;amd&rsquo; 24 import 需要引用 require.js 来使用 amd 的模块
1require([&#34;page&#34;],function(){ 2}) 25 parcel 1yarn add --dev parcel 26 ts 使用jquery 1yarn add @types/jquery or
1declare var $:any; `,url:"https://hugo-dead-simple.netlify.com/typescript/readme/"},"https://hugo-dead-simple.netlify.com/linux_tcp_program/":{title:"linux网络编程学习笔记",tags:[],content:`说明 我的学习过程
1基础的socket编程 -&gt; -&gt; 线程编程 -&gt; muduo库学习 Linux网络编程视频教程 学习自
https://github.com/834810071/NetworkProgramming https://www.bilibili.com/video/av33813135/ 我主要的学习目标:
固定住 socket 编程的基础知识
如何使用 进程 编程
如何使用 thread 编程
p1 讲解了,网络模型,理解了四层的模型
linux网络编程
tcpip基础 p1-p5 socket编程 p6 TCP/IP 网络编程 tcpip网络编程 chapter_1 chapter_2 chapter_3 chapter_4 chapter_5 chapter_7 chapter_8 chapter_9 chapter_10 muduo 网络库 muduo库的实现: https://github.com/EricPengShuai/muduo
muduo 网络库 chapter_1 chapter_2 `,url:"https://hugo-dead-simple.netlify.com/linux_tcp_program/"},"https://hugo-dead-simple.netlify.com/linux_tcp_program/1/":{title:"",tags:[],content:`p4 tcp 基于字节流 无边界的字节流,需要对数据进行分割 粘包问题,解决方法: 发送方: 发送数据前,先将数据包的长度信息发送给对方 接收方: 接收到数据包长度信息后,根据长度信息,将数据包拆分为多个数据包进行处理 面向连接的 tcp 协议,需要建立连接,断开连接,保证数据传输的可靠性 缓冲传输
tcp报文格式
紧急指针: 紧急数据指针,只有紧急数据才会使用紧急指针,紧急数据是指需要立即传输的数据 选项字段: 选项字段,可以携带一些控制信息,如窗口大小,最大报文段长度,时间戳等 tcp三次握手
第一次握手: 客户端发送 SYN 报文,服务器收到后,发送 SYN+ACK 报文,客户端收到后,发送 ACK 报文 第二次握手: 客户端发送 ACK 报文,服务器收到后,发送 ACK 报文 第三次握手: 客户端发送 ACK 报文,服务器收到后,连接建立完成 tcp四次挥手
第一次挥手: 客户端发送 FIN 报文,服务器收到后,发送 ACK 报文,客户端收到后,进入 TIME-WAIT 状态 第二次挥手: 服务器发送 FIN 报文,客户端收到后,发送 ACK 报文,服务器收到后,进入 CLOSED 状态 第三次挥手: 服务器发送 ACK 报文,客户端收到后,进入 CLOSED 状态 第四次挥手: 客户端发送 ACK 报文,服务器收到后,进入 CLOSED 状态 tcp拥塞控制
慢启动: 开始时,发送方的发送速率较低,逐渐增大,以便逼近网络的实际速率 拥塞避免: 网络拥塞时,发送方的发送速率降低,以防止网络过载 快速重传: 接收方收到重复的 ACK 报文,认为是丢包,立即重传丢失的报文段 超时重传: 发送方在一段时间内没有收到 ACK 报文,认为报文丢失,重新发送 快速恢复: 当网络拥塞程度减缓时,发送方的发送速率增加,以便减轻网络拥塞 滑动窗口协议
发送方维护一个窗口,指示自己可以发送的报文段数量 接收方维护一个窗口,指示自己可以接收的报文段数量 发送方根据接收方的反馈,调整窗口的大小,以便在网络拥塞时,减少发送报文段的数量 接收方根据发送方的反馈,调整窗口的大小,以便在网络拥塞时,减少接收报文段的数量 `,url:"https://hugo-dead-simple.netlify.com/linux_tcp_program/1/"},"https://hugo-dead-simple.netlify.com/linux_tcp_program/2/":{title:"",tags:[],content:`学习目标 1mindmap 2 root((学习目标)) 3 1.什么是socket 4 2.IPv4套接口地址结构 5 3.网终字节序 6 4.字节序转换函数 7 5.地址转换函数 8 6.套接字类型 1. 什么是socket socket可以看成是用户进程与内核网络协议栈的 编程接口 socket不仅可以用于本机的进程间通信，还可以 用于网络上不同主机的进程间通信 我的理解: socket就是对前面学习的tcp/ip的代码封装,但是位于系统的内核,也就是说提供给用户的一组API,用于网络通信.
[!WARNING] socket 这里理解成&quot;插座&quot;
1mindmap 2 root((socket需要的属性)) 3 地址: sockaddr_in 4 sin_addr 5 sin_port 6 sin_family ipv4 socket 地址结构体 ipv4 socket地址结构体,在头文件netinet/in.h中定义。 sockaddr_in结构体定义如下：
使用man 7 ip命令查看sockaddr_in结构体的定义：
1struct sockaddr_in { 2 sa_family_t sin_family; // 地址族，ipv4 就是AF_INET 3 in_port_t sin_port; // 端口号 4 struct in_addr sin_addr; // IP地址 5 char sin_zero[8]; // 未使用,注意这个在man 7 ip中没有说明 6 //暗示程序员不需要知道这个?? 7 //当成上面的普通的来用? 8}; sin_family字段表示地址族,socket在设计的时候还可以用于其它的协议,不仅是tcp/ip,比如还有unix域，对于IPv4地址，该值为AF_INET。 sin_port字段表示端口号，使用网络字节序（big-endian）存储。 sin_addr字段表示IP地址，使用struct in_addr结构体表示。 struct in_addr结构体定义如下：
1struct in_addr { 2 uint32_t s_addr; // IP地址，使用网络字节序存储 3}; s_addr字段表示IP地址，使用网络字节序存储。 疑问1 [!NOTE] 到这里就有一个疑问,socketaddr_in结构体具体的定义是什么呢?后面有没有char sin_zero[8];字段呢?通过下面的代码来验证
1{{#include ./code/size_ofsockaddr_in.c}} 输出的结果是：16,
1size bytes of sockaddr_in 16 2size bytes of sin_family 2 3size bytes of sin_port 2 4size bytes of sin_addr 4 结果确实是少8
通用套接字地址结构体sockaddr 定义如下：
它适用于任何地址协议,
1struct sockaddr { 2 sa_family_t sa_family; // 地址族 3 char sa_data[14]; // 地址数据，长度取决于地址族 4}; sa_family字段表示地址族。 sa_data字段表示地址数据，长度取决于地址族。 1#include &lt;stdio.h&gt; 2#include &lt;netinet/in.h&gt; 3 4int main(int argc, char const *argv[]) 5{ 6 struct sockaddr_in addr1; 7 struct sockaddr addr2; 8 9 printf(&#34;sizof(sockaddr_in) = %ld\\n&#34;, sizeof(addr1)); 10 printf(&#34;sizof(sockaddr) = %ld\\n&#34;, sizeof(addr2)); 11 12 // 最后输出的结果是： 13 // sizof(sockaddr_in) = 16 14 // sizof(sockaddr) = 16 15 // 说明sockaddr_in和sockaddr的大小是相同的，都是16字节。 16 17 return 0; 18} 在通常的网络编程中,我们先填写sockaddr_in结构体,然后再把它转换成通用的sockaddr结构体.
网络字节序 网络字节序 字节序分为：
大端字节序（Big-endian） 小端字节序（Little-endian） 网络字节序（Network Byte Order）是指数据的高位字节保存在内存的低地址中，而数据的低位字节保存在内存的高地址中。就是大端字节序.
在TCP/IP协议中，所有长度字段和数字都采用网络字节序。例如，在TCP报文头部的源端口字段中，端口号的高位字节保存在内存的低地址中，而端口号的低位字节保存在内存的高地址中。
`,url:"https://hugo-dead-simple.netlify.com/linux_tcp_program/2/"},"https://hugo-dead-simple.netlify.com/linux_tcp_program/muduo/chapter1/":{title:"",tags:[],content:`线程安全的对象生命周期管理 在多线种的情况下,编写一个线程安全的类尤为困难.这里想要使用share_ptr来完全这些问题.
1.1.2 MutexLock与MutexLockGuard
这是一个简单的资源类，用RAII(RAII全称是“Resource Acquisition is Initialization”，直译过来是“资源获取即初始化”,也就是说在构造函数中申请分配资源，在析构函数中释放资源)手法封装互斥器的创建与销毁。在Linux下是pthread_mutex_t，默认是不可重入的（&amp;2.1.1）。MutexLock一般是别的class的数据成员。
MutexLockGuard封装临界区的进入和退出，即加锁和解锁。MutexLockGuard一般是个栈上的对象，它的作用域刚好等于临界区域。
这两个class都不允许拷贝构造和赋值，使用原则见&amp;2.1。
1.1.3 一个线程安全的Counter示例
这里使用了神奇的mutable关键字.
下面是相关的内容.
关键字mutable 关键字const 书上的counter类,在对象销毁的时候会有race caondition
1.2 对象的创建很简单
对象的构造要做到线程安全,唯一的要求就是在构造期间不要泄漏this指针.
1.3 销毁太难
成员函数用来保护临界区的互斥器本身必须是有效的。而析构函 数破坏了这一假设，它会把mutex成员变量销毁掉。悲剧啊
1.3.2 作为数据成员的 mutex 不能保护析构
原始指针有各种问题
1.4 线程安全的 Observer 有多难
一个Observable类,它持有另一个Observer的指针,在使用这个指针Observer * -&gt; update时,如何保证Observer是存在的呢?
在Observer析构时调用unregister(),这也不行,两个线程A,B同时在访问. A在析构,B的update,会产生未知情况.
1.4.1 线程安全的 Observer 有多难
1.4.2 线程安全的 Observer 有多难
1.6 神器shared_ptr/weak_ptr
1.8 应用到 Observer 上
既然通过 weak_ptr 能探查对象的生死，那么 Observer 模式的竞态条件就很容易解决，只要让 Observable 保存 weak_ptr 即可
如何改成shared_ptr,则对应的对象会一直存在.
1.9 再论 shared_ptr 的线程安全
但是 shared_ptr 本身不是100% 线程安全的。它的引用计数本身是安全且无锁的，但对象的读写则不是
`,url:"https://hugo-dead-simple.netlify.com/linux_tcp_program/muduo/chapter1/"},"https://hugo-dead-simple.netlify.com/linux_tcp_program/muduo/chapter2/":{title:"",tags:[],content:`1． 首要原则是尽量最低限度地共享对象， 减少需要同步的场合。 一个对象能不暴露给别的线程就不要暴露； 如果要暴露， 优先考虑 immutable对象； 实在不行才暴露可修改的对象， 并用同步措施来充分 保护它。 2． 其次是使用高级的并发编程构件， 如TaskQueue、 ProducerConsumer Queue、 CountDownLatch等等。 3． 最后不得已必须使用底层同步原语（primitives） 时， 只用非递 归的互斥器和条件变量， 慎用读写锁， 不要用信号量。 4． 除了使用atomic整数之外， 不自己编写lock-free代码3， 也不要 用“内核级”同步原语45。 不凭空猜测“哪种做法性能会更好”， 比如spin lock vs. mutex。
`,url:"https://hugo-dead-simple.netlify.com/linux_tcp_program/muduo/chapter2/"},"https://hugo-dead-simple.netlify.com/linux_tcp_program/muduo/frame/":{title:"",tags:[],content:`channel -&gt; eventloop &lt;- poller
eventloop 到底做了什么呢?
`,url:"https://hugo-dead-simple.netlify.com/linux_tcp_program/muduo/frame/"},"https://hugo-dead-simple.netlify.com/linux_tcp_program/muduo/readme/":{title:"",tags:[],content:`我前面已经看完了 TCPIP网络编程这本书.
muduo 学习笔记 834810071/muduo_study 基于 【高级】手写C++ Muduo网络库项目-掌握高性能网络库实现原理 代码 GitHub - ShangyizhouA-Tiny-Network-Library 使用 C++ 11 重构陈硕的 muduo 库，去除 boost 依赖。内部实现有 HTTP 服务器，可支持 GET 请求。 可以参考这个项目,看它是如果实现用户的注册与登录的 chenshuo/documents 有ppt https://github.com/iceCream1997/muduo_server_learn S1mpleBugmuduo_cpp11 C++11版本muduo网络库 除去了对boost库的依赖 还有视频教程 结合我自己写的一些c++的笔记 https://cpphub.roj.ac.cn 当然还有我们的cppreference 手册 Hansimovlinux-server 《Linux 高性能服务器编程》和《Linux多线程服务端编程：使用muduo C++网络库》的笔记和源码，以及两个轻量级服务器的项目代码 也比较有用 raichen/LinuxServerCodes: Linux高性能服务器编程源码 https://github.com/raichen/LinuxServerCodes chenshuo/muduo: Event-driven network library for multi-threaded Linux server in C++11 https://github.com/chenshuo/muduo qinguoyi/TinyWebServer: Linux下C++轻量级Web服务器 https://github.com/qinguoyi/TinyWebServer linyacool/WebServer: A C++ High Performance Web Server https://github.com/linyacool/WebServer 使用工具Webbench，进行测试 其它可以参考的库 Frees0u1smuduoChatServer 基于Muduo精简实现的Smuduo,在保留原有功能和特性(事件驱动的Reactor模式，非阻塞IO)的基础上，移除boost库依赖，大量使用C++11新特性. `,url:"https://hugo-dead-simple.netlify.com/linux_tcp_program/muduo/readme/"},"https://hugo-dead-simple.netlify.com/linux_tcp_program/my_test/%E7%90%86%E8%A7%A3/":{title:"",tags:[],content:`在你的 C++ 代码中，当执行 cv.wait(lk); 时，lk 锁（即 std::unique_lock 对象）会被自动释放。 详细解释
1.cv.wait(lk); 的作用:
2.cv.wait(lk); 这个调用会使当前线程在条件变量 cv 上等待，同时会解锁与 lk 关联的互斥锁 m。这意味着其他线程可以获取该互斥锁，并对共享数据进行修改。
3.锁的释放与再获取:
4.当条件变量 cv 通知（notify_one 或 notify_all）时，线程会被唤醒，重新获得 m 互斥锁，之后才会继续执行。wait 的返回时机通常是在被通知后，这时会重新获得锁。
5.实现原理:
6.在 cv.wait(lk); 的实现中，调用会执行以下步骤： 7.释放 lk（即释放互斥锁）。 8.将线程置于等待状态（挂起）。 9.等待通知后，再重新获取互斥锁。
总结 因此，在 cv.wait(lk); 调用时，lk 对应的互斥锁会被释放，允许其他线程在此期间执行临界区代码。当条件变量发出通知后，等待的线程会重新获得锁并继续执行。这是条件变量实现线程同步的核心机制。
`,url:"https://hugo-dead-simple.netlify.com/linux_tcp_program/my_test/%E7%90%86%E8%A7%A3/"},"https://hugo-dead-simple.netlify.com/linux_tcp_program/tcpip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/chapter_1/":{title:"",tags:[],content:`第一章 理解网络编程和socket ![INFO] 网络编程就是编写程序使用两台连网的计算机相互交换数据.
这就是整个网络编程的全部内容.我觉得不需要去详细的理解TCP/IP的细节.
下面我按我的理解这一章的内容.
如果我们想到在电脑上创建一个server端的软件,用来接收其它电脑上另一个程序通过网络发来的信息,应该如何做呢? 应该按下面的流程来做
1--- 2title: server socket 创建流程 3--- 4flowchart TD 5 step_1[1.创建socket,API:socket] 6 step_2[2.绑定端口与ip: bind] 7 step_3[3.开启监听 listen] 8 step_4[4.接受产生的socket: accept ] 9 step_1 --&gt; step_2 --&gt; step_3 --&gt; step_4; 第一步创建 socket(插座) 如果我们家里需要网络通信,首先要有一个网络面板(网络插座)用来连接网络,然后才能通信. 同样我们也需要先创建一个socket,这个socket的作用就是用于后面的网络连接.
1int socket(int domain,int type,int protocal) 具体参数的含义与理解见一下章节
第二步 bind函数 通过第一步我们创建了一个socket(插座),那么应该把它放在哪里呢? 其实就是根据哪些信息可以找到这个socket.
信息首先要能发送给电脑,也就是需要知道电脑的IP,一个电脑可以有多个IP. 比如这个电脑就有两个网口,(单网口也可以有多IP)
可以想像到一个电脑上能进行网络通信的软件有多个,那么就有很多个socket. 电脑为了和外部通信,创建了端口这个概念.
你可以把端口想像成电脑一个一个孔洞,每一个数据通过这个孔洞发流入进电脑,如何你的socket&quot;安装&quot;在这个端口上,那么就可以接收到这个数据了.
然后这个socket和还需要和某一端口绑定在一起.
1#include &lt;sys/socket.h&gt; 2int bind(int sockfd,struct sockaddr_in * myaddr,socklen_t addrlen) 第三步: 激活监听,listen 现在我们有了一个socket,并把它放到了合适的位置(bind),接下就能通信了吗? 不能,还需要启用,激活它,就像家里弄了网络面板,网线,还需要网络公司给我们开通网络权限.
1int listen(int sockfd,int backlog) listen的其实是在socket创建一个监听队列,队列大小为backlog,每一个client请求连接后,就会加入到队列里,等待处理
第四步: accept,处理连接请求 1int accept(int sockfd,struct sockaddr * addr ,socklen_t * addrlen); 上一步,可以接收连接,然后加入到队列里,但是还需要对这些队列里的内容进行处理.
accept的作用,从队列取出一个连接数据,然后创建一个socket.你可能会问,为什么又创建了一个socket,原来不是有一个吗?
首先我们要明确的知道一个概念,两个socket一在一起才能进行通信,或者说通信的两个电脑之间各有一个socket,不允许一socket对应多个socket.
第一个socket,我们的成为socket,我们称为server socket,它在同一时刻与一个client socket进行连接,然后接收到必要的信息之后.根据这些信息产生一个socket A.这个新的socket A已后只与这个client socket进行通信.
这个过程我们称为accept
server端代码 1{{#include code/1-hello_world_server.c}} 编译
1gcc -g -o server 1-hello_world_server.c 测试
1netcat -v 127.0.0.1 8989 结果
1➞ netcat -v 127.0.0.1 8989 2localhost [127.0.0.1] 8989 (sunwebadmins) open 3Hello World!% client端代码 client实现比较简单
创建socket 调用connect,与server socket进行连接 发送数据 接收返回的数据 结束client socket 1{{#include code/1-hello_world_client.c}} 运行结果
1➞ ./1-hello_world_client.out 2Message from server: Hello World! inet_addr 函数 inet_addr 是一个用于将 IPv4 地址从点分十进制字符串表示转换为网络字节序的 32 位二进制值的函数。它在 Linux 和其他类 Unix 系统的网络编程中广泛使用。
man 3 inet_addr
函数原型：
1#include &lt;arpa/inet.h&gt; 2in_addr_t inet_addr(const char *cp); 参数：
cp：以点分十进制格式表示的 IPv4 地址字符串，例如 &ldquo;192.168.0.1&rdquo;。 返回值：
成功时，返回转换后的 32 位网络字节序的 IPv4 地址。 失败时，返回 INADDR_NONE（通常为 -1）。 inet_addr 函数将点分十进制格式的 IPv4 地址字符串转换为网络字节序的 32 位二进制值。它执行以下步骤：
将点分十进制的 IPv4 地址字符串按照点号分隔符分割为四个部分，每个部分表示一个字节。 将每个部分转换为对应的整数值（0-255）。 将四个字节组合成一个 32 位的二进制值，并按照网络字节序排列。 例如，对于 IP 地址 &ldquo;192.168.0.1&rdquo;，inet_addr 函数将返回一个 32 位的整数值 0x0100A8C0（网络字节序）。
使用示例：
1#include &lt;stdio.h&gt; 2#include &lt;arpa/inet.h&gt; 3 4int main() { 5 const char *ip_str = &#34;192.168.0.1&#34;; 6 in_addr_t ip_addr = inet_addr(ip_str); 7 8 if (ip_addr == INADDR_NONE) { 9 printf(&#34;无效的 IP 地址\\n&#34;); 10 } else { 11 printf(&#34;IP 地址的网络字节序表示: 0x%08X\\n&#34;, ip_addr); 12 } 13 14 return 0; 15} 输出：
1IP 地址的网络字节序表示: 0x0100A8C0 需要注意的是，inet_addr 函数只支持 IPv4 地址的转换，对于 IPv6 地址，需要使用 inet_pton 函数进行转换。
另外，由于 inet_addr 函数不能处理格式错误的 IP 地址字符串，因此在实际使用中，通常推荐使用更加健壮和通用的 inet_pton 函数来进行 IP 地址的转换。
linux的文件操作 每一个程序都有多个文件描述符,从 0 到 1023，这些0,1,2文件描述符被称为标准输入、标准输出、标准错误。
这个文件描述符是由linux系统维护的.
1int open(const char *pathname, int flags); 2int close(int fd); 3ssize_t read(int fd, void *buf, size_t count); 4ssize_t write(int fd, const void *buf, size_t count); `,url:"https://hugo-dead-simple.netlify.com/linux_tcp_program/tcpip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/chapter_1/"},"https://hugo-dead-simple.netlify.com/linux_tcp_program/tcpip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/chapter_10/":{title:"",tags:[],content:`为了加大服务器同时处理用户的连接,有效的利用CPU
多进程服务器: 创建多个进程提供服务 多路复用: 捆绑并统一管理IO对象提供服务 多线程: 生成与客户短等量化的线程提供服务 10.1 进程概念及引用 理解进程 进程的定义如下：占用内存空间的正在运行的程序
进程ID 在说进程创建方法之前，先要简要说明进程 ID。无论进程是如何创建的，所有的进程都会被操作系统分配一个 ID。此 ID 被称为「进程ID」，其值为大于 2 的整数。1 要分配给操作系统启动后的（用于协助操作系统）首个进程，因此用户无法得到 ID 值为 1 。接下来观察在 Linux 中运行的进程。
fork创建进程 创建进程的方式很多，此处只介绍用于创建多进程服务端的 fork 函数。
1#include &lt;unistd.h&gt; 2pid_t fork(void); 3// 成功时返回进程ID,失败时返回 -1 fork 函数将创建调用的进程副本。也就是说，并非根据完全不同的程序创建进程，而是复制正在运行的、调用 fork 函数的进程。另外，两个进程都执行 fork 函数调用后的语句（准确的说是在 fork 函数返回后）。但因为是通过同一个进程、复制相同的内存空间，之后的程序流要根据 fork 函数的返回值加以区分。即利用 fork 函数的如下特点区分程序执行流程。
父进程：fork 函数返回子进程 ID 子进程：fork 函数返回 0 此处，「父进程」（Parent Process）指原进程，即调用 fork 函数的主体，而「子进程」（Child Process）是通过父进程调用 fork 函数复制出的进程。接下来是调用 fork 函数后的程序运行流程。如图所示：
从图中可以看出，父进程调用 fork 函数的同时复制出子进程，并分别得到 fork 函数的返回值。但复制前，父进程将全局变量 gval 增加到 11,将局部变量 lval 的值增加到 25，因此在这种状态下完成进程复制。复制完成后根据 fork 函数的返回类型区分父子进程。父进程的 lval 的值增加 1 ，但这不会影响子进程的 lval 值。同样子进程将 gval 的值增加 1 也不会影响到父进程的 gval 。因为 fork 函数调用后分成了完全不同的进程，只是二者共享同一段代码而已。接下来给出一个例子：
1#include &lt;stdio.h&gt; 2#include &lt;unistd.h&gt; 3int gval = 10; 4int main(int argc, char *argv[]) 5{ 6 pid_t pid; 7 int lval = 20; 8 gval++, lval += 5; 9 pid = fork(); 10 if (pid == 0) 11 gval += 2, lval += 2; 12 else 13 gval -= 2, lval -= 2; 14 if (pid == 0) 15 printf(&#34;Child Proc: [%d,%d] \\n&#34;, gval, lval); 16 else 17 printf(&#34;Parent Proc: [%d,%d] \\n&#34;, gval, lval); 18 return 0; 19} 10.2 进程与僵尸进程 文件操作中，关闭文件和打开文件同等重要。同样，进程销毁和进程创建也同等重要。如果未认真对待进程销毁，他们将变成僵尸进程。
进程的工作完成后（执行完 main 函数中的程序后）应被销毁，但有时这些进程将变成僵尸进程，占用系统中的重要资源。这种状态下的进程称作「僵尸进程」，这也是给系统带来负担的原因之一。
僵尸进程是当子进程比父进程先结束，而父进程又没有回收子进程，释放子进程占用的资源，此时子进程将成为一个僵尸进程。如果父进程先退出 ，子进程被init接管，子进程退出后init会回收其占用的相关资源
UNIX命令ps列出的进程的状态（&ldquo;STAT&rdquo;）栏标示为 &ldquo;Z&quot;则为僵尸进程。[1]
收割僵尸进程的方法是通过kill命令手工向其父进程发送SIGCHLD信号。如果其父进程仍然拒绝收割僵尸进程，则终止父进程，使得init进程收养僵尸进程。init进程周期执行wait系统调用收割其收养的所有僵尸进程。
产生僵尸进程的原因 产生僵尸进程的原因是: 当子进程结束时,操作系统不会主动将子进程的退出状态传递给父进程 。只有父进程主动请求获取子进程的退出状态, 操作系统才会将其传递。如果父进程没有主动要求获取子进程的退出状态,操作系统将一直保存子进程的退出状态,导致子进程长时间处于僵尸进程状态。因此,为了及时回收子进程,父进程应该主动获取子进程的退出状态。
zombie.c
1{{#include chapter_10/zombie.c }} 销毁僵尸 wait函数 父进程应该主动请求获取子进程的返回值以销毁子进程。使用 wait 函数来获取子进程的终止状态，通过宏 WIFEXITED 和 WEXITSTATUS 来分离和处理子进程的返回值。
{{#include chapter_10/wait.c }}
销毁僵尸 waitpid函数 wait 函数会引起程序阻塞，还可以考虑调用 waitpid 函数。这是防止僵尸进程的第二种方法，也是防止阻塞的方法。
1#include &lt;sys/wait.h&gt; 2pid_t waitpid(pid_t pid, int *statloc, int options); 3/* 4成功时返回终止的子进程ID 或 0 ，失败时返回 -1 5pid: 等待终止的目标子进程的ID,若传 -1，则与 wait 函数相同，可以等待任意子进程终止 6statloc: 与 wait 函数的 statloc 参数具有相同含义 7options: 传递头文件 sys/wait.h 声明的常量 WNOHANG ,即使没有终止的子进程也不会进入阻塞状态，而是返回 0 退出函数。 8*/ waitpid.c
1#include &lt;stdio.h&gt; 2#include &lt;unistd.h&gt; 3#include &lt;sys/wait.h&gt; 4int main(int argc, char *argv[]) 5{ 6 int status; 7 pid_t pid = fork(); 8 if (pid == 0) 9 { 10 sleep(15); //用 sleep 推迟子进程的执行 11 return 24; 12 } 13 else 14 { 15 //调用waitpid 传递参数 WNOHANG ，这样之前有没有终止的子进程则返回0 16 while (!waitpid(-1, &amp;status, WNOHANG)) 17 { 18 sleep(3); 19 puts(&#34;sleep 3 sec.&#34;); 20 } 21 if (WIFEXITED(status)) 22 printf(&#34;Child send %d \\n&#34;, WEXITSTATUS(status)); 23 } 24 return 0; 10.3 信号处理 子进程究竟何时终止？调用 waitpid 函数后要无休止的等待吗？
信号是一种软中断，它是由操作系统向进程发送的通知消息。信号的作用是通知进程发生了某种事件，如进程终止、进程收到某种输入、进程执行时间到达某一点等。信号的处理方式是通过信号处理函数来实现的。
子进程终止的识别主体是操作系统，因此，若操作系统能把子进程结束的信息告诉正忙于工作的父进程，将有助于构建更高效的程序
信号与signal函数 我们可以注册信号处理函数，当信号发生时，操作系统将调用相应的信号处理函数。信号处理函数的原型如下：
1#include &lt;signal.h&gt; 2void (*signal(int signo, void (*func)(int)))(int); 3/* 4为了在产生信号时调用，返回之前注册的函数指针 5函数名: signal 6参数：int signo,void(*func)(int) 7返回类型：参数类型为int型，返回 void 型函数指针 8*/ 这个函数比较难,我这样理解
有函数为
1void func_a(int) 这个函数的是一个返回值为void,参数为int的函数.
1void (*func_b)(int) 2 3//相当于 4 5//定义一个类型,函数指针 6typedef void (*)(int) func_a_pointer; 7// 定义一个指向函数的变量 8func_a_pointer func_a_p = func_a; 怎么理解函数指针 再难一点,定义函数的返回值 为函数指针
1void (*func_c(int))(int) 2 3typedef void (*)(int) func_a_pointer; 4// 定义一个指向函数的变量 5func_a_pointer function_c(int); 再难一点,函数的返回值为函数指针,且函数的参数还有一个函数指针
1void (*signal(int signo, void (*func)(int)))(int); 调用上述函数时，第一个参数为特殊情况信息，第二个参数为特殊情况下将要调用的函数的地址值（指针）。发生第一个参数代表的情况时，调用第二个参数所指的函数。下面给出可以在 signal 函数中注册的部分特殊情况和对应的函数。
SIGALRM：已到通过调用 alarm 函数时候产生 SIGINT：输入 ctrl+c SIGCHLD：子进程终止 1#include &lt;stdio.h&gt; 2#include &lt;unistd.h&gt; 3#include &lt;signal.h&gt; 4void timeout(int sig) //信号处理器 5{ 6 if (sig == SIGALRM) 7 puts(&#34;Time out!&#34;); 8 alarm(2); //为了每隔 2 秒重复产生 SIGALRM 信号，在信号处理器中调用 alarm 函数 9} 10void keycontrol(int sig) //信号处理器 11{ 12 if (sig == SIGINT) 13 puts(&#34;CTRL+C pressed&#34;); 14} 15int main(int argc, char *argv[]) 16{ 17 int i; 18 signal(SIGALRM, timeout); //注册信号及相应处理器 19 signal(SIGINT, keycontrol); 20 alarm(2); //预约 2 秒候发生 SIGALRM 信号 21 22 for (i = 0; i &lt; 3; i++) 23 { 24 puts(&#34;wait...&#34;); 25 sleep(100); 26 } 27 return 0; 28} 发生信号时将唤醒由于调用 sleep 函数而进入阻塞状态的进程。
利用 sigaction 函数进行信号处理 还有一个函数，叫做 sigaction 函数，他类似于 signal 函数，而且可以完全代替后者，也更稳定。之所以稳定，是因为：
signal 函数在 Unix 系列的不同操作系统可能存在区别，但 sigaction 函数完全相同
实际上现在很少用 signal 函数编写程序，他只是为了保持对旧程序的兼容，下面介绍 sigaction 函数，只讲解可以替换 signal 函数的功能。
1#include &lt;signal.h&gt; 2 3int sigaction(int signo, const struct sigaction *act, struct sigaction *oldact); 4/* 5成功时返回 0 ，失败时返回 -1 6act: 对于第一个参数的信号处理函数（信号处理器）信息。 7oldact: 通过此参数获取之前注册的信号处理函数指针，若不需要则传递 0 8*/ 声明并初始化 sigaction 结构体变量以调用上述函数，该结构体定义如下：
1struct sigaction 2{ 3 void (*sa_handler)(int); 4 sigset_t sa_mask; 5 int sa_flags; 6}; 1#include &lt;stdio.h&gt; 2#include &lt;unistd.h&gt; 3#include &lt;signal.h&gt; 4 5void timeout(int sig) 6{ 7 if (sig == SIGALRM) 8 puts(&#34;Time out!&#34;); 9 alarm(2); 10} 11 12int main(int argc, char *argv[]) 13{ 14 int i; 15 struct sigaction act; 16 act.sa_handler = timeout; //保存函数指针 17 sigemptyset(&amp;act.sa_mask); //将 sa_mask 成员的所有位初始化成0 18 act.sa_flags = 0; //sa_flags 同样初始化成 0 19 sigaction(SIGALRM, &amp;act, 0); //注册 SIGALRM 信号的处理器。 20 21 alarm(2); //2 秒后发生 SIGALRM 信号 22 23 for (int i = 0; i &lt; 3; i++) 24 { 25 puts(&#34;wait...&#34;); 26 sleep(100); 27 } 28 return 0; 29} 10.3.4 利用信号处理技术消灭僵尸进程 下面利用子进程终止时产生 SIGCHLD 信号这一点，来用信号处理来消灭僵尸进程。看以下代码：
1#include &lt;stdio.h&gt; 2#include &lt;stdlib.h&gt; 3#include &lt;unistd.h&gt; 4#include &lt;signal.h&gt; 5#include &lt;sys/wait.h&gt; 6 7void read_childproc(int sig) 8{ 9 int status; 10 pid_t id = waitpid(-1, &amp;status, WNOHANG); 11 if (WIFEXITED(status)) 12 { 13 printf(&#34;Removed proc id: %d \\n&#34;, id); //子进程的 pid 14 printf(&#34;Child send: %d \\n&#34;, WEXITSTATUS(status)); //子进程的返回值 15 } 16} 17 18int main(int argc, char *argv[]) 19{ 20 pid_t pid; 21 struct sigaction act; 22 act.sa_handler = read_childproc; 23 sigemptyset(&amp;act.sa_mask); 24 act.sa_flags = 0; 25 sigaction(SIGCHLD, &amp;act, 0); 26 27 pid = fork(); 28 if (pid == 0) //子进程执行阶段 29 { 30 puts(&#34;Hi I&#39;m child process&#34;); 31 sleep(10); 32 return 12; 33 } 34 else //父进程执行阶段 35 { 36 printf(&#34;Child proc id: %d\\n&#34;, pid); 37 pid = fork(); 38 if (pid == 0) 39 { 40 puts(&#34;Hi! I&#39;m child process&#34;); 41 sleep(10); 42 exit(24); 43 } 44 else 45 { 46 int i; 47 printf(&#34;Child proc id: %d \\n&#34;, pid); 48 for (i = 0; i &lt; 5; i++) 49 { 50 puts(&#34;wait&#34;); 51 sleep(5); 52 } 53 } 54 } 55 return 0; 56} 10.4 基于多任务的并发服务器 之前的回声服务器每次只能同事向 1 个客户端提供服务。因此，需要扩展回声服务器，使其可以同时向多个客户端提供服务。下图是基于多进程的回声服务器的模型。
从图中可以看出，每当有客户端请求时（连接请求），回声服务器都创建子进程以提供服务。如果请求的客户端有 5 个，则将创建 5 个子进程来提供服务，为了完成这些任务，需要经过如下过程：
第一阶段：回声服务器端（父进程）通过调用 accept 函数受理连接请求 第二阶段：此时获取的套接字文件描述符创建并传递给子进程 第三阶段：子进程利用传递来的文件描述符提供服务 Q ? 如何传递给子进程文件描述符
A 子进程会复制父进程的所有的资源,所以不需要传递
Q: 子进程会复制父进程的server_sd（套接字文件描述符）吗? 那他会收到cient的数据吗?
1#include &lt;stdio.h&gt; 2#include &lt;stdlib.h&gt; 3#include &lt;string.h&gt; 4#include &lt;unistd.h&gt; 5#include &lt;signal.h&gt; 6#include &lt;sys/wait.h&gt; 7#include &lt;arpa/inet.h&gt; 8#include &lt;sys/socket.h&gt; 9 10#define BUF_SIZE 30 11void error_handling(char *message); 12void read_childproc(int sig); 13 14int main(int argc, char *argv[]) 15{ 16 int serv_sock, clnt_sock; 17 struct sockaddr_in serv_adr, clnt_adr; 18 19 pid_t pid; 20 struct sigaction act; 21 socklen_t adr_sz; 22 int str_len, state; 23 char buf[BUF_SIZE]; 24 if (argc != 2) 25 { 26 printf(&#34;Usgae : %s &lt;port&gt;\\n&#34;, argv[0]); 27 exit(1); 28 } 29 act.sa_handler = read_childproc; //防止僵尸进程 30 sigemptyset(&amp;act.sa_mask); 31 act.sa_flags = 0; 32 state = sigaction(SIGCHLD, &amp;act, 0); //注册信号处理器,把成功的返回值给 state 33 serv_sock = socket(PF_INET, SOCK_STREAM, 0); //创建服务端套接字 34 memset(&amp;serv_adr, 0, sizeof(serv_adr)); 35 serv_adr.sin_family = AF_INET; 36 serv_adr.sin_addr.s_addr = htonl(INADDR_ANY); 37 serv_adr.sin_port = htons(atoi(argv[1])); 38 39 if (bind(serv_sock, (struct sockaddr *)&amp;serv_adr, sizeof(serv_adr)) == -1) //分配IP地址和端口号 40 error_handling(&#34;bind() error&#34;); 41 if (listen(serv_sock, 5) == -1) //进入等待连接请求状态 42 error_handling(&#34;listen() error&#34;); 43 44 while (1) 45 { 46 adr_sz = sizeof(clnt_adr); 47 clnt_sock = accept(serv_sock, (struct sockaddr *)&amp;clnt_adr, &amp;adr_sz); 48 if (clnt_sock == -1) 49 continue; 50 else 51 puts(&#34;new client connected...&#34;); 52 pid = fork(); //此时，父子进程分别带有一个套接字 53 if (pid == -1) 54 { 55 close(clnt_sock); 56 continue; 57 } 58 if (pid == 0) //子进程运行区域,此部分向客户端提供回声服务 59 { 60 close(serv_sock); //关闭服务器套接字，因为从父进程传递到了子进程 61 while ((str_len = read(clnt_sock, buf, BUFSIZ)) != 0) 62 write(clnt_sock, buf, str_len); 63 64 close(clnt_sock); 65 puts(&#34;client disconnected...&#34;); 66 return 0; 67 } 68 else 69 close(clnt_sock); //通过 accept 函数创建的套接字文件描述符已经复制给子进程，因为服务器端要销毁自己拥有的 70 } 71 close(serv_sock); 72 73 return 0; 74} 75 76void error_handling(char *message) 77{ 78 fputs(message, stderr); 79 fputc(&#39;\\n&#39;, stderr); 80 exit(1); 81} 82void read_childproc(int sig) 83{ 84 pid_t pid; 85 int status; 86 pid = waitpid(-1, &amp;status, WNOHANG); 87 printf(&#34;removed proc id: %d \\n&#34;, pid); 88} 10.4.2 实现并发服务器 10.4.3 通过 fork 函数复制文件描述符 示例中给出了通过 fork 函数复制文件描述符的过程。父进程将 2 个套接字（一个是服务端套接字另一个是客户端套接字）文件描述符复制给了子进程。
调用 fork 函数时赋值父进程的所有资源，但是套接字不是归进程所有的，而是归操作系统所有，只是进程拥有代表相应套接字的文件描述符。
如图所示，1 个套接字存在 2 个文件描述符时，只有 2 个文件描述符都终止（销毁）后，才能销毁套接字。如果维持图中的状态，即使子进程销毁了与客户端连接的套接字文件描述符，也无法销毁套接字（服务器套接字同样如此）。因此调用 fork 函数后，要将无关紧要的套接字文件描述符关掉，如图所示：
10.5 分割 TCP 的 I/O 程序 `,url:"https://hugo-dead-simple.netlify.com/linux_tcp_program/tcpip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/chapter_10/"},"https://hugo-dead-simple.netlify.com/linux_tcp_program/tcpip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/chapter_2/":{title:"",tags:[],content:`socket类型与协议设置 下我只与我理解的内容,如果全部都写,那么就变在了抄书了.
1int socket(int domain, int type, int protocol); 其中的domain参数指定协议族,常见的有AF_INET, AF_INET6, AF_UNIX等,分别对应IPv4, IPv6, Unix Domain Socket.
type参数指定socket类型,常见的有SOCK_STREAM, SOCK_DGRAM, SOCK_RAW, SOCK_SEQPACKET等,分别对应TCP流式socket, UDP数据报式socket, 原始套接字, 顺序包套接字等.
protocol参数指定协议,常见的有IPPROTO_TCP, IPPROTO_UDP, IPPROTO_RAW, IPPROTO_SCTP等,分别对应TCP, UDP, 原始协议, SCTP等.
一般情况下,我们只需要设置domain和type参数,因为protocol参数一般由系统自动设置.
例如,创建一个TCP流式socket,可以使用如下代码:
这个用到的最多,其实也只用到这个(我们自己写的简单代码).
1int sockfd = socket(AF_INET, SOCK_STREAM, 0); 创建一个UDP数据报式socket,可以使用如下代码:
1int sockfd = socket(AF_INET, SOCK_DGRAM, 0); 创建一个原始套接字,可以使用如下代码:
1int sockfd = socket(AF_INET, SOCK_RAW, IPPROTO_RAW); 传输的数据不存在数据边界 书上告诉我们,socket数据的传输是无边界的,也就是说,我们发送的数据可能被拆分成多个包,也可能被粘包,接收方也可能一次接收多个包,这取决于网络的传输速率和接收方处理能力.
这里给出一个我根据书上写的client.c代码,用来接收TCP流式socket数据:
它一次只能读取一个字节.
1int tot = 0; 2int read_len; 3char buf[1024] 4while(1) { 5 //一次读取一个字节 6 read_len = read(sockfd, buf, 1); 7 if( read_len == -1) break; 8 //输出读取的字符 9 printf(&#34;%c&#34;,buf[0]); 10 tot += read_len; 11} `,url:"https://hugo-dead-simple.netlify.com/linux_tcp_program/tcpip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/chapter_2/"},"https://hugo-dead-simple.netlify.com/linux_tcp_program/tcpip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/chapter_3/":{title:"",tags:[],content:`地址族与数据序列 书上讲解了一些ipv4地址的概念，以及ipv6地址的概念。
又说了一些端口号的概念，以及端口号的作用。
但是还是很复杂的,直接理解我第一章节说的内容,每个概念只有一句话.但是这是建立在我对网络编程的了解基础上的.
下讲解了
1mindmap 2 root((sockadd_in)) 3 sin_family(sin_family) 4 AF_INET(AF_INET) 5 AF_INET6(AF_INET6) 6 AF_Local(AF_Local) 7 sin_port(sin_port) 8 htons(&#34;htons(int)&#34;) 9 sin_addr(sin_addr) 10 s_addr(s_addr) 11 inet_addr(&#34;inet_addr(char*)&#34;) 需要把sockaddr_in转化成struct sockaddr *才能使用bind()等函数.
网络字节序与地址的转换 htons(int)：将int类型整数转换为网络字节序。 htonl(int)：将int类型整数转换为网络字节序。 ntohs(int)：将int类型整数转换为主机字节序。 ntohl(int)：将int类型整数转换为主机字节序。 inet_addr(char*)：将char*类型字符串转换为in_addr类型。 inet_aton(char*, struct in_addr*)：将char*类型字符串转换为in_addr类型。 inet_ntoa(struct in_addr)：将in_addr类型转换为char*类型字符串,失败返回-1 每次创建服务器端socket都要输入IP地址会有些繁琐,此时可以使用如下的初始化地址信息
1struct sockaddr_in server_addr; 2char * serv_port = &#34;8989&#34;; 3server_addr.sin_family = AF_INET; 4server_addr.sin_port = htons(atoi(serv_port)); 5server_addr.sin_addr.s_addr = inet_addr(INADDR_ANY); `,url:"https://hugo-dead-simple.netlify.com/linux_tcp_program/tcpip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/chapter_3/"},"https://hugo-dead-simple.netlify.com/linux_tcp_program/tcpip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/chapter_4/":{title:"",tags:[],content:`基于tcp的服务器端/客户端 详细的内容看这里,我就不复制了:
https://github.com/riba2534/TCP-IP-NetworkNote/blob/master/ch04/README.md
TCP/IP 协议栈共分为 4 层，可以理解为数据收发分成了 4 个层次化过程，通过层次化的方式来解决问题
链路层: 物理层,负责网络设备之间的通信，如网卡、网线等 IP层: 数据包进行中线选择 TCP/UDP层: 负责数据包的传输，保证数据包的可靠性和顺序性 实现基于 TCP 的服务器/客户端 代码: hello_server
1{{#include ch04/hello_server.c}} 代码: hello_client
1{{#include ch04/hello_client.c}} echo服务器/客户端 程序运行的基本方式：
服务器端在同一时刻只与一个客户端相连，并提供回声服务。 服务器端依次向 5 个客户端提供服务并退出。for循环5次 客户端接受用户输入的字符串并发送到服务器端。 服务器端将接受的字符串数据传回客户端，即「回声」 服务器端与客户端之间的字符串回声一直执行到客户端输入 Q 为止。 1{{#include ch04/echo_server.c}} 1{{#include ch04/echo_client.c}} FAQ 问: 我在在linux下使用socket进行tcp网络编程,如果client端调用了close(sock)函数,那么server端口的read函数会读取到什么?
答:
在Linux下使用socket进行TCP网络编程时,如果客户端调用了close(sock)函数,服务器端的read函数的行为取决于客户端关闭连接的方式和时机。
通常情况下,当客户端调用close(sock)函数时,会向服务器发送一个FIN包,表示客户端想要关闭连接。服务器收到FIN包后,会做出以下响应:
如果服务器已经读取了所有客户端发送的数据,那么read函数会返回0,表示已经到达文件末尾(EOF)。这意味着客户端已经关闭了连接,并且没有更多的数据可读。
如果服务器还没有读取完客户端发送的所有数据,那么read函数会继续读取剩余的数据,直到读取完所有数据或者遇到错误为止。在这种情况下,read函数会返回实际读取到的字节数。当所有数据读取完毕后,再次调用read函数会返回0,表示已经到达文件末尾(EOF)。
如果客户端在发送数据的过程中突然关闭了连接,那么服务器的read函数可能会返回一个错误,通常是ECONNRESET错误,表示连接被重置。
需要注意的是,如果客户端在关闭连接之前没有发送所有的数据,那么服务器可能会丢失一部分数据。为了确保数据的完整性,通常建议在关闭连接之前,先调用shutdown(sock, SHUT_WR)函数,告诉操作系统不再发送数据,然后再调用close(sock)函数关闭连接。
总之,服务器端的read函数在客户端关闭连接时的行为取决于具体的情况:
如果客户端发送了所有数据并关闭连接,read函数会返回0,表示EOF。 如果客户端关闭连接时还有未读取的数据,read函数会继续读取剩余数据,直到读取完毕,然后返回0,表示EOF。 如果客户端异常关闭连接,read函数可能会返回错误,如ECONNRESET。 作为服务器端,需要正确处理这些不同的情况,以确保程序的正确性和鲁棒性。
问: 如何检测到 read函数返回一个错误, 例如是ECONNRESET?
在Linux系统中,当read函数返回错误时,会设置全局变量errno来指示具体的错误类型。你可以通过检查errno的值来判断是否发生了ECONNRESET错误。
下面是一个示例代码,演示了如何检测read函数返回的错误:
1#include &lt;stdio.h&gt; 2#include &lt;stdlib.h&gt; 3#include &lt;unistd.h&gt; 4#include &lt;errno.h&gt; 5#include &lt;string.h&gt; 6 7ssize_t read_data(int sockfd, void *buf, size_t len) { 8 ssize_t num_read = read(sockfd, buf, len); 9 if (num_read == -1) { 10 if (errno == ECONNRESET) { 11 printf(&#34;Connection reset by peer\\n&#34;); 12 } else { 13 perror(&#34;read&#34;); 14 } 15 return -1; 16 } 17 return num_read; 18} 在上面的代码中,read_data函数封装了read函数的调用。它检查read函数的返回值:
如果返回值为-1,表示发生了错误。此时,通过检查errno的值来判断具体的错误类型: 如果errno的值等于ECONNRESET,表示连接被对端重置,可以输出相应的错误信息。 否则,可以使用perror函数输出错误信息,perror函数会根据errno的值自动生成对应的错误描述。 如果返回值不为-1,表示读取成功,函数返回实际读取到的字节数。 在实际使用时,你可以根据需要对read_data函数进行调用,并根据返回值进行相应的处理:
1char buffer[1024]; 2ssize_t num_read = read_data(sockfd, buffer, sizeof(buffer)); 3if (num_read == -1) { 4 // 处理错误情况 5} else if (num_read == 0) { 6 // 处理连接关闭的情况 7} else { 8 // 处理成功读取数据的情况 9} 通过检查read_data函数的返回值,你可以判断是否发生了错误,并根据具体的错误类型采取相应的处理措施。
总之,通过检查read函数的返回值和errno的值,你可以检测并处理read函数返回的错误,包括ECONNRESET错误。这样可以增强程序的健壮性和可靠性。
`,url:"https://hugo-dead-simple.netlify.com/linux_tcp_program/tcpip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/chapter_4/"},"https://hugo-dead-simple.netlify.com/linux_tcp_program/tcpip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/chapter_5/":{title:"",tags:[],content:`基于tcp的服务器端/客户端(2) 本章节详细的讲解了TCP 中必要的理论知识
回声客户端问题的解决办法 这个问题其实很容易解决，因为可以提前接受数据的大小。若之前传输了20字节长的字符串，则再接收时循环调用 read 函数读取 20 个字节即可。既然有了解决办法，核心那么代码如下：
1 2//得到发送的数据大小 3str_len = write(sockfd,message,sizeof(message)); 4int recv_len = 0; 5while( recv_len &lt; str_len ) { 6 int recv_cnt += read(sockfd,recv_buf,str_len-recv_len); 7 //对方关闭了连接 8 if( recv_cnt == 0 ) { 9 break; 10 } 11 if( recv_cnt &lt; 0 ) { 12 error_handing(&#34;read error&#34;)! 13 } 14 recv_len += recv_cnt; 15} 16message[recv_len] = &#39;\\0&#39;; 17printf(&#34;Received message: %s\\n&#34;,message); TCP 原理 TCP socket中的I/O缓冲
IO缓冲在每个TCP socket中单独存在.
IO缓冲在在创建TCP socket自动生成.
即使关闭socket 也会继续传递输出缓冲中遗留的数据.
关闭socket会丢失输入缓冲中的数据.
不会发生超过输入缓冲大小的数据传输!
write函数会在数据移到输出缓冲时返回.
1. TCP连接 3次握手(three-way handshaking)
1[SYN] SEQ:1000 ACK:NULL 2[SYN+ACK] SEQ: 2000, ACK: 1001 3[ACK] SEQ: 1001, ACK: 2001 2. TCP传输 3. TCP断开 `,url:"https://hugo-dead-simple.netlify.com/linux_tcp_program/tcpip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/chapter_5/"},"https://hugo-dead-simple.netlify.com/linux_tcp_program/tcpip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/chapter_7/":{title:"",tags:[],content:`1 单方面断开连接带来的问题 主机 A 发送完最后的数据后，调用 close 函数断开了最后的连接，之后主机 A 无法再接受主机 B 传输的数据。实际上，是完全无法调用与接受数据相关的函数。最终，由主机 B 传输的、主机 A 必须要接受的数据也销毁了。
2. shutdown函数的作用 1#include &lt;sys/socket.h&gt; 2int shutdown(int sock, int howto); 3/* 4成功时返回 0 ，失败时返回 -1 5sock: 需要断开套接字文件描述符 6howto: 传递断开方式信息 7*/ 调用上述函数时，第二个参数决定断开连接的方式，其值如下所示：
SHUT_RD : 断开输入流 SHUT_WR : 断开输出流 SHUT_RDWR : 同时断开 I/O 流 若向 shutdown 的第二个参数传递SHUT_RD，则断开输入流，套接字无法接收数据。即使输入缓冲收到数据也会抹去，而且无法调用相关函数。如果向 shutdown 的第二个参数传递SHUT_WR，则中断输出流，也就无法传输数据。若如果输出缓冲中还有未传输的数据，则将传递给目标主机。最后，若传递关键字SHUT_RDWR，则同时中断 I/O 流。这相当于分 2 次调用 shutdown ，其中一次以SHUT_RD为参数，另一次以SHUT_WR为参数
3. 为什么要半关闭连接 留下足够的时间,等所有的数据交换完不就行了,好像也没有必要使用半关闭.
考虑以下情况：
一旦客户端连接到服务器，服务器将约定的文件传输给客户端，客户端收到后发送字符串「Thank you」给服务器端。
此处「Thank you」的传递是多余的，这只是用来模拟客户端断开连接前还有数据要传输的情况。此时程序的还嫌难度并不小，因为传输文件的服务器端只需连续传输文件数据即可，而客户端无法知道需要接收数据到何时。客户端也没办法无休止的调用输入函数，因为这有可能导致程序阻塞。
是否可以让服务器和客户端约定一个代表文件尾的字符？
这种方式也有问题，因为这意味这文件中不能有与约定字符相同的内容。为了解决该问题，服务端应最后向客户端传递 EOF 表示文件传输结束。客户端通过函数返回值接受 EOF ，这样可以避免与文件内容冲突。那么问题来了，服务端如何传递 EOF ？
断开输出流时向主机传输 EOF。
当然，调用 close 函数的同时关闭 I/O 流，这样也会向对方发送 EOF 。但此时无法再接受对方传输的数据。换言之，若调用 close 函数关闭流，就无法接受客户端最后发送的字符串「Thank you」。这时需要调用 shutdown 函数，只关闭服务器的输出流。这样既可以发送 EOF ，同时又保留了输入流。下面实现收发文件的服务器端/客户端。
4. 基于半关闭的文件传输程序 server代码
1{{#include chapter_7/file_server.c}} client代码
1{{#include chapter_7/file_client.c}} `,url:"https://hugo-dead-simple.netlify.com/linux_tcp_program/tcpip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/chapter_7/"},"https://hugo-dead-simple.netlify.com/linux_tcp_program/tcpip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/chapter_8/":{title:"",tags:[],content:`第 8 章 域名及网络地址 本章代码，在TCP-IP-NetworkNote中可以找到。
8.1 域名系统 DNS 是对IP地址和域名进行相互转换的系统，其核心是 DNS 服务器
8.1.1 什么是域名 域名就是我们常常在地址栏里面输入的地址，将比较难记忆的IP地址变成人类容易理解的信息。
8.1.2 DNS 服务器 相当于一个字典，可以查询出某一个域名对应的IP地址
如图所示，显示了 DNS 服务器的查询路径。
8.2 IP地址和域名之间的转换 8.2.1 程序中有必要使用域名吗？ 一句话，需要，因为IP地址可能经常改变，而且也不容易记忆，通过域名可以随时更改解析，达到更换IP的目的
8.2.2 利用域名获取IP地址 使用以下函数可以通过传递字符串格式的域名获取IP地址
1#include &lt;netdb.h&gt; 2struct hostent *gethostbyname(const char *hostname); 3/* 4成功时返回 hostent 结构体地址，失败时返回 NULL 指针 5*/ 这个函数使用方便，只要传递字符串，就可以返回域名对应的IP地址。只是返回时，地址信息装入 hostent 结构体。此结构体的定义如下：
1struct hostent 2{ 3 char *h_name; /* Official name of host. */ 4 char **h_aliases; /* Alias list. */ 5 int h_addrtype; /* Host address type. */ 6 int h_length; /* Length of address. */ 7 char **h_addr_list; /* List of addresses from name server. */ 8}; 从上述结构体可以看出，不止返回IP信息，同事还带着其他信息一起返回。域名转换成IP时只需要关注 h_addr_list 。下面简要说明上述结构体的成员：
h_name：该变量中存有官方域名（Official domain name）。官方域名代表某一主页，但实际上，一些著名公司的域名并没有用官方域名注册。 h_aliases：可以通过多个域名访问同一主页。同一IP可以绑定多个域名，因此，除官方域名外还可以指定其他域名。这些信息可以通过 h_aliases 获得。 h_addrtype：gethostbyname 函数不仅支持 IPV4 还支持 IPV6 。因此可以通过此变量获取保存在 h_addr_list 的IP地址族信息。若是 IPV4 ，则此变量中存有 AF_INET。 h_length：保存IP地址长度。若是 IPV4 地址，因为是 4 个字节，则保存4；IPV6 时，因为是 16 个字节，故保存 16 h_addr_list：这个是最重要的的成员。通过此变量以整数形式保存域名相对应的IP地址。另外，用户比较多的网站有可能分配多个IP地址给同一个域名，利用多个服务器做负载均衡，。此时可以通过此变量获取IP地址信息。 调用 gethostbyname 函数后，返回的结构体变量如图所示：
下面的代码通过一个例子来演示 gethostbyname 的应用，并说明 hostent 结构体变量特性。
gethostbyname.c 编译运行：
1gcc gethostbyname.c -o hostname 2./hostname www.baidu.com 结果：
如图所示，显示出了对百度的域名解析
可以看出，百度有一个域名解析是 CNAME 解析的，指向了shifen.com，关于百度具体的解析过程。
这一部分牵扯到了很多关于DNS解析的过程，还有 Linux 下关于域名解析的一些命令，我找了一部分资料，可以点下面的链接查看比较详细的：
关于百度DNS的解析过程 DNS解析的过程是什么，求详细的？ Linux DNS 查询剖析 Linux DNS查询命令 Linux中DNS服务器地址查询命令nslookup使用教程 DNS 原理入门 仔细阅读这一段代码：
1inet_ntoa(*(struct in_addr *)host-&gt;h_addr_list[i]) 若只看 hostent 的定义，结构体成员 h_addr_list 指向字符串指针数组（由多个字符串地址构成的数组）。但是字符串指针数组保存的元素实际指向的是 in_addr 结构体变量中地址值而非字符串，也就是说(struct in_addr *)host-&gt;h_addr_list[i]其实是一个指针，然后用*符号取具体的值。如图所示：
8.2.3 利用IP地址获取域名 请看下面的函数定义：
1#include &lt;netdb.h&gt; 2struct hostent *gethostbyaddr(const char *addr, socklen_t len, int family); 3/* 4成功时返回 hostent 结构体变量地址值，失败时返回 NULL 指针 5addr: 含有IP地址信息的 in_addr 结构体指针。为了同时传递 IPV4 地址之外的全部信息，该变量的类型声明为 char 指针 6len: 向第一个参数传递的地址信息的字节数，IPV4时为 4 ，IPV6 时为16. 7family: 传递地址族信息，ipv4 是 AF_INET ，IPV6是 AF_INET6 8*/ 下面的代码演示使用方法：
gethostbyaddr.c 编译运行：
1gcc gethostbyaddr.c -o hostaddr 2./hostaddr 8.8.8.8 结果：
从图上可以看出，8.8.8.8这个IP地址是谷歌的。
8.3 基于 Windows 的实现 暂略
8.4 习题 以下答案仅代表本人个人观点，可能不是正确答案。
下列关于DNS的说法错误的是？
答：字体加粗的表示正确答案。
因为DNS从存在，故可以使用域名代替IP DNS服务器实际上是路由器，因为路由器根据域名决定数据的路径 所有域名信息并非集中与 1 台 DNS 服务器，但可以获取某一 DNS 服务器中未注册的所有地址 DNS 服务器根据操作系统进行区分，Windows 下的 DNS 服务器和 Linux 下的 DNS 服务器是不同的。 阅读如下对话，并说明东秀的方案是否可行。（因为对话的字太多，用图代替）
答：答案就是可行，DNS 服务器是分布式的，一台坏了可以找其他的。
在浏览器地址输入 www.orentec.co.kr ，并整理出主页显示过程。假设浏览器访问默认 DNS 服务器中并没有关于 www.orentec.co.kr 的地址信息.
答：可以参考一下知乎回答，在浏览器地址栏输入一个URL后回车，背后会进行哪些技术步骤？,我用我自己的理解，简单说一下，首先会去向上一级的 DNS 服务器去查询，通过这种方式逐级向上传递信息，一直到达根服务器时，它知道应该向哪个 DNS 服务器发起询问。向下传递解析请求，得到IP地址候原路返回，最后会将解析的IP地址传递到发起请求的主机。
代码 gethostbyaddr.c
1{{#include chapter_8/gethostbyaddr.c}} gethostbyname.c
1{{#include chapter_8/gethostbyname.c}} `,url:"https://hugo-dead-simple.netlify.com/linux_tcp_program/tcpip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/chapter_8/"},"https://hugo-dead-simple.netlify.com/linux_tcp_program/tcpip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/chapter_9/":{title:"",tags:[],content:`第 9 章 套接字的多种可选项 本章代码，在TCP-IP-NetworkNote中可以找到。
9.1 套接字可选项和 I/O 缓冲大小 我们进行套接字编程时往往只关注数据通信，而忽略了套接字具有的不同特性。但是，理解这些特性并根据实际需要进行更改也很重要
9.1.1 套接字多种可选项 我们之前写得程序都是创建好套接字之后直接使用的，此时通过默认的套接字特性进行数据通信，这里列出了一些套接字可选项。
协议层 选项名 读取 设置 SOL_SOCKET SO_SNDBUF O O SOL_SOCKET SO_RCVBUF O O SOL_SOCKET SO_REUSEADDR O O SOL_SOCKET SO_KEEPALIVE O O SOL_SOCKET SO_BROADCAST O O SOL_SOCKET SO_DONTROUTE O O SOL_SOCKET SO_OOBINLINE O O SOL_SOCKET SO_ERROR O X SOL_SOCKET SO_TYPE O X IPPROTO_IP IP_TOS O O IPPROTO_IP IP_TTL O O IPPROTO_IP IP_MULTICAST_TTL O O IPPROTO_IP IP_MULTICAST_LOOP O O IPPROTO_IP IP_MULTICAST_IF O O IPPROTO_TCP TCP_KEEPALIVE O O IPPROTO_TCP TCP_NODELAY O O IPPROTO_TCP TCP_MAXSEG O O 从表中可以看出，套接字可选项是分层的。
IPPROTO_IP 可选项是IP协议相关事项
IPPROTO_TCP 层可选项是 TCP 协议的相关事项
SOL_SOCKET 层是套接字的通用可选项。
9.1.2 getsockopt &amp; setsockopt 可选项的读取和设置通过以下两个函数来完成
1#include &lt;sys/socket.h&gt; 2 3int getsockopt(int sock, int level, int optname, void *optval, socklen_t *optlen); 4/* 5成功时返回 0 ，失败时返回 -1 6sock: 用于查看选项套接字文件描述符 7level: 要查看的可选项协议层 8optname: 要查看的可选项名 9optval: 保存查看结果的缓冲地址值 10optlen: 向第四个参数传递的缓冲大小。调用函数候，该变量中保存通过第四个参数返回的可选项信息的字节数。 11*/ 上述函数可以用来读取套接字可选项，下面的函数可以更改可选项：d
1#include &lt;sys/socket.h&gt; 2 3int setsockopt(int sock, int level, int optname, const void *optval, socklen_t optlen); 4/* 5成功时返回 0 ，失败时返回 -1 6sock: 用于更改选项套接字文件描述符 7level: 要更改的可选项协议层 8optname: 要更改的可选项名 9optval: 保存更改结果的缓冲地址值 10optlen: 向第四个参数传递的缓冲大小。调用函数后，该变量中保存通过第四个参数返回的可选项信息的字节数。 11*/ 下面的代码可以看出 getsockopt 的使用方法。下面示例用协议层为 SOL_SOCKET 、名为 SO_TYPE 的可选项查看套接字类型（TCP 和 UDP ）。
sock_type.c 编译运行：
1gcc sock_type.c -o sock_type 2./sock_type 结果：
1SOCK_STREAM: 1 2SOCK_DGRAM: 2 3Socket type one: 1 4Socket type two: 2 首先创建了一个 TCP 套接字和一个 UDP 套接字。然后通过调用 getsockopt 函数来获得当前套接字的状态。
用于验证套接类型的 SO_TYPE 是只读可选项，因为套接字类型只能在创建时决定，以后不能再更改。
9.1.3 SO_SNDBUF &amp; SO_RCVBUF 创建套接字的同时会生成 I/O 缓冲。关于 I/O 缓冲，可以去看第五章。
SO_RCVBUF 是输入缓冲大小相关可选项，SO_SNDBUF 是输出缓冲大小相关可选项。用这 2 个可选项既可以读取当前 I/O 大小，也可以进行更改。通过下列示例读取创建套接字时默认的 I/O 缓冲大小。
get_buf.c 编译运行：
1gcc get_buf.c -o getbuf 2./getbuf 运行结果：
1Input buffer size: 87380 2Output buffer size: 16384 可以看出本机的输入缓冲和输出缓冲大小。
下面的代码演示了，通过程序设置 I/O 缓冲区的大小
set_buf.c 编译运行：
1gcc get_buf.c -o setbuf 2./setbuf 结果:
1Input buffer size: 6144 2Output buffer size: 6144 输出结果和我们预想的不是很相同，缓冲大小的设置需谨慎处理，因此不会完全按照我们的要求进行。
9.2 SO_REUSEADDR 9.2.1 发生地址分配错误（Binding Error） 在学习 SO_REUSEADDR 可选项之前，应该好好理解 Time-wait 状态。看以下代码的示例：
reuseadr_eserver.c 这是一个回声服务器的服务端代码，可以配合第四章的 echo_client.c 使用，在这个代码中，客户端通知服务器终止程序。在客户端控制台输入 Q 可以结束程序，向服务器发送 FIN 消息并经过四次握手过程。当然，输入 CTRL+C 也会向服务器传递 FIN 信息。强制终止程序时，由操作系统关闭文件套接字，此过程相当于调用 close 函数，也会向服务器发送 FIN 消息。
这样看不到是什么特殊现象，考虑以下情况：
服务器端和客户端都已经建立连接的状态下，向服务器控制台输入 CTRL+C ，强制关闭服务端
如果用这种方式终止程序，如果用同一端口号再次运行服务端，就会输出「bind() error」消息，并且无法再次运行。但是在这种情况下，再过大约 3 分钟就可以重新运行服务端。
9.2.2 Time-wait 状态 观察以下过程：
假设图中主机 A 是服务器，因为是主机 A 向 B 发送 FIN 消息，故可想象成服务器端在控制台中输入 CTRL+C 。但是问题是，套接字经过四次握手后并没有立即消除，而是要经过一段时间的 Time-wait 状态。当然，只有先断开连接的（先发送 FIN 消息的）主机才经过 Time-wait 状态。因此，若服务器端先断开连接，则无法立即重新运行。套接字处在 Time-wait 过程时，相应端口是正在使用的状态。因此，就像之前验证过的，bind 函数调用过程中会发生错误。
实际上，不论是服务端还是客户端，都要经过一段时间的 Time-wait 过程。先断开连接的套接字必然会经过 Time-wait 过程，但是由于客户端套接字的端口是任意指定的，所以无需过多关注 Time-wait 状态。
那到底为什么会有 Time-wait 状态呢，在图中假设，主机 A 向主机 B 传输 ACK 消息（SEQ 5001 , ACK 7502 ）后立刻消除套接字。但是最后这条 ACK 消息在传递过程中丢失，没有传递主机 B ，这时主机 B 就会试图重传。但是此时主机 A 已经是完全终止状态，因此主机 B 永远无法收到从主机 A 最后传来的 ACK 消息。基于这些问题的考虑，所以要设计 Time-wait 状态。
9.2.3 地址再分配 Time-wait 状态看似重要，但是不一定讨人喜欢。如果系统发生故障紧急停止，这时需要尽快重启服务起以提供服务，但因处于 Time-wait 状态而必须等待几分钟。因此，Time-wait 并非只有优点，这些情况下容易引发大问题。下图中展示了四次握手时不得不延长 Time-wait 过程的情况。
从图上可以看出，在主机 A 四次握手的过程中，如果最后的数据丢失，则主机 B 会认为主机 A 未能收到自己发送的 FIN 信息，因此重传。这时，收到的 FIN 消息的主机 A 将重启 Time-wait 计时器。因此，如果网络状况不理想， Time-wait 将持续。
解决方案就是在套接字的可选项中更改 SO_REUSEADDR 的状态。适当调整该参数，可将 Time-wait 状态下的套接字端口号重新分配给新的套接字。SO_REUSEADDR 的默认值为 0.这就意味着无法分配 Time-wait 状态下的套接字端口号。因此需要将这个值改成 1 。具体作法已在示例 reuseadr_eserver.c 给出，只需要把注释掉的东西解除注释即可。
1optlen = sizeof(option); 2option = TRUE; 3setsockopt(serv_sock, SOL_SOCKET, SO_REUSEADDR, (void *)&amp;option, optlen); 此时，已经解决了上述问题。
9.3 TCP_NODELAY 9.3.1 Nagle 算法 为了防止因数据包过多而发生网络过载，Nagle 算法诞生了。它应用于 TCP 层。它是否使用会导致如图所示的差异：
图中展示了通过 Nagle 算法发送字符串 Nagle 和未使用 Nagle 算法的差别。可以得到一个结论。
只有接收到前一数据的 ACK 消息， Nagle 算法才发送下一数据。
TCP 套接字默认使用 Nagle 算法交换数据，因此最大限度的进行缓冲，直到收到 ACK 。左图也就是说一共传递 4 个数据包以传输一个字符串。从右图可以看出，发送数据包一共使用了 10 个数据包。由此可知，不使用 Nagle 算法将对网络流量产生负面影响。即使只传输一个字节的数据，其头信息都可能是几十个字节。因此，为了提高网络传输效率，必须使用 Nagle 算法。
Nagle 算法并不是什么情况下都适用，网络流量未受太大影响时，不使用 Nagle 算法要比使用它时传输速度快。最典型的就是「传输大文数据」。将文件数据传入输出缓冲不会花太多时间，因此，不使用 Nagle 算法，也会在装满输出缓冲时传输数据包。这不仅不会增加数据包的数量，反而在无需等待 ACK 的前提下连续传输，因此可以大大提高传输速度。
所以，未准确判断数据性质时不应禁用 Nagle 算法。
9.3.2 禁用 Nagle 算法 禁用 Nagle 算法应该使用：
1int opt_val = 1; 2setsockopt(sock, IPPROTO_TCP, TCP_NODELAY, (void *)&amp;opt_val, sizeof(opt_val)); 通过 TCP_NODELAY 的值来查看Nagle 算法的设置状态。
1opt_len = sizeof(opt_val); 2getsockopt(sock, IPPROTO_TCP, TCP_NODELAY, (void *)&amp;opt_val, &amp;opt_len); 如果正在使用Nagle 算法，那么 opt_val 值为 0，如果禁用则为 1.
关于这个算法，可以参考这个回答：TCP连接中启用和禁用TCP_NODELAY有什么影响？
9.4 基于 Windows 的实现 暂略
9.5 习题 以下答案仅代表本人个人观点，可能不是正确答案。
下列关于 Time-wait 状态的说法错误的是？
答：以下字体加粗的代表正确。
Time-wait 状态只在服务器的套接字中发生 断开连接的四次握手过程中，先传输 FIN 消息的套接字将进入 Time-wait 状态。 Time-wait 状态与断开连接的过程无关，而与请求连接过程中 SYN 消息的传输顺序有关 Time-wait 状态通常并非必要，应尽可能通过更改套接字可选项来防止其发生 TCP_NODELAY 可选项与 Nagle 算法有关，可通过它禁用 Nagle 算法。请问何时应考虑禁用 Nagle 算法？结合收发数据的特性给出说明。
答：当网络流量未受太大影响时，不使用 Nagle 算法要比使用它时传输速度快，比如说在传输大文件时。
代码 get_buf.c
1{{#include chapter_9/get_buf.c}} set_buf
1{{#include chapter_9/set_buf.c}} reuseadr_eserver
1{{#include chapter_9/reuseadr_eserver.c}} sock_type
1{{#include chapter_9/sock_type.c}} `,url:"https://hugo-dead-simple.netlify.com/linux_tcp_program/tcpip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/chapter_9/"},"https://hugo-dead-simple.netlify.com/linux_tcp_program/tcpip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/readme/":{title:"",tags:[],content:`说明 作者: 韩国 - 尹圣雨
学习资源 riba2534TCP-IP-NetworkNote 📘《TCPIP网络编程》(韩-尹圣雨)学习笔记 `,url:"https://hugo-dead-simple.netlify.com/linux_tcp_program/tcpip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/readme/"},"https://hugo-dead-simple.netlify.com/mongodb/readme/":{title:"",tags:[],content:"",url:"https://hugo-dead-simple.netlify.com/mongodb/readme/"},"https://hugo-dead-simple.netlify.com/categories/":{title:"Categories",tags:[],content:"",url:"https://hugo-dead-simple.netlify.com/categories/"},"https://hugo-dead-simple.netlify.com/mongodb/":{title:"MongoDB 学习笔记",tags:[],content:`这里是我学习 MongoDB 过程中记录的所有笔记和练习。
MongoDB - Lookup 操作详解 MongoDB 练习 1 MongoDB 练习 2 MongoDB 练习 3 MongoDB 练习 4 MongoDB - 在数组上查询 `,url:"https://hugo-dead-simple.netlify.com/mongodb/"},"https://hugo-dead-simple.netlify.com/search/":{title:"Search Results",tags:[],content:"",url:"https://hugo-dead-simple.netlify.com/search/"},"https://hugo-dead-simple.netlify.com/books/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B%E8%BF%9B%E9%98%B6%E6%8C%87%E5%8D%97/":{title:"算法竞赛进阶指南 学习笔记",tags:[],content:" 0x00 基本算法 ",url:"https://hugo-dead-simple.netlify.com/books/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B%E8%BF%9B%E9%98%B6%E6%8C%87%E5%8D%97/"},"https://hugo-dead-simple.netlify.com/":{title:"首页",tags:[],content:" 这里是rainboy写的文章, 托管在 GitHub 仓库 ",url:"https://hugo-dead-simple.netlify.com/"}}</script><script defer src=/js/lunr.js></script><script defer src=/js/search.js></script><br><footer><div class=footer-info><p>Copyright &copy; 2025 Rainboy. All rights reserved.
<span>| Last build: 2025-09-09 13:04:40</span></p></div><script defer>document.addEventListener("keydown",function(e){if(document.activeElement.isContentEditable)return!1;if(document.activeElement.tagName=="INPUT")return!1;if(e.altKey||e.ctrlKey||e.shiftKey)return!1;var t=e.key;if(t==="h")e.preventDefault(),e.stopPropagation(),window.location.href="/";else if(t==="t")e.preventDefault(),e.stopPropagation(),window.location.href=`https://${location.hostname}/tags`;else if(t==="i"){e.preventDefault(),e.stopPropagation();const t=document.querySelectorAll("input");for(let e=0;e<t.length;e++)if(t[e].offsetParent!==null){t[e].selectionStart=t[e].selectionEnd=t[e].value.length,t[e].focus();break}}return!1})</script><script defer>function throttle(e,t){var n=Date.now();return function(){var s=Date.now();n+t-s<0&&(e(),n=s)}}function scrollHandler(){const e=Array.from(document.querySelectorAll("body h2, body h3"));function t(){for(var n,s,o,i=window.pageYOffset||document.documentElement.scrollTop,t=0;t<e.length;t++)s=e[t].getAttribute("id"),n=document.querySelector('nav ul li a[href="#'+s+'"]'),n&&n.classList.remove("active-toc");for(t=e.length-1;t>=0;t--)if(o=e[t].offsetTop,i>o-75&&(s=e[t].getAttribute("id"),n=document.querySelector('nav ul li a[href="#'+s+'"]'),n)){n.classList.add("active-toc");break}}window.addEventListener("scroll",throttle(t,200))}setTimeout(scrollHandler,100)</script><script defer>function addCopyButtonToCodeBlocks(){const e=document.querySelectorAll('code[class^="language-"]:not(.output):not([class*="language-console"])');e.forEach(e=>{const t=document.createElement("button");t.classList.add("copy-code-button"),t.innerHTML="copy",t.addEventListener("click",()=>{const s=e.querySelectorAll(".cl");let n="";s.forEach(e=>{n+=e.innerText}),navigator.clipboard.writeText(n),t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},1500)}),e.parentNode.before(t)})}setTimeout(function(){addCopyButtonToCodeBlocks()},100)</script><script defer src=/js/theme-switcher.js></script></footer></body></html>