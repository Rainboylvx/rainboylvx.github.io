<!doctype html><html lang=zh-cn><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta http-equiv=cache-control content="max-age=0"><meta http-equiv=cache-control content="no-cache"><meta http-equiv=expires content="0"><meta http-equiv=expires content="Tue, 01 Jan 1980 1:00:00 GMT"><meta http-equiv=pragma content="no-cache"><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png }><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=manifest href=/site.webmanifest><meta name=theme-color media="(prefers-color-scheme: light)" content="#ffffff"><meta name=theme-color media="(prefers-color-scheme: dark)" content="#1b1b1b"><meta name=description content><script>(function(){const e=localStorage.getItem("theme")||(window.matchMedia("(prefers-color-scheme: dark)").matches?"dark":"light");document.documentElement.setAttribute("data-theme",e)})()</script><title>| Rainboy's Blog</title><style>:root{--background:#ffffff}@media(prefers-color-scheme:dark){:root{--background:#1b1b1b}}html{background-color:var(--background)}body{background-color:var(--background)}</style><link rel=stylesheet type=text/css href=/style.min.4de9e3236bcb55312d0b2ff0fc62c694f607b9c0d95d0621f6c6dbacb7d6dbb5.css media=all><link rel=stylesheet href=/grid.css><link href="https://fonts.font.im/css?family=Roboto+Mono" rel=stylesheet><style>body,.heti,.heti--sans{font-family:roboto mono,monospace,times new roman,times,heti song,serif,apple color emoji,segoe ui emoji,segoe ui symbol}</style></head><body><nav><ul class=menu><li><a tabindex=-1 class=menu-link href=/><u>H</u>ome</a></li><li><a tabindex=-1 class=menu-link href=/tags><u>T</u>ags</a></li><li><span style=cursor:pointer id=theme-switcher class=menu-link type=button><svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-moon h-4 w-4"><path d="M12 3a6 6 0 009 9 9 9 0 11-9-9z"/></svg></span></li></ul></nav><div id=single-header><h1></h1><div id=single-meta></div></div><main class="heti heti--classic"><p><code>ret</code> 与 <code>ret 10</code>之间的区别</p><p>当然可以。<code>ret</code> 和 <code>ret 10</code> 都是函数返回指令，但它们之间有一个非常重要且根本的区别。</p><p>最核心的区别在于<strong>由谁来负责清理函数调用时压入栈的参数</strong>。</p><hr><h3 id=ret-常规返回><code>ret</code> (常规返回)</h3><p><strong>动作：</strong></p><ol><li>从栈顶弹出一个地址，放入指令指针寄存器 (<code>EIP</code> 或 <code>RIP</code>) 中。</li><li>CPU 跳转到该地址继续执行。</li></ol><p><strong>参数清理：</strong>
<code>ret</code> 指令本身<strong>不负责</strong>清理调用者压入栈的参数。它假定**调用者（Caller）**会在函数返回后自己清理栈。</p><p><strong>对应的调用约定：</strong>
这种方式通常与 <code>__cdecl</code> 调用约定相关，这是 C 和 C++ 语言默认的调用约定。</p><p><strong>示例：</strong></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=ln> 1</span><span class=cl>; ----- 调用者的代码 (Caller) -----
</span></span><span class=line><span class=ln> 2</span><span class=cl>push arg2        ; 压入第2个参数 (4字节)
</span></span><span class=line><span class=ln> 3</span><span class=cl>push arg1        ; 压入第1个参数 (4字节)
</span></span><span class=line><span class=ln> 4</span><span class=cl>call MyFunction  ; 调用函数
</span></span><span class=line><span class=ln> 5</span><span class=cl>add esp, 8       ; &lt;--- 由调用者负责清理 2 * 4 = 8 字节的参数
</span></span><span class=line><span class=ln> 6</span><span class=cl>
</span></span><span class=line><span class=ln> 7</span><span class=cl>; ----- 被调用函数 MyFunction 的代码 (Callee) -----
</span></span><span class=line><span class=ln> 8</span><span class=cl>MyFunction:
</span></span><span class=line><span class=ln> 9</span><span class=cl>    ; ... 函数体 ...
</span></span><span class=line><span class=ln>10</span><span class=cl>    ret          ; &lt;--- 简单返回，不关心参数
</span></span></code></pre></div><p><strong>优点：</strong>
因为它不关心参数数量，所以支持<strong>可变参数函数</strong>，比如 <code>printf(format, ...)</code>。被调用的 <code>printf</code> 函数不知道有多少个参数，所以它无法清理，必须由调用者来完成。</p><hr><h3 id=ret-10-带参数清理的返回><code>ret 10</code> (带参数清理的返回)</h3><p><strong><code>10</code> 的含义：</strong>
这里的 <code>10</code> 是十六进制的 <code>10h</code>，代表十进制的 <strong>16</strong>。它指示了要清理的字节数。</p><p><strong>动作：</strong></p><ol><li>从栈顶弹出一个地址，放入指令指针寄存器 (<code>EIP</code> 或 <code>RIP</code>) 中。</li><li>CPU 跳转到该地址继续执行。</li><li><strong>在跳转后，CPU 会自动将栈顶指针 <code>ESP</code> 的值增加 16 字节</strong>（相当于执行了 <code>add esp, 16</code>）。</li></ol><p><strong>参数清理：</strong>
<code>ret 10</code> 指令在返回的同时，也清理了栈上的参数。它假定<strong>被调用者（Callee）</strong>，也就是这个函数自己，负责清理栈。16 字节通常意味着 <strong>4 个参数</strong>（每个参数4字节）。</p><p><strong>对应的调用约定：</strong>
这种方式通常与 <code>__stdcall</code> 调用约定相关，Windows API 函数广泛使用此约定。</p><p><strong>示例：</strong></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=ln> 1</span><span class=cl>; ----- 调用者的代码 (Caller) -----
</span></span><span class=line><span class=ln> 2</span><span class=cl>push arg4        ; 压入第4个参数
</span></span><span class=line><span class=ln> 3</span><span class=cl>push arg3        ; 压入第3个参数
</span></span><span class=line><span class=ln> 4</span><span class=cl>push arg2        ; 压入第2个参数
</span></span><span class=line><span class=ln> 5</span><span class=cl>push arg1        ; 压入第1个参数
</span></span><span class=line><span class=ln> 6</span><span class=cl>call MyFunction  ; 调用函数
</span></span><span class=line><span class=ln> 7</span><span class=cl>                 ; &lt;--- 调用者在这里什么都不用做！
</span></span><span class=line><span class=ln> 8</span><span class=cl>
</span></span><span class=line><span class=ln> 9</span><span class=cl>; ----- 被调用函数 MyFunction 的代码 (Callee) -----
</span></span><span class=line><span class=ln>10</span><span class=cl>MyFunction:
</span></span><span class=line><span class=ln>11</span><span class=cl>    ; ... 函数体 ...
</span></span><span class=line><span class=ln>12</span><span class=cl>    ret 10       ; &lt;--- 返回，并清理 4 * 4 = 16 字节的参数
</span></span></code></pre></div><p><strong>优点：</strong>
代码可以更紧凑一些，因为清理栈的指令 (<code>add esp, ...</code>) 只需要在函数内部出现一次，而不是在每个调用它的地方都出现一次。</p><hr><h3 id=总结对比>总结对比</h3><table><thead><tr><th style=text-align:left>特性</th><th style=text-align:left><code>ret</code></th><th style=text-align:left><code>ret 10</code></th></tr></thead><tbody><tr><td style=text-align:left><strong>参数清理者</strong></td><td style=text-align:left><strong>调用者 (Caller)</strong></td><td style=text-align:left><strong>被调用者 (Callee)</strong></td></tr><tr><td style=text-align:left><strong>指令动作</strong></td><td style=text-align:left>弹出返回地址并跳转</td><td style=text-align:left>弹出返回地址、跳转，并给 <code>ESP</code> 加上一个立即数</td></tr><tr><td style=text-align:left><strong>常见调用约定</strong></td><td style=text-align:left><code>__cdecl</code></td><td style=text-align:left><code>__stdcall</code></td></tr><tr><td style=text-align:left><strong>是否支持可变参数</strong></td><td style=text-align:left>是</td><td style=text-align:left>否（因为清理的字节数是固定的）</td></tr><tr><td style=text-align:left><strong>常见用途</strong></td><td style=text-align:left>C/C++ 默认函数</td><td style=text-align:left>Windows API 函数</td></tr></tbody></table><p><strong>为什么这个区别很重要？</strong>
如果一个函数是按 <code>__stdcall</code> 编译的（使用 <code>ret 10</code>），而调用者却按 <code>__cdecl</code> 的方式去调用它（在 <code>call</code> 之后尝试自己清理参数），就会导致栈被清理两次，从而破坏栈的平衡，引发程序崩溃。因此，在进行混合语言编程或调用外部库时，正确匹配调用约定至关重要。</p></main><br><footer><div class=footer-info><p>Copyright &copy; 2025 Rainboy. All rights reserved.
<span>| Last build: 2025-10-26 19:41:26</span></p></div><script defer>document.addEventListener("keydown",function(e){if(document.activeElement.isContentEditable)return!1;if(document.activeElement.tagName=="INPUT")return!1;if(e.altKey||e.ctrlKey||e.shiftKey)return!1;var t=e.key;if(t==="h")e.preventDefault(),e.stopPropagation(),window.location.href="/";else if(t==="t")e.preventDefault(),e.stopPropagation(),window.location.href=`https://${location.hostname}/tags`;else if(t==="i"){e.preventDefault(),e.stopPropagation();const t=document.querySelectorAll("input");for(let e=0;e<t.length;e++)if(t[e].offsetParent!==null){t[e].selectionStart=t[e].selectionEnd=t[e].value.length,t[e].focus();break}}return!1})</script><script defer>function throttle(e,t){var n=Date.now();return function(){var s=Date.now();n+t-s<0&&(e(),n=s)}}function scrollHandler(){const e=Array.from(document.querySelectorAll("body h2, body h3"));function t(){for(var n,s,o,i=window.pageYOffset||document.documentElement.scrollTop,t=0;t<e.length;t++)s=e[t].getAttribute("id"),n=document.querySelector('nav ul li a[href="#'+s+'"]'),n&&n.classList.remove("active-toc");for(t=e.length-1;t>=0;t--)if(o=e[t].offsetTop,i>o-75&&(s=e[t].getAttribute("id"),n=document.querySelector('nav ul li a[href="#'+s+'"]'),n)){n.classList.add("active-toc");break}}window.addEventListener("scroll",throttle(t,200))}setTimeout(scrollHandler,100)</script><script defer>function addCopyButtonToCodeBlocks(){const e=document.querySelectorAll('code[class^="language-"]:not(.output):not([class*="language-console"])');e.forEach(e=>{const t=document.createElement("button");t.classList.add("copy-code-button"),t.innerHTML="copy",t.addEventListener("click",()=>{const s=e.querySelectorAll(".cl");let n="";s.forEach(e=>{n+=e.innerText}),navigator.clipboard.writeText(n),t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},1500)}),e.parentNode.before(t)})}setTimeout(function(){addCopyButtonToCodeBlocks()},100)</script><script defer src=/js/theme-switcher.js></script></footer></body></html>