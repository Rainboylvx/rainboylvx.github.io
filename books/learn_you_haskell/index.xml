<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>learn you haskell for great good on Rainboy's Blog</title><link>https://hugo-dead-simple.netlify.com/books/learn_you_haskell/index.html</link><description>Recent content in learn you haskell for great good on Rainboy's Blog</description><generator>Hugo</generator><language>zh-cn</language><lastBuildDate>Sun, 02 Nov 2025 10:12:14 +0000</lastBuildDate><atom:link href="https://hugo-dead-simple.netlify.com/books/learn_you_haskell/index.xml" rel="self" type="application/rss+xml"/><item><title>chapter_3</title><link>https://hugo-dead-simple.netlify.com/books/learn_you_haskell/chapter_3.html</link><pubDate>Sun, 02 Nov 2025 00:00:00 +0000</pubDate><guid>https://hugo-dead-simple.netlify.com/books/learn_you_haskell/chapter_3.html</guid><description>&lt;h2 id="haskell类型与类型类-读书笔记核心内容"&gt;Haskell：类型与类型类 读书笔记核心内容&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;一、 核心概念：静态类型与类型推断&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;静态类型系统 (Static Type System)&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Haskell 是静态类型的。这意味着&lt;strong&gt;每个表达式的类型在编译时&lt;/strong&gt;就已经确定了。&lt;/li&gt;
&lt;li&gt;这样做的好处是极大地提高了代码的安全性。例如，你不能将一个布尔值和数字相除，这样的错误在编译阶段就会被发现，而不是在程序运行时崩溃。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;类型推断 (Type Inference)&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;与 Java 或 Pascal 不同，Haskell 具有强大的类型推断能力。&lt;/li&gt;
&lt;li&gt;你&lt;strong&gt;不必&lt;/strong&gt;为每个函数或表达式显式地写出类型。Haskell 编译器通常能自动推断出它们的类型。&lt;/li&gt;
&lt;li&gt;尽管如此，为顶层函数（toplevel functions）编写明确的类型签名（Type Declaration）被认为是最佳实践。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;二、 类型 (Types)&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;什么是类型？&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;类型是给表达式贴上的“标签”，用于说明该表达式属于哪个“类别”。例如：
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;True&lt;/code&gt; 是 &lt;code&gt;Bool&lt;/code&gt; 类型。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;quot;hello&amp;quot;&lt;/code&gt; 是 &lt;code&gt;[Char]&lt;/code&gt; 类型（即 &lt;code&gt;String&lt;/code&gt;）。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;'a'&lt;/code&gt; 是 &lt;code&gt;Char&lt;/code&gt; 类型。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;(True, 'a')&lt;/code&gt; 是 &lt;code&gt;(Bool, Char)&lt;/code&gt; 类型。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;在 GHCI 中检查类型&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;使用 &lt;code&gt;:t&lt;/code&gt; 命令可以查看任何表达式的类型。&lt;/li&gt;
&lt;li&gt;例如：&lt;code&gt;:t 'a'&lt;/code&gt; 会返回 &lt;code&gt;'a' :: Char&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;::&lt;/code&gt; 读作“具有类型”。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;常见的内置类型&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;Int&lt;/code&gt;&lt;/strong&gt;：有界的整数（通常为 32 或 64 位）。它更高效。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;Integer&lt;/code&gt;&lt;/strong&gt;：无界的整数。可以用来表示任意大的数字，但效率低于 &lt;code&gt;Int&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;Float&lt;/code&gt;&lt;/strong&gt;：单精度浮点数。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;Double&lt;/code&gt;&lt;/strong&gt;：双精度浮点数。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;Bool&lt;/code&gt;&lt;/strong&gt;：布尔值，只有 &lt;code&gt;True&lt;/code&gt; 和 &lt;code&gt;False&lt;/code&gt; 两个值。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;Char&lt;/code&gt;&lt;/strong&gt;：单个字符。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;String&lt;/code&gt;&lt;/strong&gt;：字符串，它实际上是 &lt;code&gt;[Char]&lt;/code&gt;（字符列表）的类型别名。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;三、 函数的类型&lt;/strong&gt;&lt;/p&gt;</description></item><item><title>鹏翔万里haskell读书笔记</title><link>https://hugo-dead-simple.netlify.com/books/learn_you_haskell/%E9%B9%8F%E7%BF%94%E4%B8%87%E9%87%8Chaskell%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.html</link><pubDate>Sun, 02 Nov 2025 00:00:00 +0000</pubDate><guid>https://hugo-dead-simple.netlify.com/books/learn_you_haskell/%E9%B9%8F%E7%BF%94%E4%B8%87%E9%87%8Chaskell%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.html</guid><description>&lt;p&gt;来自: &lt;a href="https://github.com/TonyCrane/note/blob/726089f71103941b9371c997aecba5ea49bcf436/docs/cs/pl/haskell.md" target="_blank" rel="noopener"&gt;https://github.com/TonyCrane/note/blob/726089f71103941b9371c997aecba5ea49bcf436/docs/cs/pl/haskell.md&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Haskell 是一种标准化的，通用的纯函数式编程语言，有惰性求值和强静态类型。它的命名源自美国逻辑学家哈斯凯尔·加里，他在数理逻辑方面上的工作使得函数式编程语言有了广泛的基础。在 Haskell 中，“函数是第一类对象”。作为一门函数编程语言，主要控制结构是函数。Haskell 语言是1990年在编程语言 Miranda 的基础上标准化的，并且以λ演算为基础发展而来。这也是为什么 Haskell 语言以希腊字母 “λ”（Lambda）作为自己的标志。Haskell 具有“证明即程序、命题为类型”的特征。&lt;/p&gt;
&lt;div style="text-align: right"&gt;———— 维基百科&lt;/div&gt;
&lt;/blockquote&gt;
&lt;h2 id="1-基础运算"&gt;1 基础运算&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;+ - * / ()&lt;/code&gt;：加减乘除&lt;/li&gt;
&lt;li&gt;&lt;code&gt;div&lt;/code&gt;：整除&lt;/li&gt;
&lt;li&gt;&lt;code&gt;mod&lt;/code&gt;：取模&lt;/li&gt;
&lt;li&gt;&lt;code&gt;True False&lt;/code&gt;：布尔值&lt;/li&gt;
&lt;li&gt;&lt;code&gt;|| &amp;amp;&amp;amp; not&lt;/code&gt;：或且非&lt;/li&gt;
&lt;li&gt;&lt;code&gt;==&lt;/code&gt;：条件判断，相等&lt;/li&gt;
&lt;li&gt;&lt;code&gt;/=&lt;/code&gt;：条件判断，不等&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="11-函数调用"&gt;1.1 函数调用&lt;/h3&gt;
&lt;p&gt;Haskell 中调用函数不加括号，先写出函数名，然后逐个列出参数，用空格隔开：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-haskell" data-lang="haskell"&gt;&lt;span class="line"&gt;&lt;span class="ln"&gt;1&lt;/span&gt;&lt;span class="cl"&gt;&lt;span class="nf"&gt;ghci&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;max&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="ln"&gt;2&lt;/span&gt;&lt;span class="cl"&gt;&lt;span class="mi"&gt;2&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;前缀（prefix）函数与中缀（infix）函数转换：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;对前缀函数加&lt;code&gt;``&lt;/code&gt;使其变成中缀函数&lt;/li&gt;
&lt;li&gt;对中缀函数加&lt;code&gt;()&lt;/code&gt;使其变成前缀函数&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-haskell" data-lang="haskell"&gt;&lt;span class="line"&gt;&lt;span class="ln"&gt;1&lt;/span&gt;&lt;span class="cl"&gt;&lt;span class="nf"&gt;ghci&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="mi"&gt;4&lt;/span&gt; &lt;span class="p"&gt;`&lt;/span&gt;&lt;span class="n"&gt;div&lt;/span&gt;&lt;span class="p"&gt;`&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="ln"&gt;2&lt;/span&gt;&lt;span class="cl"&gt;&lt;span class="mi"&gt;2&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="ln"&gt;3&lt;/span&gt;&lt;span class="cl"&gt;&lt;span class="nf"&gt;ghci&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="p"&gt;`&lt;/span&gt;&lt;span class="n"&gt;max&lt;/span&gt;&lt;span class="p"&gt;`&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="ln"&gt;4&lt;/span&gt;&lt;span class="cl"&gt;&lt;span class="mi"&gt;2&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="ln"&gt;5&lt;/span&gt;&lt;span class="cl"&gt;&lt;span class="nf"&gt;ghci&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="ln"&gt;6&lt;/span&gt;&lt;span class="cl"&gt;&lt;span class="mi"&gt;3&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="ln"&gt;7&lt;/span&gt;&lt;span class="cl"&gt;&lt;span class="nf"&gt;ghci&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;||&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="kt"&gt;True&lt;/span&gt; &lt;span class="kt"&gt;False&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="ln"&gt;8&lt;/span&gt;&lt;span class="cl"&gt;&lt;span class="kt"&gt;True&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;hr&gt;
&lt;h2 id="2-list"&gt;2 List&lt;/h2&gt;
&lt;p&gt;列表是 Haskell 中很常见的数据类型，和 Python 中不同，Haskell 中的列表中的所有元素必须是同一个类型。&lt;/p&gt;
&lt;p&gt;以下是列表常用的函数：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;(++)&lt;/code&gt; :: [a] -&amp;gt; [a] -&amp;gt; [a]：合并两个列表&lt;/li&gt;
&lt;li&gt;&lt;code&gt;(:)&lt;/code&gt; :: a -&amp;gt; [a] -&amp;gt; [a]：将单个元素并入列表。[1, 2, 3] 是 1:2:3:[] 的语法糖&lt;/li&gt;
&lt;li&gt;&lt;code&gt;(!!)&lt;/code&gt; :: [a] -&amp;gt; Int -&amp;gt; a：通过索引取出某个位置上的元素。a !! 1 相当于 Python 中的 a[1]&lt;/li&gt;
&lt;li&gt;&lt;code&gt;head&lt;/code&gt; :: [a] -&amp;gt; a：返回列表的第一个元素&lt;/li&gt;
&lt;li&gt;&lt;code&gt;tail&lt;/code&gt; :: [a] -&amp;gt; [a]：返回列表中除去第一个元素后的列表（若只有一个元素则返回空列表[]）&lt;/li&gt;
&lt;li&gt;&lt;code&gt;last&lt;/code&gt; :: [a] -&amp;gt; a：返回列表中的最后一个元素&lt;/li&gt;
&lt;li&gt;&lt;code&gt;init&lt;/code&gt; :: [a] -&amp;gt; [a]：返回列表中除去最后一个元素后的列表&lt;/li&gt;
&lt;li&gt;&lt;code&gt;length&lt;/code&gt; :: Foldable t =&amp;gt; t a -&amp;gt; Int：返回列表的长度&lt;/li&gt;
&lt;li&gt;&lt;code&gt;null&lt;/code&gt; :: Foldable t =&amp;gt; t a -&amp;gt; Bool：返回列表是否为空&lt;/li&gt;
&lt;li&gt;&lt;code&gt;reverse&lt;/code&gt; :: [a] -&amp;gt; [a]：返回翻转后的列表&lt;/li&gt;
&lt;li&gt;&lt;code&gt;take&lt;/code&gt; :: Int -&amp;gt; [a] -&amp;gt; [a]：返回列表a的前n个元素的列表(take n a)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;drop&lt;/code&gt; :: Int -&amp;gt; [a] -&amp;gt; [a]：返回列表a中除去前n个元素后的列表(drop n a)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;maximum&lt;/code&gt; :: (Foldable t, Ord a) =&amp;gt; t a -&amp;gt; a：返回列表中的最大值&lt;/li&gt;
&lt;li&gt;&lt;code&gt;minimum&lt;/code&gt; :: (Foldable t, Ord a) =&amp;gt; t a -&amp;gt; a：返回列表中的最小值&lt;/li&gt;
&lt;li&gt;&lt;code&gt;sum&lt;/code&gt; :: (Foldable t, Num a) =&amp;gt; t a -&amp;gt; a：返回列表中所有元素的和&lt;/li&gt;
&lt;li&gt;&lt;code&gt;product&lt;/code&gt; :: (Foldable t, Num a) =&amp;gt; t a -&amp;gt; a：返回列表中所有元素的积&lt;/li&gt;
&lt;li&gt;&lt;code&gt;elem&lt;/code&gt; :: (Foldable t, Eq a) =&amp;gt; t a -&amp;gt; Bool：判断值n是否在列表a中
&lt;div class="highlight"&gt;&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-haskell" data-lang="haskell"&gt;&lt;span class="line"&gt;&lt;span class="ln"&gt;1&lt;/span&gt;&lt;span class="cl"&gt;&lt;span class="nf"&gt;elem&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="ln"&gt;2&lt;/span&gt;&lt;span class="cl"&gt;&lt;span class="c1"&gt;-- 或&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="ln"&gt;3&lt;/span&gt;&lt;span class="cl"&gt;&lt;span class="nf"&gt;n&lt;/span&gt; &lt;span class="p"&gt;`&lt;/span&gt;&lt;span class="n"&gt;elem&lt;/span&gt;&lt;span class="p"&gt;`&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="c1"&gt;--用``包上可以变成中缀函数使用&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="21-texas-ranges"&gt;2.1 Texas ranges&lt;/h3&gt;
&lt;p&gt;使用&lt;code&gt;..&lt;/code&gt;可以表示出范围并自动推导：&lt;/p&gt;</description></item><item><title>chapter 1 Introduction</title><link>https://hugo-dead-simple.netlify.com/books/learn_you_haskell/chapter_1.html</link><pubDate>Tue, 09 Sep 2025 00:00:00 +0000</pubDate><guid>https://hugo-dead-simple.netlify.com/books/learn_you_haskell/chapter_1.html</guid><description>&lt;p&gt;这篇文章是《Learn You a Haskell for Great Good!》教程的引言，主要内容可以总结为以下几点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;教程目标&lt;/strong&gt;：本教程主要面向有命令式编程（如 C++, Java, Python）经验，但初次接触函数式编程的开发者。作者建议通过阅读多种资料来学习Haskell，因为它起初可能感觉很奇怪，但一旦“开窍”就会变得容易。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Haskell的核心特性&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;纯函数式 (Purely Functional)&lt;/strong&gt;：你不是告诉计算机“如何做”，而是定义“是什么”。变量一旦赋值就不可改变，函数没有副作用，这保证了同样的输入总能得到同样的输出。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;惰性求值 (Lazy)&lt;/strong&gt;：代码只在真正需要结果时才被执行，这使得程序更高效，并能轻松处理无限大的数据结构。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;静态类型 (Statically Typed)&lt;/strong&gt;：编译器在编译阶段就能捕捉大量类型错误。同时，其强大的类型推导系统意味着你无需为每个变量都显式声明类型。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;优雅简洁 (Elegant and Concise)&lt;/strong&gt;：代码通常比等效的命令式代码更短，更易于维护。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;如何开始学习&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;你需要一个文本编辑器和Haskell编译器（GHC）。&lt;/li&gt;
&lt;li&gt;推荐使用 &lt;code&gt;GHCup&lt;/code&gt; 这个工具来安装所需环境。&lt;/li&gt;
&lt;li&gt;学习时，可以使用 &lt;code&gt;ghci&lt;/code&gt; 这个交互式环境来加载 &lt;code&gt;.hs&lt;/code&gt; 文件并实时测试函数，这样边学边练效率更高。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;</description></item><item><title>chapter 2 Starting Out</title><link>https://hugo-dead-simple.netlify.com/books/learn_you_haskell/chapter_2.html</link><pubDate>Tue, 09 Sep 2025 00:00:00 +0000</pubDate><guid>https://hugo-dead-simple.netlify.com/books/learn_you_haskell/chapter_2.html</guid><description>&lt;h2 id="这是什么页面"&gt;这是什么页面？&lt;/h2&gt;
&lt;p&gt;这是Haskell编程教程的“Starting Out”章节，旨在介绍Haskell语言的基础知识，包括交互模式、基本操作、函数定义、列表和元组等核心概念。页面通过示例代码和解释帮助初学者快速上手。&lt;/p&gt;
&lt;h2 id="主要内容"&gt;主要内容&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;GHCI交互模式&lt;/strong&gt;：Haskell使用GHCI（Glasgow Haskell Compiler Interactive）进行交互式编程，允许用户直接输入表达式并查看结果，例如算术运算（如 &lt;code&gt;2 + 15&lt;/code&gt;）和布尔操作（如 &lt;code&gt;True &amp;amp;&amp;amp; False&lt;/code&gt;）。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;基本操作&lt;/strong&gt;：包括算术运算符（+、-、*、/）、布尔运算符（&amp;amp;&amp;amp;、||、not）和相等比较（==、/=）。Haskell是强类型语言，操作数类型必须匹配，否则会报错。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;函数定义与调用&lt;/strong&gt;：函数通过空格分隔参数调用（如 &lt;code&gt;succ 8&lt;/code&gt; 返回 9）。函数可以定义为前缀或中缀形式（使用反引号，如 &lt;code&gt;92 `div` 10&lt;/code&gt;）。示例包括自定义函数如 &lt;code&gt;doubleMe x = x + x&lt;/code&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;列表&lt;/strong&gt;：列表是同质数据结构，用方括号表示（如 &lt;code&gt;[1,2,3]&lt;/code&gt;）。支持操作如连接（++）、cons操作符（:）、索引（!!），以及常用函数（head、tail、length、reverse等）。列表推导允许过滤和转换元素（如 &lt;code&gt;[x*2 | x &amp;lt;- [1..10], x*2 &amp;gt;= 12]&lt;/code&gt;）。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;范围和无列表&lt;/strong&gt;：使用范围（如 &lt;code&gt;[1..20]&lt;/code&gt;）生成序列，支持步长（如 &lt;code&gt;[2,4..20]&lt;/code&gt;）。无限列表可通过函数如 &lt;code&gt;cycle&lt;/code&gt; 和 &lt;code&gt;repeat&lt;/code&gt; 创建，并结合 &lt;code&gt;take&lt;/code&gt; 截取。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;元组&lt;/strong&gt;：元组存储固定数量的异质元素，用括号表示（如 &lt;code&gt;(1,&amp;quot;a&amp;quot;)&lt;/code&gt;）。与列表不同，元组大小和类型固定。常用函数包括 &lt;code&gt;fst&lt;/code&gt; 和 &lt;code&gt;snd&lt;/code&gt; 用于 pairs，以及 &lt;code&gt;zip&lt;/code&gt; 用于合并列表成元组列表。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;实用示例&lt;/strong&gt;：页面包含多个代码示例，如计算直角三角形周长，演示如何结合列表推导和条件过滤解决问题。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="目的"&gt;目的&lt;/h2&gt;
&lt;p&gt;该页面为Haskell初学者提供实践基础，通过交互式示例和简单函数定义，培养函数式编程思维。重点在于理解类型系统、列表处理和函数组合，为后续学习铺垫。&lt;/p&gt;</description></item></channel></rss>