<!doctype html><html lang=zh-cn><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta http-equiv=cache-control content="max-age=0"><meta http-equiv=cache-control content="no-cache"><meta http-equiv=expires content="0"><meta http-equiv=expires content="Tue, 01 Jan 1980 1:00:00 GMT"><meta http-equiv=pragma content="no-cache"><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png }><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=manifest href=/site.webmanifest><meta name=theme-color media="(prefers-color-scheme: light)" content="#ffffff"><meta name=theme-color media="(prefers-color-scheme: dark)" content="#1b1b1b"><meta name=description content="类型与类型类"><script>(function(){const e=localStorage.getItem("theme")||(window.matchMedia("(prefers-color-scheme: dark)").matches?"dark":"light");document.documentElement.setAttribute("data-theme",e)})()</script><title>类型与类型类 | Rainboy's Blog</title><style>:root{--background:#ffffff}@media(prefers-color-scheme:dark){:root{--background:#1b1b1b}}html{background-color:var(--background)}body{background-color:var(--background)}</style><link rel=stylesheet type=text/css href=/style.min.4de9e3236bcb55312d0b2ff0fc62c694f607b9c0d95d0621f6c6dbacb7d6dbb5.css media=all><link rel=stylesheet href=/grid.css><link href="https://fonts.font.im/css?family=Roboto+Mono" rel=stylesheet><style>body,.heti,.heti--sans{font-family:roboto mono,monospace,times new roman,times,heti song,serif,apple color emoji,segoe ui emoji,segoe ui symbol}</style></head><body><nav><ul class=menu><li><a tabindex=-1 class=menu-link href=/><u>H</u>ome</a></li><li><a tabindex=-1 class=menu-link href=/tags><u>T</u>ags</a></li><li><span style=cursor:pointer id=theme-switcher class=menu-link type=button><svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-moon h-4 w-4"><path d="M12 3a6 6 0 009 9 9 9 0 11-9-9z"/></svg></span></li></ul></nav><div id=single-header><h1>类型与类型类</h1><div id=single-meta><span class=datesub>2025-09-11 00:00</span>
<span id=tags>&nbsp;&nbsp;
<span><a href=https://hugo-dead-simple.netlify.com/tags/index.html>#</a>
</span>&nbsp;</span></div></div><aside class="hidden lg:block toc" id=tableOfContentContainer><nav id=TableOfContents><ul><li><a href=#haskell类型与类型类-读书笔记核心内容>Haskell：类型与类型类 读书笔记核心内容</a></li></ul></nav></aside><main class="heti heti--classic"><h2 id=haskell类型与类型类-读书笔记核心内容>Haskell：类型与类型类 读书笔记核心内容</h2><p><strong>一、 核心概念：静态类型与类型推断</strong></p><ol><li><p><strong>静态类型系统 (Static Type System)</strong>：</p><ul><li>Haskell 是静态类型的。这意味着<strong>每个表达式的类型在编译时</strong>就已经确定了。</li><li>这样做的好处是极大地提高了代码的安全性。例如，你不能将一个布尔值和数字相除，这样的错误在编译阶段就会被发现，而不是在程序运行时崩溃。</li></ul></li><li><p><strong>类型推断 (Type Inference)</strong>：</p><ul><li>与 Java 或 Pascal 不同，Haskell 具有强大的类型推断能力。</li><li>你<strong>不必</strong>为每个函数或表达式显式地写出类型。Haskell 编译器通常能自动推断出它们的类型。</li><li>尽管如此，为顶层函数（toplevel functions）编写明确的类型签名（Type Declaration）被认为是最佳实践。</li></ul></li></ol><p><strong>二、 类型 (Types)</strong></p><ol><li><p><strong>什么是类型？</strong></p><ul><li>类型是给表达式贴上的“标签”，用于说明该表达式属于哪个“类别”。例如：<ul><li><code>True</code> 是 <code>Bool</code> 类型。</li><li><code>"hello"</code> 是 <code>[Char]</code> 类型（即 <code>String</code>）。</li><li><code>'a'</code> 是 <code>Char</code> 类型。</li><li><code>(True, 'a')</code> 是 <code>(Bool, Char)</code> 类型。</li></ul></li></ul></li><li><p><strong>在 GHCI 中检查类型</strong>：</p><ul><li>使用 <code>:t</code> 命令可以查看任何表达式的类型。</li><li>例如：<code>:t 'a'</code> 会返回 <code>'a' :: Char</code>。</li><li><code>::</code> 读作“具有类型”。</li></ul></li><li><p><strong>常见的内置类型</strong>：</p><ul><li><strong><code>Int</code></strong>：有界的整数（通常为 32 或 64 位）。它更高效。</li><li><strong><code>Integer</code></strong>：无界的整数。可以用来表示任意大的数字，但效率低于 <code>Int</code>。</li><li><strong><code>Float</code></strong>：单精度浮点数。</li><li><strong><code>Double</code></strong>：双精度浮点数。</li><li><strong><code>Bool</code></strong>：布尔值，只有 <code>True</code> 和 <code>False</code> 两个值。</li><li><strong><code>Char</code></strong>：单个字符。</li><li><strong><code>String</code></strong>：字符串，它实际上是 <code>[Char]</code>（字符列表）的类型别名。</li></ul></li></ol><p><strong>三、 函数的类型</strong></p><ol><li><strong>类型签名 (Type Signatures)</strong>：<ul><li>函数也有类型。我们使用 <code>::</code> 来声明它。</li><li>格式：<code>functionName :: argumentType1 -> argumentType2 -> returnType</code></li><li>例如：<code>addThree :: Int -> Int -> Int -> Int</code></li><li>这表示 <code>addThree</code> 函数接收三个 <code>Int</code> 类型的参数，并返回一个 <code>Int</code> 类型的值。<strong>最后一个类型总是返回类型</strong>。</li></ul></li></ol><p><strong>四、 类型变量 (Type Variables) 与多态</strong></p><ol><li><strong>多态函数 (Polymorphic Functions)</strong>：<ul><li>当一个函数的类型签名中包含<strong>小写字母开头的名称</strong>（如 <code>a</code>, <code>b</code>, <code>t</code>）时，这些就是“类型变量”。</li><li>类型变量意味着“<strong>可以是任何类型</strong>”。</li><li>例如，<code>head</code> 函数的类型是 <code>head :: [a] -> a</code>。</li><li>这表示 <code>head</code> 接受一个<strong>任何类型 <code>a</code> 的元素组成的列表</strong>（<code>[a]</code>），并返回一个<strong>该类型 <code>a</code> 的元素</strong>。它不关心列表里具体是 <code>Int</code> 还是 <code>String</code>。</li><li>这类似于其他语言中的“泛型”。</li></ul></li></ol><p><strong>五、 类型类 (Typeclasses)</strong></p><ol><li><p><strong>什么是类型类？</strong></p><ul><li>类型类不是面向对象语言中的“类”。它更像是<strong>定义行为的接口（Interface）</strong>。</li><li>如果一个类型是某个类型类的“实例”（instance），那么它必须实现了该类型类所描述的行为（即特定的函数）。</li></ul></li><li><p><strong>类约束 (Class Constraints)</strong>：</p><ul><li>在类型签名中，使用 <code>=></code> 来表示类型约束。</li><li>例如：<code>(==) :: (Eq a) => a -> a -> Bool</code></li><li>这读作：<code>==</code> 函数接受两个类型为 <code>a</code> 的值，并返回一个 <code>Bool</code>。<strong>前提条件是：类型 <code>a</code> 必须是 <code>Eq</code> 类型类的实例</strong>。</li></ul></li><li><p><strong>常见的类型类</strong>：</p><ul><li><strong><code>Eq</code></strong>：用于支持<strong>相等性比较</strong>的类型。它提供了 <code>==</code> 和 <code>/=</code> (不等于) 函数。</li><li><strong><code>Ord</code></strong>：用于支持<strong>排序</strong>的类型。它提供了 <code>&lt;</code>, <code>></code>, <code>&lt;=</code>, <code>>=</code> 等函数。一个类型必须首先是 <code>Eq</code> 的实例，才能成为 <code>Ord</code> 的实例。</li><li><strong><code>Show</code></strong>：用于可以<strong>转换成字符串</strong>的类型。它提供了 <code>show</code> 函数（例如 <code>show 3</code> 返回 <code>"3"</code>）。</li><li><strong><code>Read</code></strong>：<code>Show</code> 的反向操作。用于将<strong>字符串转换回特定类型</strong>。它提供了 <code>read</code> 函数。<ul><li>注意：使用 <code>read</code> 时，Haskell 常常无法推断你想要的目标类型，因此需要<strong>显式类型注解</strong>，例如：<code>read "5" :: Int</code>。</li></ul></li><li><strong><code>Enum</code></strong>：用于可以<strong>枚举</strong>的类型（即有顺序的）。这使得它们可以用于列表的范围表达式，如 <code>['a'..'e']</code> 或 <code>[1..5]</code>。</li><li><strong><code>Bounded</code></strong>：用于有<strong>明确上界和下界</strong>的类型。它提供了 <code>minBound</code> 和 <code>maxBound</code>。</li><li><strong><code>Num</code></strong>：用于“数字”的类型类。像 <code>20</code> 这样的字面量本身是多态的，其类型是 <code>(Num t) => t</code>。这意味着 <code>20</code> 既可以是 <code>Int</code>，也可以是 <code>Float</code> 或 <code>Double</code>，Haskell 会根据上下文来推断。</li><li><strong><code>Integral</code></strong>：<code>Num</code> 的子类，只包括整数（<code>Int</code>, <code>Integer</code>）。</li><li><strong><code>Floating</code></strong>：<code>Num</code> 的子类，只包括浮点数（<code>Float</code>, <code>Double</code>）。</li></ul></li><li><p><strong><code>fromIntegral</code> 函数</strong>：</p><ul><li>这是一个非常有用的函数，其类型为 <code>fromIntegral :: (Num b, Integral a) => a -> b</code>。</li><li>它用于将一个<strong>整数类型</strong>（如 <code>Int</code>）转换成一个<strong>更通用的数字类型</strong>（如 <code>Float</code> 或 <code>Double</code>），以便在计算中混合使用它们。</li></ul></li></ol></main><br><footer><div class=footer-info><p>Copyright &copy; 2025 Rainboy. All rights reserved.
<span>| Last build: 2025-11-09 22:54:39</span></p></div><script defer>document.addEventListener("keydown",function(e){if(document.activeElement.isContentEditable)return!1;if(document.activeElement.tagName=="INPUT")return!1;if(e.altKey||e.ctrlKey||e.shiftKey)return!1;var t=e.key;if(t==="h")e.preventDefault(),e.stopPropagation(),window.location.href="/";else if(t==="t")e.preventDefault(),e.stopPropagation(),window.location.href=`https://${location.hostname}/tags`;else if(t==="i"){e.preventDefault(),e.stopPropagation();const t=document.querySelectorAll("input");for(let e=0;e<t.length;e++)if(t[e].offsetParent!==null){t[e].selectionStart=t[e].selectionEnd=t[e].value.length,t[e].focus();break}}return!1})</script><script defer>function throttle(e,t){var n=Date.now();return function(){var s=Date.now();n+t-s<0&&(e(),n=s)}}function scrollHandler(){const e=Array.from(document.querySelectorAll("body h2, body h3"));function t(){for(var n,s,o,i=window.pageYOffset||document.documentElement.scrollTop,t=0;t<e.length;t++)s=e[t].getAttribute("id"),n=document.querySelector('nav ul li a[href="#'+s+'"]'),n&&n.classList.remove("active-toc");for(t=e.length-1;t>=0;t--)if(o=e[t].offsetTop,i>o-75&&(s=e[t].getAttribute("id"),n=document.querySelector('nav ul li a[href="#'+s+'"]'),n)){n.classList.add("active-toc");break}}window.addEventListener("scroll",throttle(t,200))}setTimeout(scrollHandler,100)</script><script defer>function addCopyButtonToCodeBlocks(){const e=document.querySelectorAll('code[class^="language-"]:not(.output):not([class*="language-console"])');e.forEach(e=>{const t=document.createElement("button");t.classList.add("copy-code-button"),t.innerHTML="copy",t.addEventListener("click",()=>{const s=e.querySelectorAll(".cl");let n="";s.forEach(e=>{n+=e.innerText}),navigator.clipboard.writeText(n),t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},1500)}),e.parentNode.before(t)})}setTimeout(function(){addCopyButtonToCodeBlocks()},100)</script><script defer src=/js/theme-switcher.js></script></footer></body></html>