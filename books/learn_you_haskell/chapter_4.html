<!doctype html><html lang=zh-cn><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta http-equiv=cache-control content="max-age=0"><meta http-equiv=cache-control content="no-cache"><meta http-equiv=expires content="0"><meta http-equiv=expires content="Tue, 01 Jan 1980 1:00:00 GMT"><meta http-equiv=pragma content="no-cache"><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png }><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=manifest href=/site.webmanifest><meta name=theme-color media="(prefers-color-scheme: light)" content="#ffffff"><meta name=theme-color media="(prefers-color-scheme: dark)" content="#1b1b1b"><meta name=description content="chapter_4 《Haskell：函数语法》读书笔记核心内容"><script>(function(){const e=localStorage.getItem("theme")||(window.matchMedia("(prefers-color-scheme: dark)").matches?"dark":"light");document.documentElement.setAttribute("data-theme",e)})()</script><title>chapter_4 《Haskell：函数语法》读书笔记核心内容 | Rainboy's Blog</title><style>:root{--background:#ffffff}@media(prefers-color-scheme:dark){:root{--background:#1b1b1b}}html{background-color:var(--background)}body{background-color:var(--background)}</style><link rel=stylesheet type=text/css href=/style.min.4de9e3236bcb55312d0b2ff0fc62c694f607b9c0d95d0621f6c6dbacb7d6dbb5.css media=all><link rel=stylesheet href=/grid.css><link href="https://fonts.font.im/css?family=Roboto+Mono" rel=stylesheet><style>body,.heti,.heti--sans{font-family:roboto mono,monospace,times new roman,times,heti song,serif,apple color emoji,segoe ui emoji,segoe ui symbol}</style></head><body><nav><ul class=menu><li><a tabindex=-1 class=menu-link href=/><u>H</u>ome</a></li><li><a tabindex=-1 class=menu-link href=/tags><u>T</u>ags</a></li><li><span style=cursor:pointer id=theme-switcher class=menu-link type=button><svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-moon h-4 w-4"><path d="M12 3a6 6 0 009 9 9 9 0 11-9-9z"/></svg></span></li></ul></nav><div id=single-header><h1>chapter_4 《Haskell：函数语法》读书笔记核心内容</h1><div id=single-meta><span class=datesub>2025-09-11 00:00</span>
<span id=tags>&nbsp;&nbsp;
<span><a href=https://hugo-dead-simple.netlify.com/tags/index.html>#</a>
</span>&nbsp;</span></div></div><aside class="hidden lg:block toc" id=tableOfContentContainer><nav id=TableOfContents><ul><li><a href=#一-模式匹配-pattern-matching>一、 模式匹配 (Pattern Matching)</a><ul><li><a href=#1-基本用法>1. 基本用法</a></li><li><a href=#2-在递归中的应用>2. 在递归中的应用</a></li><li><a href=#3-匹配元组-tuples-和列表-lists>3. 匹配元组 (Tuples) 和列表 (Lists)</a></li><li><a href=#4-as模式as-patterns>4. “as”模式（As-Patterns）</a></li></ul></li><li><a href=#二-哨兵-guards>二、 哨兵 (Guards)</a></li><li><a href=#三-where-绑定>三、 <code>where</code> 绑定</a></li><li><a href=#四-let-绑定>四、 <code>let</code> 绑定</a></li><li><a href=#五-case-表达式>五、 <code>case</code> 表达式</a></li></ul></nav></aside><main class="heti heti--classic"><h2 id=一-模式匹配-pattern-matching>一、 模式匹配 (Pattern Matching)</h2><p>模式匹配是 Haskell 中一种极其强大的特性，它允许你根据输入数据的具体“形状”或“值”来定义函数的不同行为。</p><h3 id=1-基本用法>1. 基本用法</h3><p>通过为同一个函数提供多个定义（称为“函数子句”），Haskell 会按从上到下的顺序检查哪个模式匹配了当前的参数：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-haskell data-lang=haskell><span class=line><span class=ln> 1</span><span class=cl><span class=c1>-- 如果参数是 7，就返回 &#34;LUCKY NUMBER SEVEN!&#34;</span>
</span></span><span class=line><span class=ln> 2</span><span class=cl><span class=nf>lucky</span> <span class=ow>::</span> <span class=kt>Int</span> <span class=ow>-&gt;</span> <span class=kt>String</span>
</span></span><span class=line><span class=ln> 3</span><span class=cl><span class=nf>lucky</span> <span class=mi>7</span> <span class=ow>=</span> <span class=s>&#34;LUCKY NUMBER SEVEN!&#34;</span>
</span></span><span class=line><span class=ln> 4</span><span class=cl><span class=c1>-- 如果参数是其他任何整数（用 x 匹配），就返回 &#34;Sorry, you&#39;re out of luck, pal!&#34;</span>
</span></span><span class=line><span class=ln> 5</span><span class=cl><span class=nf>lucky</span> <span class=n>x</span> <span class=ow>=</span> <span class=s>&#34;Sorry, you&#39;re out of luck, pal!&#34;</span>
</span></span><span class=line><span class=ln> 6</span><span class=cl>
</span></span><span class=line><span class=ln> 7</span><span class=cl><span class=c1>-- 调用:</span>
</span></span><span class=line><span class=ln> 8</span><span class=cl><span class=c1>-- ghci&gt; lucky 7</span>
</span></span><span class=line><span class=ln> 9</span><span class=cl><span class=c1>-- &#34;LUCKY NUMBER SEVEN!&#34;</span>
</span></span><span class=line><span class=ln>10</span><span class=cl><span class=c1>-- ghci&gt; lucky 8</span>
</span></span><span class=line><span class=ln>11</span><span class=cl><span class=c1>-- &#34;Sorry, you&#39;re out of luck, pal!&#34;</span>
</span></span></code></pre></div><h3 id=2-在递归中的应用>2. 在递归中的应用</h3><p>模式匹配是实现递归函数的自然方式，特别是用于定义“基本情况”（Base Case）：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-haskell data-lang=haskell><span class=line><span class=ln>1</span><span class=cl><span class=nf>factorial</span> <span class=ow>::</span> <span class=kt>Int</span> <span class=ow>-&gt;</span> <span class=kt>Int</span>
</span></span><span class=line><span class=ln>2</span><span class=cl><span class=c1>-- 基本情况：0 的阶乘是 1</span>
</span></span><span class=line><span class=ln>3</span><span class=cl><span class=nf>factorial</span> <span class=mi>0</span> <span class=ow>=</span> <span class=mi>1</span>
</span></span><span class=line><span class=ln>4</span><span class=cl><span class=c1>-- 递归情况：n 的阶乘是 n * (n-1) 的阶乘</span>
</span></span><span class=line><span class=ln>5</span><span class=cl><span class=nf>factorial</span> <span class=n>n</span> <span class=ow>=</span> <span class=n>n</span> <span class=o>*</span> <span class=n>factorial</span> <span class=p>(</span><span class=n>n</span> <span class=o>-</span> <span class=mi>1</span><span class=p>)</span>
</span></span></code></pre></div><h3 id=3-匹配元组-tuples-和列表-lists>3. 匹配元组 (Tuples) 和列表 (Lists)</h3><p>模式匹配可以“解构”数据结构：</p><ul><li><p><strong>元组：</strong></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-haskell data-lang=haskell><span class=line><span class=ln>1</span><span class=cl><span class=nf>addVectors</span> <span class=ow>::</span> <span class=p>(</span><span class=kt>Double</span><span class=p>,</span> <span class=kt>Double</span><span class=p>)</span> <span class=ow>-&gt;</span> <span class=p>(</span><span class=kt>Double</span><span class=p>,</span> <span class=kt>Double</span><span class=p>)</span> <span class=ow>-&gt;</span> <span class=p>(</span><span class=kt>Double</span><span class=p>,</span> <span class=kt>Double</span><span class=p>)</span>
</span></span><span class=line><span class=ln>2</span><span class=cl><span class=c1>-- 将两个元组的元素分别解构到 a, b 和 x, y</span>
</span></span><span class=line><span class=ln>3</span><span class=cl><span class=nf>addVectors</span> <span class=p>(</span><span class=n>a</span><span class=p>,</span> <span class=n>b</span><span class=p>)</span> <span class=p>(</span><span class=n>x</span><span class=p>,</span> <span class=n>y</span><span class=p>)</span> <span class=ow>=</span> <span class=p>(</span><span class=n>a</span> <span class=o>+</span> <span class=n>x</span><span class=p>,</span> <span class=n>b</span> <span class=o>+</span> <span class=n>y</span><span class=p>)</span>
</span></span></code></pre></div></li><li><p><strong>列表：</strong></p><ul><li><code>[]</code>：匹配空列表。</li><li><code>x:xs</code>（Cons 操作符）：匹配非空列表。<code>x</code> 绑定到列表的<strong>头部</strong>（第一个元素），<code>xs</code> 绑定到<strong>尾部</strong>（剩余所有元素组成的列表）。</li><li><code>x:y:zs</code>：匹配至少有两个元素的列表。<code>x</code> 是第一个，<code>y</code> 是第二个，<code>zs</code> 是剩下的。</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-haskell data-lang=haskell><span class=line><span class=ln>1</span><span class=cl><span class=nf>myHead</span> <span class=ow>::</span> <span class=p>[</span><span class=n>a</span><span class=p>]</span> <span class=ow>-&gt;</span> <span class=n>a</span>
</span></span><span class=line><span class=ln>2</span><span class=cl><span class=c1>-- 如果列表非空 (x:xs)，返回头部 x</span>
</span></span><span class=line><span class=ln>3</span><span class=cl><span class=nf>myHead</span> <span class=p>(</span><span class=n>x</span><span class=kt>:</span><span class=n>xs</span><span class=p>)</span> <span class=ow>=</span> <span class=n>x</span>
</span></span><span class=line><span class=ln>4</span><span class=cl><span class=c1>-- 注意：这个版本的 myHead 在遇到空列表时会引发错误，因为它没有匹配 [] 的模式。</span>
</span></span></code></pre></div></li></ul><h3 id=4-as模式as-patterns>4. “as”模式（As-Patterns）</h3><p>使用 <code>@</code> 符号，你可以在解构的同时，保留对整个匹配项的引用：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-haskell data-lang=haskell><span class=line><span class=ln> 1</span><span class=cl><span class=c1>-- xs@(x:y:_)</span>
</span></span><span class=line><span class=ln> 2</span><span class=cl><span class=c1>-- xs 会绑定到整个列表</span>
</span></span><span class=line><span class=ln> 3</span><span class=cl><span class=c1>-- x 会绑定到第一个元素</span>
</span></span><span class=line><span class=ln> 4</span><span class=cl><span class=c1>-- y 会绑定到第二个元素</span>
</span></span><span class=line><span class=ln> 5</span><span class=cl><span class=nf>capital</span> <span class=ow>::</span> <span class=kt>String</span> <span class=ow>-&gt;</span> <span class=kt>String</span>
</span></span><span class=line><span class=ln> 6</span><span class=cl><span class=nf>capital</span> <span class=s>&#34;&#34;</span> <span class=ow>=</span> <span class=s>&#34;Empty string, whoops!&#34;</span>
</span></span><span class=line><span class=ln> 7</span><span class=cl><span class=nf>capital</span> <span class=n>all</span><span class=o>@</span><span class=p>(</span><span class=n>x</span><span class=kt>:</span><span class=n>xs</span><span class=p>)</span> <span class=ow>=</span> <span class=s>&#34;The first letter of &#34;</span> <span class=o>++</span> <span class=n>all</span> <span class=o>++</span> <span class=s>&#34; is &#34;</span> <span class=o>++</span> <span class=p>[</span><span class=n>x</span><span class=p>]</span>
</span></span><span class=line><span class=ln> 8</span><span class=cl>
</span></span><span class=line><span class=ln> 9</span><span class=cl><span class=c1>-- 调用:</span>
</span></span><span class=line><span class=ln>10</span><span class=cl><span class=c1>-- ghci&gt; capital &#34;Dracula&#34;</span>
</span></span><span class=line><span class=ln>11</span><span class=cl><span class=c1>-- &#34;The first letter of Dracula is D&#34;</span>
</span></span></code></pre></div><h2 id=二-哨兵-guards>二、 哨兵 (Guards)</h2><p>如果说模式匹配是根据“形状”进行分支，那么哨兵（Guards）就是根据“布尔条件”（<code>True</code> 或 <code>False</code>）来进行分支。</p><ul><li>哨兵写在函数体等号的右侧，用 <code>|</code>（管道符）开始。</li><li>Haskell 会<strong>依次检查</strong>每个哨兵条件。</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-haskell data-lang=haskell><span class=line><span class=ln> 1</span><span class=cl><span class=nf>bmiTell</span> <span class=ow>::</span> <span class=kt>Double</span> <span class=ow>-&gt;</span> <span class=kt>Double</span> <span class=ow>-&gt;</span> <span class=kt>String</span>
</span></span><span class=line><span class=ln> 2</span><span class=cl><span class=nf>bmiTell</span> <span class=n>weight</span> <span class=n>height</span>
</span></span><span class=line><span class=ln> 3</span><span class=cl>    <span class=o>|</span> <span class=n>bmi</span> <span class=o>&lt;=</span> <span class=mf>18.5</span> <span class=ow>=</span> <span class=s>&#34;You&#39;re underweight, you emo, you!&#34;</span>
</span></span><span class=line><span class=ln> 4</span><span class=cl>    <span class=o>|</span> <span class=n>bmi</span> <span class=o>&lt;=</span> <span class=mf>25.0</span> <span class=ow>=</span> <span class=s>&#34;You&#39;re supposedly normal.&#34;</span>
</span></span><span class=line><span class=ln> 5</span><span class=cl>    <span class=o>|</span> <span class=n>bmi</span> <span class=o>&lt;=</span> <span class=mf>30.0</span> <span class=ow>=</span> <span class=s>&#34;You&#39;re fat! Lose some weight, fatty!&#34;</span>
</span></span><span class=line><span class=ln> 6</span><span class=cl>    <span class=o>|</span> <span class=n>otherwise</span>   <span class=ow>=</span> <span class=s>&#34;You&#39;re a whale, congratulations!&#34;</span>
</span></span><span class=line><span class=ln> 7</span><span class=cl>    <span class=kr>where</span> <span class=n>bmi</span> <span class=ow>=</span> <span class=n>weight</span> <span class=o>/</span> <span class=n>height</span> <span class=o>^</span> <span class=mi>2</span> <span class=c1>-- &#39;where&#39; 绑定在下面介绍</span>
</span></span><span class=line><span class=ln> 8</span><span class=cl>
</span></span><span class=line><span class=ln> 9</span><span class=cl><span class=c1>-- `otherwise` 是一个特殊的哨兵，它总是为 True，用于捕捉所有其他情况，</span>
</span></span><span class=line><span class=ln>10</span><span class=cl><span class=c1>-- 类似于其他语言中的 &#39;else&#39;。</span>
</span></span></code></pre></div><h2 id=三-where-绑定>三、 <code>where</code> 绑定</h2><p><code>where</code> 关键字允许你在函数定义的<strong>末尾</strong>（在所有哨兵之后）定义局部变量或辅助函数。</p><ul><li><strong>作用域</strong>：<code>where</code> 中定义的名称只在<strong>当前这个函数定义</strong>（包括它所有的哨兵）中可见。</li><li><strong>对齐</strong>：<code>where</code> 块中的所有绑定必须正确对齐。</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-haskell data-lang=haskell><span class=line><span class=ln>1</span><span class=cl><span class=nf>bmiTell</span> <span class=ow>::</span> <span class=kt>Double</span> <span class=ow>-&gt;</span> <span class=kt>Double</span> <span class=ow>-&gt;</span> <span class=kt>String</span>
</span></span><span class=line><span class=ln>2</span><span class=cl><span class=nf>bmiTell</span> <span class=n>weight</span> <span class=n>height</span>
</span></span><span class=line><span class=ln>3</span><span class=cl>    <span class=o>|</span> <span class=n>bmi</span> <span class=o>&lt;=</span> <span class=n>skinny</span> <span class=ow>=</span> <span class=s>&#34;You&#39;re underweight, you emo, you!&#34;</span>
</span></span><span class=line><span class=ln>4</span><span class=cl>    <span class=o>|</span> <span class=n>bmi</span> <span class=o>&lt;=</span> <span class=n>normal</span> <span class=ow>=</span> <span class=s>&#34;You&#39;re supposedly normal.&#34;</span>
</span></span><span class=line><span class=ln>5</span><span class=cl>    <span class=o>|</span> <span class=n>bmi</span> <span class=o>&lt;=</span> <span class=n>fat</span>    <span class=ow>=</span> <span class=s>&#34;You&#39;re fat! Lose some weight, fatty!&#34;</span>
</span></span><span class=line><span class=ln>6</span><span class=cl>    <span class=o>|</span> <span class=n>otherwise</span>     <span class=ow>=</span> <span class=s>&#34;You&#39;re a whale, congratulations!&#34;</span>
</span></span><span class=line><span class=ln>7</span><span class=cl>    <span class=kr>where</span> <span class=n>bmi</span> <span class=ow>=</span> <span class=n>weight</span> <span class=o>/</span> <span class=n>height</span> <span class=o>^</span> <span class=mi>2</span>
</span></span><span class=line><span class=ln>8</span><span class=cl>          <span class=c1>-- 可以在 where 内部继续定义</span>
</span></span><span class=line><span class=ln>9</span><span class=cl>          <span class=p>(</span><span class=n>skinny</span><span class=p>,</span> <span class=n>normal</span><span class=p>,</span> <span class=n>fat</span><span class=p>)</span> <span class=ow>=</span> <span class=p>(</span><span class=mf>18.5</span><span class=p>,</span> <span class=mf>25.0</span><span class=p>,</span> <span class=mf>30.0</span><span class=p>)</span>
</span></span></code></pre></div><h2 id=四-let-绑定>四、 <code>let</code> 绑定</h2><p><code>let</code> 绑定是另一种创建局部变量的方式，但它是一个<strong>表达式</strong>，而不是像 <code>where</code> 那样的“块”。</p><ul><li><strong>格式</strong>：<code>let &lt;bindings> in &lt;expression></code></li><li><strong>作用域</strong>：<code>let</code> 中定义的名称<strong>只在 <code>in</code> 之后的表达式中</strong>可见。</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-haskell data-lang=haskell><span class=line><span class=ln>1</span><span class=cl><span class=nf>cylinder</span> <span class=ow>::</span> <span class=kt>Double</span> <span class=ow>-&gt;</span> <span class=kt>Double</span> <span class=ow>-&gt;</span> <span class=kt>Double</span>
</span></span><span class=line><span class=ln>2</span><span class=cl><span class=nf>cylinder</span> <span class=n>r</span> <span class=n>h</span> <span class=ow>=</span>
</span></span><span class=line><span class=ln>3</span><span class=cl>    <span class=kr>let</span> <span class=n>sideArea</span> <span class=ow>=</span> <span class=mi>2</span> <span class=o>*</span> <span class=n>pi</span> <span class=o>*</span> <span class=n>r</span> <span class=o>*</span> <span class=n>h</span>
</span></span><span class=line><span class=ln>4</span><span class=cl>        <span class=n>topArea</span> <span class=ow>=</span> <span class=n>pi</span> <span class=o>*</span> <span class=n>r</span> <span class=o>^</span> <span class=mi>2</span>
</span></span><span class=line><span class=ln>5</span><span class=cl>    <span class=kr>in</span> <span class=n>sideArea</span> <span class=o>+</span> <span class=mi>2</span> <span class=o>*</span> <span class=n>topArea</span>
</span></span></code></pre></div><ul><li><strong><code>let</code> vs <code>where</code></strong>：<ul><li><code>where</code> 绑定在函数底部，其作用域覆盖整个函数（包括所有哨兵）。</li><li><code>let</code> 绑定是表达式，可以<strong>随处使用</strong>（例如在 <code>if</code> 语句的某个分支中），但作用域仅限于其 <code>in</code> 部分。</li><li><code>let</code> 绑定在 GHCI（Haskell 解释器）中非常有用，可以用来定义临时变量。</li></ul></li></ul><h2 id=五-case-表达式>五、 <code>case</code> 表达式</h2><p><code>case</code> 表达式是模式匹配的“表达式版本”。它允许你在函数体内的任何地方，根据一个值进行模式匹配。</p><ul><li><p><strong>格式</strong>：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-haskell data-lang=haskell><span class=line><span class=ln>1</span><span class=cl><span class=kr>case</span> <span class=o>&lt;</span><span class=n>expression</span><span class=o>&gt;</span> <span class=kr>of</span>
</span></span><span class=line><span class=ln>2</span><span class=cl>    <span class=o>&lt;</span><span class=n>pattern1</span><span class=o>&gt;</span> <span class=ow>-&gt;</span> <span class=o>&lt;</span><span class=n>result1</span><span class=o>&gt;</span>
</span></span><span class=line><span class=ln>3</span><span class=cl>    <span class=o>&lt;</span><span class=n>pattern2</span><span class=o>&gt;</span> <span class=ow>-&gt;</span> <span class=o>&lt;</span><span class=n>result2</span><span class=o>&gt;</span>
</span></span><span class=line><span class=ln>4</span><span class=cl>    <span class=o>...</span>
</span></span></code></pre></div></li><li><p><strong>用途</strong>：当你不想为每种模式都创建一个顶层函数定义，或者想在另一个表达式内部进行模式匹配时，<code>case</code> 非常有用。</p></li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-haskell data-lang=haskell><span class=line><span class=ln> 1</span><span class=cl><span class=c1>-- 使用 case 重写 head</span>
</span></span><span class=line><span class=ln> 2</span><span class=cl><span class=nf>head&#39;</span> <span class=ow>::</span> <span class=p>[</span><span class=n>a</span><span class=p>]</span> <span class=ow>-&gt;</span> <span class=n>a</span>
</span></span><span class=line><span class=ln> 3</span><span class=cl><span class=nf>head&#39;</span> <span class=n>xs</span> <span class=ow>=</span> <span class=kr>case</span> <span class=n>xs</span> <span class=kr>of</span> <span class=kt>[]</span>    <span class=ow>-&gt;</span> <span class=ne>error</span> <span class=s>&#34;No head for empty lists!&#34;</span>
</span></span><span class=line><span class=ln> 4</span><span class=cl>                      <span class=p>(</span><span class=n>x</span><span class=kt>:</span><span class=kr>_</span><span class=p>)</span> <span class=ow>-&gt;</span> <span class=n>x</span>
</span></span><span class=line><span class=ln> 5</span><span class=cl>
</span></span><span class=line><span class=ln> 6</span><span class=cl><span class=c1>-- 描述列表的 case 表达式</span>
</span></span><span class=line><span class=ln> 7</span><span class=cl><span class=nf>describeList</span> <span class=ow>::</span> <span class=p>[</span><span class=n>a</span><span class=p>]</span> <span class=ow>-&gt;</span> <span class=kt>String</span>
</span></span><span class=line><span class=ln> 8</span><span class=cl><span class=nf>describeList</span> <span class=n>xs</span> <span class=ow>=</span> <span class=s>&#34;The list is &#34;</span> <span class=o>++</span> <span class=kr>case</span> <span class=n>xs</span> <span class=kr>of</span> <span class=kt>[]</span>  <span class=ow>-&gt;</span> <span class=s>&#34;empty.&#34;</span>
</span></span><span class=line><span class=ln> 9</span><span class=cl>                                               <span class=p>[</span><span class=n>x</span><span class=p>]</span> <span class=ow>-&gt;</span> <span class=s>&#34;a singleton list.&#34;</span>
</span></span><span class=line><span class=ln>10</span><span class=cl>                                               <span class=kr>_</span>   <span class=ow>-&gt;</span> <span class=s>&#34;a longer list.&#34;</span>
</span></span></code></pre></div><hr></main><br><footer><div class=footer-info><p>Copyright &copy; 2025 Rainboy. All rights reserved.
<span>| Last build: 2025-11-09 22:54:39</span></p></div><script defer>document.addEventListener("keydown",function(e){if(document.activeElement.isContentEditable)return!1;if(document.activeElement.tagName=="INPUT")return!1;if(e.altKey||e.ctrlKey||e.shiftKey)return!1;var t=e.key;if(t==="h")e.preventDefault(),e.stopPropagation(),window.location.href="/";else if(t==="t")e.preventDefault(),e.stopPropagation(),window.location.href=`https://${location.hostname}/tags`;else if(t==="i"){e.preventDefault(),e.stopPropagation();const t=document.querySelectorAll("input");for(let e=0;e<t.length;e++)if(t[e].offsetParent!==null){t[e].selectionStart=t[e].selectionEnd=t[e].value.length,t[e].focus();break}}return!1})</script><script defer>function throttle(e,t){var n=Date.now();return function(){var s=Date.now();n+t-s<0&&(e(),n=s)}}function scrollHandler(){const e=Array.from(document.querySelectorAll("body h2, body h3"));function t(){for(var n,s,o,i=window.pageYOffset||document.documentElement.scrollTop,t=0;t<e.length;t++)s=e[t].getAttribute("id"),n=document.querySelector('nav ul li a[href="#'+s+'"]'),n&&n.classList.remove("active-toc");for(t=e.length-1;t>=0;t--)if(o=e[t].offsetTop,i>o-75&&(s=e[t].getAttribute("id"),n=document.querySelector('nav ul li a[href="#'+s+'"]'),n)){n.classList.add("active-toc");break}}window.addEventListener("scroll",throttle(t,200))}setTimeout(scrollHandler,100)</script><script defer>function addCopyButtonToCodeBlocks(){const e=document.querySelectorAll('code[class^="language-"]:not(.output):not([class*="language-console"])');e.forEach(e=>{const t=document.createElement("button");t.classList.add("copy-code-button"),t.innerHTML="copy",t.addEventListener("click",()=>{const s=e.querySelectorAll(".cl");let n="";s.forEach(e=>{n+=e.innerText}),navigator.clipboard.writeText(n),t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},1500)}),e.parentNode.before(t)})}setTimeout(function(){addCopyButtonToCodeBlocks()},100)</script><script defer src=/js/theme-switcher.js></script></footer></body></html>