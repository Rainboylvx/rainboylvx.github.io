<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>lua学习笔记 on Rainboy's Blog</title><link>https://hugo-dead-simple.netlify.com/program_language/lua/index.html</link><description>Recent content in lua学习笔记 on Rainboy's Blog</description><generator>Hugo</generator><language>zh-cn</language><lastBuildDate>Fri, 24 Oct 2025 07:51:34 +0000</lastBuildDate><atom:link href="https://hugo-dead-simple.netlify.com/program_language/lua/index.xml" rel="self" type="application/rss+xml"/><item><title>元表及元方法</title><link>https://hugo-dead-simple.netlify.com/program_language/lua/lua%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%9F%BA%E7%A1%80.html</link><pubDate>Wed, 22 Oct 2025 00:00:00 +0000</pubDate><guid>https://hugo-dead-simple.netlify.com/program_language/lua/lua%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%9F%BA%E7%A1%80.html</guid><description>&lt;h2 id="元表概念"&gt;元表概念&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Lua 中的每个值都可以有一个元表&lt;/strong&gt;。此元表是一个普通的 Lua 表，它定义了原始值在特定事件下的行为。您可以通过设置其元表中的特定字段来更改值的多个行为方面。例如，当非数字值是加法的操作数时，Lua 会在该值的元表的 __add 字段中查找一个函数。如果找到一个，Lua 会调用此函数来执行加法&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;详细参见 &lt;a href="https://cloudwu.github.io/lua53doc/manual.html#2.4" target="_blank" rel="noopener"&gt;2.4 – 元表及元方法&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;举一个例子,类似于 c++的运算符重载,这里我们重载&lt;code&gt;+&lt;/code&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-Lua" data-lang="Lua"&gt;&lt;span class="line"&gt;&lt;span class="ln"&gt; 1&lt;/span&gt;&lt;span class="cl"&gt;&lt;span class="n"&gt;foo&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="ln"&gt; 2&lt;/span&gt;&lt;span class="cl"&gt;&lt;span class="n"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;foo.a&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="ln"&gt; 3&lt;/span&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="ln"&gt; 4&lt;/span&gt;&lt;span class="cl"&gt;&lt;span class="n"&gt;smt&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="ln"&gt; 5&lt;/span&gt;&lt;span class="cl"&gt; &lt;span class="n"&gt;__add&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="kr"&gt;function&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="ln"&gt; 6&lt;/span&gt;&lt;span class="cl"&gt; &lt;span class="kr"&gt;return&lt;/span&gt; &lt;span class="n"&gt;a.a&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="ln"&gt; 7&lt;/span&gt;&lt;span class="cl"&gt; &lt;span class="kr"&gt;end&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="ln"&gt; 8&lt;/span&gt;&lt;span class="cl"&gt;&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="ln"&gt; 9&lt;/span&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="ln"&gt;10&lt;/span&gt;&lt;span class="cl"&gt;&lt;span class="c1"&gt;-- 设定 foo 的元表,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="ln"&gt;11&lt;/span&gt;&lt;span class="cl"&gt;&lt;span class="c1"&gt;-- 当你对非数字值做加操作时， Lua 会检查该值的元表中的 &amp;#34;__add&amp;#34; 域下的函数&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="ln"&gt;12&lt;/span&gt;&lt;span class="cl"&gt;&lt;span class="n"&gt;setmetatable&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;foo&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;smt&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="ln"&gt;13&lt;/span&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="ln"&gt;14&lt;/span&gt;&lt;span class="cl"&gt;&lt;span class="n"&gt;b&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;foo&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="ln"&gt;15&lt;/span&gt;&lt;span class="cl"&gt;&lt;span class="n"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;string.format&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;#34;foo + 1 = %d&amp;#34;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id="__index"&gt;__index&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;&lt;code&gt;__index&lt;/code&gt;:&lt;/strong&gt; 索引 &lt;code&gt;table[key]&lt;/code&gt;。 当 &lt;code&gt;table&lt;/code&gt; 不是表或是表 &lt;code&gt;table&lt;/code&gt; 中不存在 &lt;code&gt;key&lt;/code&gt; 这个键时，这个事件被触发。 此时，会读出 &lt;code&gt;table&lt;/code&gt; 相应的元方法。
尽管名字取成这样， 这个事件的元方法其实可以是一个函数也可以是一张表。 如果它是一个函数，则以 &lt;code&gt;table&lt;/code&gt; 和 &lt;code&gt;key&lt;/code&gt; 作为参数调用它。 如果它是一张表，最终的结果就是以 &lt;code&gt;key&lt;/code&gt; 取索引这张表的结果。 （这个索引过程是走常规的流程，而不是直接索引， 所以这次索引有可能引发另一次元方法。）&lt;/p&gt;</description></item><item><title>Lua中的面向对象编程</title><link>https://hugo-dead-simple.netlify.com/program_language/lua/lua%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1.html</link><pubDate>Tue, 30 Sep 2025 00:00:00 +0000</pubDate><guid>https://hugo-dead-simple.netlify.com/program_language/lua/lua%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1.html</guid><description>&lt;p&gt;嗨！很高兴能和你一起探索Lua这门优雅且强大的语言。你可能知道，Lua天生并没有像Java或C++那样的内置类和对象系统。但别担心，这正是它的魅力所在！这门语言提供了极其灵活的元编程机制，让我们能够&lt;strong&gt;从零开始，亲手构建一个属于自己的面向对象（Object-Oriented Programming，简称OOP）世界&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;这篇博客将带你深入理解Lua中实现OOP的几种核心思想，从最基础的&lt;strong&gt;表（table）和元表（metatable）&lt;/strong&gt;，到实用的继承和多态。准备好了吗？让我们开始吧！&lt;/p&gt;
&lt;h2 id="核心概念表元表和__index"&gt;核心概念：表、元表和&lt;code&gt;__index&lt;/code&gt;&lt;/h2&gt;
&lt;p&gt;在Lua中，一切皆表。表是Lua中唯一的数据结构，它既可以是数组，也可以是哈希表。而实现OOP的关键，就在于如何利用&lt;strong&gt;元表&lt;/strong&gt;来赋予表新的行为。&lt;/p&gt;
&lt;p&gt;你可以把&lt;strong&gt;元表&lt;/strong&gt;想象成一个表的“配置文件”或者“行为蓝图”。当你在一个表上执行某个操作（比如访问一个不存在的键）时，如果这个表设置了元表，Lua就会去元表中查找对应的特殊字段，我们称之为&lt;strong&gt;元方法（metamethod）&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;实现OOP，我们主要关注一个元方法：&lt;code&gt;__index&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;__index&lt;/code&gt;的神奇之处在于：当你想在一个表中访问一个不存在的键时，Lua不会直接返回&lt;code&gt;nil&lt;/code&gt;，而是会去&lt;strong&gt;这个表的元表&lt;/strong&gt;中，查找&lt;code&gt;__index&lt;/code&gt;字段。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果&lt;code&gt;__index&lt;/code&gt;是一个&lt;strong&gt;表&lt;/strong&gt;，Lua就会在这个表中继续查找这个键。&lt;/li&gt;
&lt;li&gt;如果&lt;code&gt;__index&lt;/code&gt;是一个&lt;strong&gt;函数&lt;/strong&gt;，Lua就会调用这个函数，并把原始的表和键作为参数传入。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;我们主要利用第一种情况来实现“继承”的行为。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;参考 &lt;a href="https://wiki-zh.luatos.org/luaGuide/luaReference.html#id6" target="_blank" rel="noopener"&gt;lua 5.3 中文手册 2.4 – 元表及元方法&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="方案一基础的基于表的oop"&gt;方案一：基础的基于表的OOP&lt;/h2&gt;
&lt;p&gt;这是最简单，也是最常见的实现方式。我们利用&lt;code&gt;__index&lt;/code&gt;指向一个&lt;strong&gt;原型表（prototype table）&lt;/strong&gt;，这个原型表就像是我们的“类”，里面存放着所有对象共享的方法。&lt;/p&gt;
&lt;p&gt;让我们来创建一个简单的&lt;code&gt;Vector2&lt;/code&gt;类，代表二维向量。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-lua" data-lang="lua"&gt;&lt;span class="line"&gt;&lt;span class="ln"&gt; 1&lt;/span&gt;&lt;span class="cl"&gt;&lt;span class="c1"&gt;-- Vector2.lua&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="ln"&gt; 2&lt;/span&gt;&lt;span class="cl"&gt;&lt;span class="kd"&gt;local&lt;/span&gt; &lt;span class="n"&gt;Vector2&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;{}&lt;/span&gt; &lt;span class="c1"&gt;-- 我们的“类”原型表&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="ln"&gt; 3&lt;/span&gt;&lt;span class="cl"&gt;&lt;span class="n"&gt;Vector2.__index&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;Vector2&lt;/span&gt; &lt;span class="c1"&gt;-- 关键步骤：设置元表，指向自身&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="ln"&gt; 4&lt;/span&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="ln"&gt; 5&lt;/span&gt;&lt;span class="cl"&gt;&lt;span class="kr"&gt;function&lt;/span&gt; &lt;span class="nc"&gt;Vector2&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nf"&gt;new&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="ln"&gt; 6&lt;/span&gt;&lt;span class="cl"&gt; &lt;span class="kd"&gt;local&lt;/span&gt; &lt;span class="n"&gt;self&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="c1"&gt;-- 创建实例&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="ln"&gt; 7&lt;/span&gt;&lt;span class="cl"&gt; &lt;span class="n"&gt;setmetatable&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;self&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;Vector2&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="c1"&gt;-- 设置实例的元表为Vector2&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="ln"&gt; 8&lt;/span&gt;&lt;span class="cl"&gt; &lt;span class="kr"&gt;return&lt;/span&gt; &lt;span class="n"&gt;self&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="ln"&gt; 9&lt;/span&gt;&lt;span class="cl"&gt;&lt;span class="kr"&gt;end&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="ln"&gt;10&lt;/span&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="ln"&gt;11&lt;/span&gt;&lt;span class="cl"&gt;&lt;span class="kr"&gt;function&lt;/span&gt; &lt;span class="nc"&gt;Vector2&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="nf"&gt;add&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;other&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="ln"&gt;12&lt;/span&gt;&lt;span class="cl"&gt; &lt;span class="c1"&gt;-- 注意：这里的冒号语法糖会把self作为第一个参数传入&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="ln"&gt;13&lt;/span&gt;&lt;span class="cl"&gt; &lt;span class="kr"&gt;return&lt;/span&gt; &lt;span class="n"&gt;Vector2.new&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;self.x&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;other.x&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;self.y&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;other.y&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="ln"&gt;14&lt;/span&gt;&lt;span class="cl"&gt;&lt;span class="kr"&gt;end&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="ln"&gt;15&lt;/span&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="ln"&gt;16&lt;/span&gt;&lt;span class="cl"&gt;&lt;span class="kr"&gt;function&lt;/span&gt; &lt;span class="nc"&gt;Vector2&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="nf"&gt;tostring&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="ln"&gt;17&lt;/span&gt;&lt;span class="cl"&gt; &lt;span class="kr"&gt;return&lt;/span&gt; &lt;span class="n"&gt;string.format&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;#34;Vector2(%f, %f)&amp;#34;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;self.x&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;self.y&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="ln"&gt;18&lt;/span&gt;&lt;span class="cl"&gt;&lt;span class="kr"&gt;end&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="ln"&gt;19&lt;/span&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="ln"&gt;20&lt;/span&gt;&lt;span class="cl"&gt;&lt;span class="kd"&gt;local&lt;/span&gt; &lt;span class="n"&gt;v1&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;Vector2.new&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="ln"&gt;21&lt;/span&gt;&lt;span class="cl"&gt;&lt;span class="kd"&gt;local&lt;/span&gt; &lt;span class="n"&gt;v2&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;Vector2.new&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="ln"&gt;22&lt;/span&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="ln"&gt;23&lt;/span&gt;&lt;span class="cl"&gt;&lt;span class="kd"&gt;local&lt;/span&gt; &lt;span class="n"&gt;v3&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;v1&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="n"&gt;add&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;v2&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="ln"&gt;24&lt;/span&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="ln"&gt;25&lt;/span&gt;&lt;span class="cl"&gt;&lt;span class="n"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;v3&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="n"&gt;tostring&lt;/span&gt;&lt;span class="p"&gt;())&lt;/span&gt; &lt;span class="c1"&gt;-- 输出：Vector2(4.000000, 6.000000)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;strong&gt;发生了什么？&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;我们首先创建了一个&lt;code&gt;Vector2&lt;/code&gt;表，它将作为我们的类和原型。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Vector2.__index = Vector2&lt;/code&gt;是核心。当我们通过&lt;code&gt;v1:add(v2)&lt;/code&gt;调用&lt;code&gt;add&lt;/code&gt;方法时，Lua发现&lt;code&gt;v1&lt;/code&gt;中没有&lt;code&gt;add&lt;/code&gt;键。&lt;/li&gt;
&lt;li&gt;于是，它会去&lt;code&gt;v1&lt;/code&gt;的元表（也就是&lt;code&gt;Vector2&lt;/code&gt;）中查找&lt;code&gt;__index&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;__index&lt;/code&gt;指向了&lt;code&gt;Vector2&lt;/code&gt;自身，所以Lua在&lt;code&gt;Vector2&lt;/code&gt;中找到了&lt;code&gt;add&lt;/code&gt;方法并调用了它。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Vector2:add&lt;/code&gt;语法糖会把&lt;code&gt;v1&lt;/code&gt;作为&lt;code&gt;self&lt;/code&gt;参数传入，实现了方法调用。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;这种方式的优点是简单明了，容易理解。缺点是当你的类和继承关系变得复杂时，管理起来可能会有些混乱。&lt;/p&gt;</description></item></channel></rss>